## 提示
### 关于`mid`
如果用`mid=(left+right)/2`，在运行二分查找程序时可能溢出超时。

因为如果left和right相加超过int表示的最大范围时就会溢出变为负数。

所以如果想避免溢出，不能使用`mid=(left+right)/2`，应该使用`mid=left+(right-left)/2`。

### 关于`while`循环要不要取等号

如果下面逻辑中涉及到遍历指针等于`left`或者`right`的时候就需要写`=`

## NK二分查找-I
[题目来源](https://www.nowcoder.com/practice/d3df40bd23594118b57554129cadf47b?tpId=196&tqId=38364&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)



请实现无重复数字的升序数组的二分查找
给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1

题解：

> 这里有 `if(nums[mid] == target)`，所以`(left <= right)`
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return mid;
            if(nums[mid] < target) left = mid + 1;
            else 
                right = mid - 1;
        }
        return -1;
    }
};
```
时间复杂度：`O(logN)`。

空间复杂度：`O(1)`。

### 二分查找-II

[题目来源](https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=196&tqId=37163&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-total%2Fquestion-ranking&tab=answerKey)

请实现有重复数字的升序数组的二分查找
给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1

示例：

```
[1,2,4,4,5],4

2
从左到右，查找到第1个为4的，下标为2，返回2 
```

思路：

和上面一题不同，这题元素有重复

> 往左边逼近

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
            //边界条件判断
        if (nums.size() == 0)
            return -1;
        int left = 0;
        int right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;  //往左逼近
            }
        }
        return nums[left] == target ? left : -1;        
    }
};
```


## 153.寻找旋转排序数组中的最小值

[题目来源](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`

若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 互不相同 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

示例：

```cpp
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

思路：


> 通过对比与`nums[0]`的大小来将数组分成两段，可以通过二分查找来寻找旋转点

一般来说，二分查找用于解决 有序的数组 问题，**旋转排序数组**的题目比较特殊，即使在某一个点发生旋转，我们依然可以考虑直接进行二分搜索。

因为数组原本是有序的，只不过在某一点发生了旋转。所以下面使用二分搜索的时候
```
[1,2,3,4,5,6]
--->开始旋转
[6,1,2,3,4,5]
[5,6,1,2,3,4]
[4,5,6,1,2,3]
[3,4,5,6,1,2]
[2,3,4,5,6,1]
```
我们可以用中间的和最右的数进行对比，注意等号，如果：
- `nums[mid] > nums[right]` 说明最小数在右边，有`left = mid + 1`
- `nums[mid] <= nums[right]`说明最小数在左边, 有`right = mid`

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
    // - `nums[mid] > nums[right]` 说明最小数在右边，有`left = mid + 1`
    // - `nums[mid] <= nums[right]`说明最小数在左边, 有`right = mid`
        int left = 0,right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[right]) //最小值在右边
                left = mid + 1;
            else right = mid;      //最小值在左边
        }
        return nums[left];
    }
};
```

### 154.寻找旋转排序数组中的最小值 II

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,4,4,5,6,7]` 在变化后可能得到：
若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,4]`
若旋转 `7` 次，则可以得到 `[0,1,4,4,5,6,7]`
注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

示例
```
输入：nums = [1,3,5]
输出：1

输入：nums = [2,2,2,0,1]
输出：0
```

思路：

这道题和【153.寻找旋转排序数组中的最小值】 不同的是，本题元素并不唯一。

首先，创建两个指针 `left`, `right 分别指向 `numbers` 首尾数字，然后计算出两指针之间的中间索引值 `middle`，然后我们会遇到以下三种情况：

- `middle > right` ：代表最小值一定在 `middle` 右侧，所以 `left` 移到 `middle + 1` 的位置。
- `middle < right` ：代表最小值一定在 `middle` 左侧或者就是 `middle`，所以 `right` 移到 `middle` 的位置。
`middle` 既不大于 `left` 指针的值，也不小于 `right` 指针的值，代表着 `middle` 可能等于 `left` 指针的值，或者 `right` 指针的值，我们这时候只能让 `right` 指针递减，来一个一个找最小值了。



## 33.搜索旋转排序数组

[题目来源](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 `k（0 <= k < nums.length）`上进行了 旋转，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 从 0 开始 计数）。

例如，`[0,1,2,4,5,6,7]` 在下标 3 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 旋转后 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回`-1` 。


示例 
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

思路：

首先判断左边是否有序，即`if(nums[left] < nums[mid])`，如果有序再判断`target`有没有落在左边,如果无序,即`if(nums[left] > nums[mid])`，再判断`target`有没有落在右边。

**注意**：`[1,3] 2`  和`[3,1] 1` 这两个，`++left;`



```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return mid;
            //先判断左边是不是有序
            if(nums[left] < nums[mid]) {
                //判断target会落在哪边
                if(nums[left] <= target && nums[mid] > target) {
                    //在左边
                    right = mid - 1; 
                }
                else {
                    left = mid + 1;
                }
            }
            else if(nums[left] > nums[mid]){ // 左边无序,右边有序
                //判断target有没有落在右边
                if(nums[mid] < target && nums[right] >= target) {
                    left =  mid + 1;
                }
                else {
                    right = mid - 1;
                }
            }
            else {
                //[3,1] target = 1 nums[mid] = 3 不是我们需要的，且left = mid = 0，所以left也不是，所以过滤left->left++
                ++left;
            }
        }
        return -1;
    }
};
```


### 81. 搜索旋转排序数组 II

「题目来源](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。

在传递给函数之前，`nums` 在预先未知的某个下标 `k（0 <= k < nums.length）`上进行了 旋转 ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1]`, `nums[0], nums[1], ..., nums[k-1]]`（下标 从 `0` 开始 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 5 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 旋转后 的数组 nums 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

 

示例 
```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true

输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false
```

思路：

这题与上题不同，上题返回的是下标。且上题不允许元素重复。

其解题思路和上题基本一致，首先判断左边是否有序，即`if(nums[left] < nums[mid])`，如果有序再判断`target`有没有落在左边,如果无序,即`if(nums[left] > nums[mid])`，再判断`target`有没有落在右边。



```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return true;
            // 先判断左边有没有序
            if(nums[left] < nums[mid]) {
                //如果左边有序判断target是不是在左边
                if(nums[left] <= target && nums[mid] > target) {
                    right = mid - 1;
                }
                //不在左边
                else left = mid + 1;
            }
            //否则如果右边有序
            else if(nums[mid] < nums[left]){
                //判断target是否在右边
                if(nums[mid] < target && nums[right] >= target) {
                    left = mid + 1;
                }
                //否则在左边
                else 
                    right = mid - 1;
            }
            else {
                ++left;
            }
        }
        return false;
    }
};
```

