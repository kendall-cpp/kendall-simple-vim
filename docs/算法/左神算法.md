
- [排序算法](#排序算法)
  - [冒泡排序](#冒泡排序)
  - [插入排序](#插入排序)
  - [归并排序](#归并排序)
    - [剑指 Offer 51. 数组中的逆序对](#剑指-offer-51-数组中的逆序对)
  - [快速排序](#快速排序)
    - [分治问题](#分治问题)
    - [快速排序实现](#快速排序实现)
  - [堆排序](#堆排序)
  - [桶排序](#桶排序)
    - [计数排序(没有负数)](#计数排序没有负数)
    - [找桶（不懂）](#找桶不懂)
- [队列和栈](#队列和栈)
  - [剑指 Offer 30. 包含min函数的栈](#剑指-offer-30-包含min函数的栈)
  - [队列实现栈](#队列实现栈)

------

## 排序算法

[leetcode 912](https://leetcode-cn.com/problems/sort-an-array/)

### 冒泡排序

一开始一个指针指向最后，然后排好一遍就往前移

开始冒泡，就是当前元素和下一个比较，如果比下一个大，就交换

```cpp
void BubbleSort(vector<int> &nums) {
    // 为空或者只有一个数，不需要排序
    if(nums.size() < 2) {
        return ;
    }
    //一开始指针指向最后一个位置
    for(int end = nums.size() - 1; end>=0; --end) {
        for(int i=0;i<end;++i) {
            if(nums[i] > nums[i+1]) {
                swap(nums[i],nums[i+1]);
            }
        }
    }
}
```

时间复杂度： O(N)

空间复杂度：O(1)

### 插入排序

> 左边不动，右边插入

从当前位置 i=1「第二个」 开始，左边的数已经排好了，当前数和前面一个比较，小于就交换，否则就停，并插入

```cpp
void InsertSort(vector<int> &nums) {
    if(nums.size() < 2 ) {
        return;
    }
    //从位置i开始，左边的数是排好序的
    for(int i=1;i<nums.size();++i) {
        for(int j=i-1;j>=0;--j) {
            if(nums[j+1] < nums[j]) {
                //注意这里不是用 i
                swap(nums[j],nums[j+1]);
            }
        }
    }
}
```

时间复杂度：$O(N)$ ，最好，$O(N^2)$，最差

时间复杂度：$O(1)$

### 归并排序

> 归并排序，快速排序，堆排序，时间复杂度都是 $O(nlog^n)$

先递归排好左边 和 右边

再 merge 排序两个数组

```cpp
void merge(vector<int>& nums, int left, int mid , int right){
    //注意 pl 是 left， pr 是 mid+1，不是 right
    int pl = left;
    int pr = mid +1;
    int index = 0;
    vector<int> temp(right-left+1);
    while(pl<=mid && pr<=right){
        if(nums[pl] <= nums[pr]){
            temp[index++] = nums[pl++];
        }else{
            temp[index++] = nums[pr++];
        }
    }
    while(pl<= mid){
        temp[index++] = nums[pl++];
    }
    while(pr<=right){
        temp[index++] = nums[pr++];
    }
    //拷贝回去
    int i = left;
    for(auto x : temp) {
        nums[i++] = x;
    }
    // int k = 0;
    // for(int i=left;i<=right;i++){
    //     nums[i] = temp[k++];
    // }
}
void sortProcess(vector<int>& nums, int left, int right){
    if(left<right){
        int mid = left + ((right-left)>>1);
        sortProcess(nums,left,mid);
        sortProcess(nums,mid+1,right);
        merge(nums,left,mid,right);
    }
}
vector<int> sortMerge(vector<int>& nums) {
    sortProcess(nums,0,nums.size()-1);
    return nums;
}
```

空间复杂度：O(N)

#### 剑指 Offer 51. 数组中的逆序对

[leetcode](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

```
输入: [7,5,6,4]
输出: 5
```

归并排序思想

> 注意：计算左面区间和右面区间够成逆序对的数量。此行原因只要有第一个位置大于时，肯定也大于左边后面的元素        
> 比如：2 5 7 | 1 3 4      
> 5 比 3 大，那么肯定 5 后面的 7 肯定也比 3 大，因此 ans = mid(中间位置) - left(左边遍历指针) + 1

```cpp
class Solution {
public:
    int ans = 0;
    void merge(vector<int>& nums, int left, int mid , int right){
        //注意 pl 是 left， pr 是 mid+1，不是 right
        int pl = left;
        int pr = mid +1;
        int index = 0;
        vector<int> temp(right-left+1);
        while(pl<=mid && pr<=right){
            if(nums[pl] <= nums[pr]){
                temp[index++] = nums[pl++];
            }else{
                temp[index++] = nums[pr++];
                //左边的比左边的大， 记录
                ans += (mid - pl + 1);
                //计算左面区间和右面区间够成逆序对的数量。此行原因只要有第一个位置大于时，肯定也大于左边后面的元素
            }
        }
        while(pl<= mid){
            temp[index++] = nums[pl++];
        }
        while(pr<=right){
            temp[index++] = nums[pr++];
        }
        //拷贝回去
        int i = left;
        for(auto x : temp) {
            nums[i++] = x;
        }
        // int k = 0;
        // for(int i=left;i<=right;i++){
        //     nums[i] = temp[k++];
        // }
    }
    void sortProcess(vector<int>& nums, int left, int right){
        if(left<right){
            int mid = left + ((right-left)>>1);
            sortProcess(nums,left,mid);
            sortProcess(nums,mid+1,right);
            merge(nums,left,mid,right);
        }
    }
    int reversePairs(vector<int>& nums) {
         sortProcess(nums, 0, nums.size() - 1);
         return ans;
    }
};
```

### 快速排序

#### 分治问题

把大于最右边的数放在最左边，把大于最右边的数放在右边，相等的数放在中间

```cpp
//传的是 0 和 size() - 1
vector<int>  partition(vector<int> &nums,int left,int right) {
    
    int less = left - 1;  //小于区域的指针
    int more = right;     // 大于区域的指针，最后一个数显划分到大于区域里面
    while(left < more) {
        // 如果当前数小于等于最右边的数，当前数和小于区的下一个数交换，小于区域右移，当前指针右移
        if(nums[left] < nums[right]) {
            swap(nums[++less],nums[left++] );
        }
        //如果当前数大于右边的值，当前值和大于区的左边一个交换，大于区左移,当前指针不动
        else if(nums[left] > nums[right] ) {
            swap(nums[left],nums[--more]);
        }
        // 如果相等，啥也不做，只是当期那指针右移
        else {
            ++left;
        }
    }
    //最后交换最右的值和大于区的最左值
    swap(nums[more],nums[right]);
    //返回相等的两个索引
    vector<int> ans {less + 1,more};
    return ans;
    
}
int main() 
{
	vector<int> nums = {3,4,5,6,0,4};
	for(int i=0;i<nums.size();++i)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
    vector<int> ans = partition(nums,0,nums.size() - 1);
	for(int i=0;i<nums.size();++i)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
    cout << ans[0] << " -- ";
    cout << ans[1] << endl;
    return  0;

}
```

运行结果：

```
3 4 5 6 0 4 
3 0 4 4 5 6 
2 -- 3
```

#### 快速排序实现

```cpp
vector<int> partition(vector<int> &nums,int left,int right) {
    int less = left - 1;
    int more = right;
    while(left < more) {
        if(nums[left] < nums[right]) {
            swap(nums[++less],nums[left++]);
        }
        else if(nums[left] > nums[right]) {
            swap(nums[left],nums[--more]);
        }
        else {
            ++left;
        }
    }
    //记得交换最后一个数
    swap(nums[more],nums[right]);
    vector<int> ans {less+1,more};
    return ans;
}

void quickSort(vector<int> &nums,int left,int right) {
    if(left >= right) return;
    //随机取一个数
    // swap( nums[right], nums[rand() % (right - left + 1) + left] );

    vector<int> indexs = partition(nums,left,right);
    quickSort(nums,left, indexs[0]-1);
    quickSort(nums,indexs[1]+1,right);
}
void mySort(vector<int> &nums) {
    if(nums.size() < 2) return;
    quickSort(nums,0,nums.size() - 1);
}
```

空间复杂度：O(logn)   最好的时候，记录中间点的位置，最差 O(N)



### 堆排序

数组与堆节点索引对关系：

对于第 i 位置的索引

左孩子：$2*i+1$      
右孩子：$2*i+2$           
父亲节点：$\frac{i-1}{2}$

```cpp
//移除节点
// 让第一个数和最后一个数交换 堆大小减一
// 从头结点开始向下调整的过程
// 和自己的孩子比较， 和最大的孩子交换
void heapify(vector<int> &nums,int index, int heapSize) {
    //取左孩子下标，右孩子下标就是左孩子+1
    int left = index * 2 + 1;
    while(left < heapSize) {
        //找出孩子节点的最大值，还有保证又孩子不越界
        int largest = left + 1 < heapSize && nums[left+1] > nums[left]
                 ? left + 1
                 : left ;  
        //不能写成下面这样，因为这里主要是为了取右孩子
        // int largest = left + 1 < heapSize && nums[left] > nums[left + 1] ? left : left + 1;  
        largest = nums[largest] > nums[index] ? largest : index;
        if(largest == index) 
            break;  //最大值还是父节点，就结束了
        swap(nums[index],nums[largest]);
        index = largest;
        left = index * 2 + 1;
    }
}

//建立大根堆
//如果当前节点比父亲接节点大，就和父亲节点交换，指针指向父亲节点
 void heapInsert(vector<int> &nums,int index) {
     //当前位置比父节点位置要大，就交换
     while(nums[index] > nums[ (index - 1) / 2 ]) {
         swap(nums[index],nums[ (index - 1) / 2 ]);
         //指针指向父节点 
         index = (index - 1) / 2;
     }
 }

void heapSort(vector<int> &nums) {
    if(nums.size() < 2) return;
    //建堆,将每个节点都插入完全二叉树
    for(int i=0;i<nums.size();++i) {
        heapInsert(nums,i);
    }
    //堆的大小
    int heapSize = nums.size();
    //最大值后最后一个交换
    swap(nums[0],nums[--heapSize]);

    //一直删除堆
    while(heapSize > 0) {
        heapify(nums,0,heapSize);
        swap(nums[0],nums[--heapSize]);
    }
     
}

int main() 
{
	vector<int> nums = {3,4,5,6,0,4};
	for(int i=0;i<nums.size();++i)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
    heapSort(nums);
	for(int i=0;i<nums.size();++i)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
    // cout << ans[0] << " -- ";
    // cout << ans[1] << endl;
    return  0;

}
```
### 桶排序

#### 计数排序(没有负数)

先求最大的数，最大的数作为桶的个数

装桶，将桶的数据倒回原数组

```cpp
void bucketSort(vector<int> &nums) {
    if(nums.size() < 2) return;
    int maxNum = INT_MIN;
    //找到这批数中最大的数
    for(int i=0;i<nums.size();++i) {
        maxNum = max(nums[i],maxNum);
    }
    //定义一个桶，大小为 maxNum+1
    vector<int> bucket(maxNum+1,0);

    //装桶过程
    // 对应的桶++，记录这个数有多少个
    for(int i=0;i<nums.size();++i) {
        bucket[nums[i]]++;
    }

    //倒桶过程，倒回原来的数组去
    int index = 0;
    for(int j=0;j<bucket.size();++j) {
        while(bucket[j]-- > 0) {
            nums[index++] = j;
        }
    }
}
```

#### 找桶（不懂）

```cpp

int bucket(long num, long len, long min, long max) {
    return (int) ((num - min) * len / (max - min));
}
int getMaxMap(vector<int> &nums) {
    if(nums.size() < 2 ) return 0;
    //记录有几个数
    int len = nums.size();
    // 记录最大值
    int maxn = INT_MIN;
    //记录最小值
    int minn = INT_MAX;
    // 遍历找到最大值和最小值
    for(int i=0;i<len;++i) {
        minn = min(nums[i],minn);
        maxn = max(nums[i],maxn);
    }
    // 如果最大值和最小值相等，说明就一组数
    if(minn == maxn) {
        return 0;
    }
    //记录这个桶有没有数进来
    vector<bool> hasNum (len,false);
    //记录每个桶的最大值和最小值
    vector<int> minNums (len + 1);
    vector<int> maxNums (len + 1);
    int bid = 0;  //记录放在哪个桶
    for(int i=0;i<len;++i) {
        bid = bucket(nums[i],len,minn,maxn);
        minNums[bid] = hasNum[bid] ? min(minNums[bid],nums[i]) : nums[i];
        maxNums[bid] = hasNum[bid] ? max(maxNums[bid],nums[i] ) : nums[i];
        hasNum[i] = true;
    }
    int res = 0;
    int lastMax = maxNums[0];
    int i = 1;
    for(;i <- len;++i) {
        if(hasNum[i]) {
            res = max(res,minNums[i] - lastMax);
            lastMax = maxNums[i];
        }
    }
    return res;
}
```

## 队列和栈

### 剑指 Offer 30. 包含min函数的栈

[leetcode](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/submissions/)

构造函数 最小栈 进入一个最大值，方便后面比较

入栈，如果小于最小栈栈顶元素，就入最小栈，否则，最小栈栈再次入栈。

数据栈正常入栈出栈

```cpp
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
        stackMin.push(INT_MAX);
    }
    
    void push(int x) {
        stackData.push(x);
        int temp = stackMin.top() < x ? stackMin.top() : x ;
        stackMin.push(temp);
    }
    
    void pop() {
        stackData.pop();
        stackMin.pop();
    }
    
    int top() {
        return stackData.top();
    }
    
    int min() {
        return stackMin.top();
    }
private:
    stack<int> stackData;
    stack<int> stackMin;
};
```

### 队列实现栈

[leetcode](https://leetcode-cn.com/problems/implement-stack-using-queues/submissions/)

思路：

在 pop 方法中先把 queueIn 中的元素移入 queueOut 中，剩下最后一个元素就是出队元素，然后再将元素从 queueOut 中移回 queueIn 中。

```cpp
class MyStack {
public:
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        queData.push(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        while(queData.size() > 1) {
            queTemp.push(queData.front());
            queData.pop();
        }
        int ans = queData.front();
        queData.pop();
        //记得把数据加回数据队列中
        while(queTemp.size() > 0) {
            queData.push(queTemp.front());
            queTemp.pop();
        }
        return ans;
    }
    
    /** Get the top element. */
    int top() {
        //先删除再插入
        int ans = pop();
        queData.push(ans);
        return ans;
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return queData.empty() && queTemp.empty();
    }
private:
    queue<int> queData;
    queue<int> queTemp;
};
```