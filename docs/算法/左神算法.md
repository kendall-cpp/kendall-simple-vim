
- [排序算法](#排序算法)
  - [冒泡排序](#冒泡排序)
  - [插入排序](#插入排序)
  - [归并排序](#归并排序)
    - [剑指 Offer 51. 数组中的逆序对](#剑指-offer-51-数组中的逆序对)

------

## 排序算法

[leetcode 912](https://leetcode-cn.com/problems/sort-an-array/)

### 冒泡排序

一开始一个指针指向最后，然后排好一遍就往前移

开始冒泡，就是当前元素和下一个比较，如果比下一个大，就交换

```cpp
void BubbleSort(vector<int> &nums) {
    // 为空或者只有一个数，不需要排序
    if(nums.size() < 2) {
        return ;
    }
    //一开始指针指向最后一个位置
    for(int end = nums.size() - 1; end>=0; --end) {
        for(int i=0;i<end;++i) {
            if(nums[i] > nums[i+1]) {
                swap(nums[i],nums[i+1]);
            }
        }
    }
}
```

时间复杂度： O(N)

空间复杂度：O(1)

### 插入排序

从当前位置 i=1「第二个」 开始，左边的数已经排好了，当前数和前面一个比较，小于就交换，否则就停，并插入

```cpp
void InsertSort(vector<int> &nums) {
    if(nums.size() < 2 ) {
        return;
    }
    //从位置i开始，左边的数是排好序的
    for(int i=1;i<nums.size();++i) {
        for(int j=i-1;j>=0;--j) {
            if(nums[j+1] < nums[j]) {
                //注意这里不是用 i
                swap(nums[j],nums[j+1]);
            }
        }
    }
}
```

时间复杂度：$O(N)$ ，最好，$O(N^2)$，最差

时间复杂度：$O(1)$

### 归并排序

> 归并排序，快速排序，堆排序，时间复杂度都是 $O(nlog^n)$

先递归排好左边 和 右边

再 merge 排序两个数组

```cpp
void merge(vector<int>& nums, int left, int mid , int right){
    //注意 pl 是 left， pr 是 mid+1，不是 right
    int pl = left;
    int pr = mid +1;
    int index = 0;
    vector<int> temp(right-left+1);
    while(pl<=mid && pr<=right){
        if(nums[pl] <= nums[pr]){
            temp[index++] = nums[pl++];
        }else{
            temp[index++] = nums[pr++];
        }
    }
    while(pl<= mid){
        temp[index++] = nums[pl++];
    }
    while(pr<=right){
        temp[index++] = nums[pr++];
    }
    //拷贝回去
    int i = left;
    for(auto x : temp) {
        nums[i++] = x;
    }
    // int k = 0;
    // for(int i=left;i<=right;i++){
    //     nums[i] = temp[k++];
    // }
}
void sortProcess(vector<int>& nums, int left, int right){
    if(left<right){
        int mid = left + ((right-left)>>1);
        sortProcess(nums,left,mid);
        sortProcess(nums,mid+1,right);
        merge(nums,left,mid,right);
    }
}
vector<int> sortMerge(vector<int>& nums) {
    sortProcess(nums,0,nums.size()-1);
    return nums;
}
```

#### 剑指 Offer 51. 数组中的逆序对

[leetcode](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

```
输入: [7,5,6,4]
输出: 5
```

归并排序思想

> 注意：计算左面区间和右面区间够成逆序对的数量。此行原因只要有第一个位置大于时，肯定也大于左边后面的元素        
> 比如：2 5 7 | 1 3 4      
> 5 比 3 大，那么肯定 5 后面的 7 肯定也比 3 大，因此 ans = mid(中间位置) - left(左边遍历指针) + 1

```cpp
class Solution {
public:
    int ans = 0;
    void merge(vector<int>& nums, int left, int mid , int right){
        //注意 pl 是 left， pr 是 mid+1，不是 right
        int pl = left;
        int pr = mid +1;
        int index = 0;
        vector<int> temp(right-left+1);
        while(pl<=mid && pr<=right){
            if(nums[pl] <= nums[pr]){
                temp[index++] = nums[pl++];
            }else{
                temp[index++] = nums[pr++];
                //左边的比左边的大， 记录
                ans += (mid - pl + 1);
                //计算左面区间和右面区间够成逆序对的数量。此行原因只要有第一个位置大于时，肯定也大于左边后面的元素
            }
        }
        while(pl<= mid){
            temp[index++] = nums[pl++];
        }
        while(pr<=right){
            temp[index++] = nums[pr++];
        }
        //拷贝回去
        int i = left;
        for(auto x : temp) {
            nums[i++] = x;
        }
        // int k = 0;
        // for(int i=left;i<=right;i++){
        //     nums[i] = temp[k++];
        // }
    }
    void sortProcess(vector<int>& nums, int left, int right){
        if(left<right){
            int mid = left + ((right-left)>>1);
            sortProcess(nums,left,mid);
            sortProcess(nums,mid+1,right);
            merge(nums,left,mid,right);
        }
    }
    int reversePairs(vector<int>& nums) {
         sortProcess(nums, 0, nums.size() - 1);
         return ans;
    }
};
```




