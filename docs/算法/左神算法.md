

------

## 排序算法

### 冒泡排序

一开始一个指针指向最后，然后排好一遍就往前移

开始冒泡，就是当前元素和下一个比较，如果比下一个大，就交换

```cpp
void BubbleSort(vector<int> &nums) {
    // 为空或者只有一个数，不需要排序
    if(nums.size() < 2) {
        return ;
    }
    //一开始指针指向最后一个位置
    for(int end = nums.size() - 1; end>=0; --end) {
        for(int i=0;i<end;++i) {
            if(nums[i] > nums[i+1]) {
                swap(nums[i],nums[i+1]);
            }
        }
    }
}
```

时间复杂度： O(N)

空间复杂度：O(1)

### 插入排序

从当前位置 i=1「第二个」 开始，左边的数已经排好了，当前数和前面一个比较，小于就交换，否则就停，并插入

```cpp
void InsertSort(vector<int> &nums) {
    if(nums.size() < 2 ) {
        return;
    }
    //从位置i开始，左边的数是排好序的
    for(int i=1;i<nums.size();++i) {
        for(int j=i-1;j>=0;--j) {
            if(nums[j+1] < nums[j]) {
                //注意这里不是用 i
                swap(nums[j],nums[j+1]);
            }
        }
    }
}
```

时间复杂度：$O(N)$ ，最好，$O(N^2)$，最差

时间复杂度：$O(1)$

### 归并排序

> 归并排序，快速排序，堆排序，时间复杂度都是 $O(nlog^n)$

先递归排好左边 和 右边

再 merge 排序两个数组

```cpp
//函数声明
void myMergeSort(vector<int> &nums,int left,int right);
void merge(vector<int> &nums,int left,int mid,int right);

void mergeSort(vector<int> nums) {
    if(nums.size() < 2) {
        return ;
    }
    int left = 0,right = nums.size() - 1;
    myMergeSort(nums,left,right);
}
void myMergeSort(vector<int> &nums,int left,int right) {
    if(left <= right) {
        return ;
    }
    int mid = left + (right - left) / 2;  //左移就是 除 2的多少次方
    myMergeSort(nums,left,mid);
    myMergeSort(nums,mid+1,right);
    merge(nums,left,mid,right);
}
//两个指针，小的放入新数组，右移
void merge(vector<int> &nums,int left,int mid,int right) {
    int pl = left, pr = mid + 1;
    // vector<int> temp(right - left + 1,0);
    vector<int> temp;
    while(pl <= mid && pr <= right) {
        if(nums[pl] < nums[pr]) {
            temp.push_back(nums[pl]);
            ++pl;
        }
        else {
            temp.push_back(nums[pr]);
            ++pr;
        }
    }
    while(pl <= mid) {
        temp.push_back(nums[pl++]);
    }
    while(pr <= right) {
        temp.push_back(nums[pr++]);
    }
    //拷贝回去
    for(int i=0;i<temp.size();++i) {
        nums[left + 1] = temp[i];
    }
}
```

