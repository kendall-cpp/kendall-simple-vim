

----

> [点击选择百度](https://www.nowcoder.com/ta/job-code-high?company=139)

## NC140 排序

[牛客地址](https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=117&&tqId=37851&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

### 快速排序

```cpp
class Solution {
public:
    vector<int> MySort(vector<int>& arr) {
        int left = 0,right = arr.size() - 1;
        quickSort(arr,left,right);
        return arr;
    }
    void quickSort(vector<int> &nums,int left,int right) {
        if(left < right) {
            int index = partition(nums,left,right);
            quickSort(nums, left, index - 1);
            quickSort(nums, index + 1, right);
        }
    }
    int partition(vector<int> &nums,int left,int right) {
        swap( nums[left], nums[rand() % (right - left + 1) + left] );
        int prev = nums[left];
        while(left < right) {
            while(left < right && nums[right] >= prev) {
                --right;
            }
            nums[left] = nums[right];
            while(left < right && nums[left] <= prev) {
                ++left;
            }
            nums[right] = nums[left];
        }
        nums[left] = prev;
        return left;
    }
};
```

### 归并排序

### 堆排序

### 冒泡排序

## 树的遍历

### 前序遍历

### 中序遍历

### 后序遍历

### 层次遍历

## 设计 LRU 缓存结构

## NC119 最小的K个数

[牛客网址](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=117&&tqId=37765&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

寻找没有排序的数组中的最小的 K 个数

思路：

根据快排的的规律，prev 的左边比 prev 小，右边比 prev 大。

找到 prev 在 K-1 位置，用迭代器取 `begin()` 到 `begin() + 1`

```cpp
class Solution {
public:
    int n;
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        n = k;
        int left = 0,right = input.size() - 1;
        quickSort(input,left,right);
        vector<int> ans(input.begin(),input.begin() + k);
        return ans;
    }
    void quickSort(vector<int> &nums, int left,int right) {
        if(left < right) {
            int index = partition(nums,left,right);
            if(index == n-1) {
                return ;
            }
            else if(index > n-1) {
                quickSort(nums, left, index - 1);
            }
            else {
                quickSort(nums, index + 1, right);
            }
        }
    }
    int partition(vector<int> &nums, int left,int right) {
//         swap(nums[left], nums[ rand() % (right - left + 1) + left ]);
        int prev = nums[left];
        while(left < right) {
            while(left < right && nums[right] >= prev) {
                --right;
            }
            nums[left] = nums[right];
            while(left < right && nums[left] <= prev) {
                ++left;
            }
            nums[right] = nums[left];
        }
        nums[left] = prev;
        return left;
    }
};
```