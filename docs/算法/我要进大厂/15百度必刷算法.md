
- [NC140 排序](#nc140-排序)
  - [快速排序](#快速排序)
  - [归并排序](#归并排序)
  - [堆排序](#堆排序)
  - [冒泡排序](#冒泡排序)
- [树的遍历](#树的遍历)
  - [前序遍历](#前序遍历)
  - [中序遍历](#中序遍历)
  - [后序遍历](#后序遍历)
  - [层次遍历](#层次遍历)
- [设计LRU缓存结构](#设计lru缓存结构)
- [NC119 最小的K个数](#nc119-最小的k个数)
- [NC88 寻找第K大](#nc88-寻找第k大)
- [NC61 两数之和](#nc61-两数之和)
- [NC33 合并两个排序的链表](#nc33-合并两个排序的链表)
- [NC76 用两个栈实现队列](#nc76-用两个栈实现队列)
- [NC68 跳台阶](#nc68-跳台阶)
- [NC50 链表中的节点每k个一组翻转](#nc50-链表中的节点每k个一组翻转)

----

> [点击选择百度](https://www.nowcoder.com/ta/job-code-high?company=139)

## NC140 排序

[牛客地址](https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=117&&tqId=37851&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

### 快速排序

```cpp
class Solution {
public:
    vector<int> MySort(vector<int>& arr) {
        int left = 0,right = arr.size() - 1;
        quickSort(arr,left,right);
        return arr;
    }
    void quickSort(vector<int> &nums,int left,int right) {
        if(left < right) {
            int index = partition(nums,left,right);
            quickSort(nums, left, index - 1);
            quickSort(nums, index + 1, right);
        }
    }
    int partition(vector<int> &nums,int left,int right) {
        swap( nums[left], nums[rand() % (right - left + 1) + left] );
        int prev = nums[left];
        while(left < right) {
            while(left < right && nums[right] >= prev) {
                --right;
            }
            nums[left] = nums[right];
            while(left < right && nums[left] <= prev) {
                ++left;
            }
            nums[right] = nums[left];
        }
        nums[left] = prev;
        return left;
    }
};
```

### 归并排序

### 堆排序

### 冒泡排序

## 树的遍历

### 前序遍历

### 中序遍历

### 后序遍历

### 层次遍历


## 设计LRU缓存结构

方法：使用 哈希表+双向链表

```cpp
LRUCache cache = new LRUCache(2);  //2 是缓存容量
cache.push(1,1);
cache.push(2,2);
cache.get(1);   //返回 1
cache.push(3,3);  //会先删掉(2,2),再插入（3，3）
```

先假设一个缓冲容量为 2 的LRU缓存。这里双向链表的 `tail` 方向是最近使用的元素。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/LRU-01.215c53yhmqcg.png)

- 首先执行`cache.push(1,1);`: 此时链表加入节点 1 ，哈希表也加入一个节点，并且指向链表的第一个节点。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/LRU-02.4m9qomp2rou0.png)

- 执行`cache.push(2,2);`

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/LRU-03.5j3weh9xmpg0.png)

- `cache.get(1);`: 因为访问了节点 1 ，所以节点 1 移动到尾部。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/LRU-04.16bxykif3t6o.png)

- `cache.push(3,3);`: 由于容量达到了上线，我们先进行删除操作，先删除`node 2`,再插入`node 3`。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/LRU-05.4omf4o5lqnm0.png)


```cpp
#include <iostream>
#include <cstdio>
#include <list>
#include <unordered_map>

using namespace std;

class LRUCache {
public:
    LRUCache(int capacity)
        : cap(capacity) {}

    // 先找hash table，如有，复制到头部，再删除原有位置元素
    int get(int key)
    {
        auto it = mp.find(key);  //返回的是迭代器
        // 如果找不到就直接返回
        if (it == mp.end()) return -1;

        // 获取value的值
        auto target_it = it->second;  
        // 定义一个pair对保存key,value,注意这里赋值用{}
        pair<int, int> n {target_it->first, target_it->second};
        cache.push_front(n);
        cache.erase(target_it);  //删除
        mp.erase(key);
        //添加
        mp.emplace(key, cache.begin());

        return n.second;
    }

    // 先通过哈希表检查cache里是否已存在相同key， 有则删除，不管有没有都要把新 key 和 value 对放至头部, 如超出容量则再弹出末尾
    void put(int key, int value)
    {
        // unordered_map<int, list<pair<int, int>>::iterator>::iterator it= mp.find(key);
        auto it = mp.find(key);
        //如果找到了
        //这里必须先删除列表再删除哈希表，因为链表是存在map的value中的。
        if (it != mp.end()) {
            //缓冲中先删除这个节点
            cache.erase(it->second);
            // 哈希表中删除这个key
            mp.erase(key);
        }

        //然后再插入到队头
        // list<pair<int,int>>::iterator target_it = it->second;
        pair<int, int> n {key, value};
        cache.push_front(n);
        mp.emplace(key, cache.begin());

        // 如果容量已经超出上限了，删除队尾元素
        if (cache.size() > cap) {
            mp.erase(cache.back().first);
            cache.pop_back();
        }
    }

    // 打印
    void show()
    {
        for (auto kv : cache) {
            // printf("%d:%d, ", kv.first, kv.second);
            cout << kv.first << ":" << kv.second << "  ";
        }
        // printf("  mp size: %zu\n", mp.size());
        cout << "   mp_size = " << mp.size() << endl;
    }
    
private:
    int cap = 0; //缓存容量
    list<pair<int, int>> cache;  //双向链表
    unordered_map<int, list<pair<int, int>>::iterator> mp;
};

int main() {
    LRUCache *lru = new LRUCache(2);
    // lru->cache[0] = {0,1};
    lru->put(1,1);
    lru->put(2,2);

    lru->show();
    int ret = lru->get(1);
    cout << "get(1) : " << ret << endl;
    lru->show();
    lru->set(3,3);
    lru->show();
    return 0;
}
```

[leetcode题目](https://leetcode-cn.com/problems/lru-cache-lcci/submissions/)

```cpp
class LRUCache {
public:
    LRUCache(int capacity) 
    : cap(capacity)
    {

    }
    
    //查找一个元素，先查找hash table,如果有就复制到表头，然后再删除原来的位置
    int get(int key) {
        unordered_map<int,list<pair<int,int>>::iterator >::iterator it = mp.find(key);
        // 如果找不到就直接返回
        if(it == mp.end()) {
            return -1;
        }

        // 如果找到就将其复制到表头再删除原有的位置
        // 获取value值
        auto target_it = it->second;  //mp里的value是pair对
        // 获取链表里面的每个节点的键值对
        pair<int,int> n = {target_it->first,target_it->second};
        
        //先插入到表头
        cache.push_front(n);
        //删除原来的位置
        cache.erase(target_it);
        mp.erase(key);
        //插入开始位置的key
        mp.emplace(key,cache.begin());



        return n.second;
    }
    //写入数据
    // 先通过哈希表检查cache里是否已存在相同key， 有则删除，
    //不管有没有都要把新 key 和 value 对放至头部, 如超出容量则再弹出末尾
    void put(int key, int value) {
        auto it = mp.find(key);
        //如果找到了，需要放到队头
        if(it != mp.end()) {
            //缓冲区中先删除这个节点
            cache.erase(it->second);
            mp.erase(key);
        }

        //然后插入到队头
        pair<int,int> n{key,value};
        cache.push_front(n);
        mp.emplace(key,cache.begin());

        // 如果容量已经超出上限了，删除队尾元素
        if (cache.size() > cap) {
            mp.erase(cache.back().first);
            cache.pop_back();
        }
    }
private:
    //缓存容量
    int cap = 0;
    //双向链表
    list<pair<int,int>> cache;  
    //哈希表 unorder_map是有序的，map是无序的
    unordered_map<int,list<pair<int,int>>::iterator> mp;
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

[牛客题目](https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&tqId=37804&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

```cpp
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        cap = k;  //缓冲区的长度
        vector<int> ans;
        for(auto &nums : operators) {  //nums是每个数组
            if(nums[0] == 1) {
                set(nums[1],nums[2]);
            }else {  //获取
                ans.push_back(get(nums[1]));
            }
        }
        return ans;
    }
    //获取
    //先查找哈希表，如果没有就结束，有就复制到头部，再删除原有位置元素
    int get(int key) {
        
        auto it = mp.find(key);
        //如果在哈希表中找不到，那就直接返回找不到
        if(it == mp.end()) {
            return -1;
        }
        
        //如果存在
        
         //value的值 cache的一个节点
        auto target_it = it->second;
        //定义一个pari对
        pair<int,int> n{target_it->first,target_it->second};
        //缓冲区中先插入
        cache.push_front(n);
        //删除
        cache.erase(target_it);
        mp.erase(key);
        //哈希表中插入
        mp.emplace(key,cache.begin());
        
        
        return n.second;
    }
    r
    void set(int key,int value) {
        auto it = mp.find(key);
        
        //如果有就删除
        if(it != mp.end()) {
            cache.erase(it->second);
            mp.erase(key);
        }
        //然后再队头插入
        pair<int, int> n{key,value};
        cache.push_front(n);
        mp.emplace(key,cache.begin());
        
        //如果有容量已经到达上限，就弹出队尾
        if(cap < cache.size()) {
            mp.erase(cache.back().first);
            cache.pop_back();
        }
    }
    
private:
    int cap = 0;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator > mp;
};
```



## NC119 最小的K个数

[牛客网址](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=117&&tqId=37765&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

寻找没有排序的数组中的最小的 K 个数

思路：

根据快排的的规律，prev 的左边比 prev 小，右边比 prev 大。

找到 prev 在 K-1 位置，用迭代器取 `begin()` 到 `begin() + 1`

```cpp
class Solution {
public:
    int n;
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        n = k;
        int left = 0,right = input.size() - 1;
        quickSort(input,left,right);
        vector<int> ans(input.begin(),input.begin() + k);
        return ans;
    }
    void quickSort(vector<int> &nums, int left,int right) {
        if(left < right) {
            int index = partition(nums,left,right);
            //注意这里是 n-1 ，因为所以缩影从 0 开始
            if(index == n-1) {
                return ;
            }
            else if(index > n-1) {
                quickSort(nums, left, index - 1);
            }
            else {
                quickSort(nums, index + 1, right);
            }
        }
    }
    int partition(vector<int> &nums, int left,int right) {
//         swap(nums[left], nums[ rand() % (right - left + 1) + left ]);
        int prev = nums[left];
        while(left < right) {
            while(left < right && nums[right] >= prev) {
                --right;
            }
            nums[left] = nums[right];
            while(left < right && nums[left] <= prev) {
                ++left;
            }
            nums[right] = nums[left];
        }
        nums[left] = prev;
        return left;
    }
};
```

## NC88 寻找第K大

[牛客网址](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=117&&tqId=37791&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

有一个整数数组，请你根据快速排序的思路，找出数组中第 大的数。

给定一个整数数组 ,同时给定它的大小n和要找的 ，请返回第 大的数(包括重复的元素，不用去重)，保证答案存在。
要求时间复杂度 O(n)

```
输入：[1,3,5,2,2],5,3
输出：2
```

> 使用快速排序思想可解

## NC61 两数之和

[牛客链接](https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=117&&tqId=37756&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

示例 1：
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

- 使用哈希表来保存，每次先检查 `target-nums[i]` 有没有在哈希表里面，如果有直接返回。


```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> ans;
        unordered_map<int, int> mp;
        for(int i=0;i<numbers.size();++i) {
            if(mp.count(target-numbers[i]) != 0) {
                ans.push_back(mp[target-numbers[i]] + 1);
                ans.push_back(i + 1);
                break;
            }
            mp[numbers[i]] = i;
        }
        return ans;
    }
};
```

## NC33 合并两个排序的链表

[牛客链接](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=117&&tqId=37735&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```cpp
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        ListNode * dumpy = new ListNode(-1);
        ListNode *p = dumpy;
        ListNode *p1 = pHead1,*p2 = pHead2;
        while(p1 && p2) {
            if(p1->val < p2->val) {
                p->next = p1;
                p = p1;
                p1 = p1->next;
            }
            else {
                p->next = p2;
                p = p2;
                p2 = p2->next;
            }
        }
        if(p1) {
            p->next = p1;
        }
        if(p2) {
            p->next = p2;
        }
        return dumpy->next;
    }
};
```
## NC76 用两个栈实现队列

[牛客链接](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=117&&tqId=37774&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```cpp
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    //先判断栈 2 是否为空，把栈2出完，再把栈1全部灌入栈2，再输出
    int pop() {
        int ans;
        if(!stack2.empty()) {
            ans = stack2.top();
            stack2.pop();
        }
        else {
            while(!stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
            ans =  stack2.top();        
            stack2.pop();
        }

        return ans;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

## NC68 跳台阶

[牛客链接](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=117&&tqId=37764&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```
输入：2
输出：2

输入：7
输出：21
```

动态规划思想，维护两个数即可

```cpp
class Solution {
public:
    int jumpFloor(int number) {
        if( number <= 2) return number;
        int dp_i_1 = 1;
        int dp_i_2 = 2;
        int dp;
        for(int i=3; i<=number;++i) {
            dp = dp_i_1 + dp_i_2;
            dp_i_1 = dp_i_2;
            dp_i_2 = dp;
        }
        return dp;
    }
};
```

## NC50 链表中的节点每k个一组翻转

[牛客链接](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=117&&tqId=37746&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)

```
输入：{1,2,3,4,5},2
输出：{2,1,4,3,5}
```

需要设置一个虚拟头结点

具体见图

- 初始化指针，并将 start 移动到要翻转的最后一个节点

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-01.1y03qeggrlmo.png)

- 将翻转的为节点下一个指向空，并让 start 移动到要翻转的开始位置，准备翻转链表

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-02.5djbua117m80.png)

- 开始进行翻转,具体逻辑见代码吧

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-03.4p0snogncw40.png)

- 移动指针，准备下一轮翻转

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-04.6mirl8yjtdk0.png)


```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(k == 0 || head == nullptr) return head;
        ListNode *dumpy = new ListNode(-1);
        dumpy->next = head;
        ListNode *pre = dumpy;
        ListNode *start = head;
        ListNode *last,*first;
        while(start) {
            for(int i=0;i<k-1 && start != nullptr;++i) {
                start = start->next;
            }
            if(start == nullptr) break;
            last = start->next;
            start->next = nullptr;
            start = pre->next;
            first = start;
            while(start) {
                ListNode *cur = start;
                start = start->next;
                cur->next = last;
                last = cur;
            }
            //接上前面的
            pre->next = last;
            pre = first;
            start = first->next;
        }
        return dumpy->next;
    }
};
```