
- [面试写树的算法写不出我就是大猪蹄子](#面试写树的算法写不出我就是大猪蹄子)
  - [144. 二叉树的前序遍历](#144-二叉树的前序遍历)
  - [145. 二叉树的后序遍历](#145-二叉树的后序遍历)
  - [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
  - [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
    - [107. 二叉树的层序遍历 II](#107-二叉树的层序遍历-ii)
    - [按之字形顺序打印二叉树](#按之字形顺序打印二叉树)
    - [103. 二叉树的锯齿形层序遍历](#103-二叉树的锯齿形层序遍历)
    - [199. 二叉树的右视图](#199-二叉树的右视图)
    - [429. N 叉树的层序遍历](#429-n-叉树的层序遍历)
    - [二叉树翻转](#二叉树翻转)
  - [二叉树的镜像](#二叉树的镜像)
    - [101. 对称二叉树](#101-对称二叉树)
    - [100. 相同的树](#100-相同的树)
    - [572. 另一个树的子树](#572-另一个树的子树)
  - [104. 二叉树的最大深度](#104-二叉树的最大深度)
    - [559. N 叉树的最大深度](#559-n-叉树的最大深度)
    - [111. 二叉树的最小深度](#111-二叉树的最小深度)
  - [222. 完全二叉树的节点个数](#222-完全二叉树的节点个数)
  - [110. 平衡二叉树](#110-平衡二叉树)
  - [257. 二叉树的所有路径](#257-二叉树的所有路径)
  - [404. 左叶子之和](#404-左叶子之和)
  - [513. 找树左下角的值](#513-找树左下角的值)
  - [重建二叉树](#重建二叉树)
    - [知道后序中序重建二叉树](#知道后序中序重建二叉树)
    - [知道前序中序重建二叉树](#知道前序中序重建二叉树)
  - [617.合并二叉树](#617合并二叉树)
  - [从上往下打印二叉树](#从上往下打印二叉树)
    - [剑指 Offer 32 - II. 从上到下打印二叉树 II](#剑指-offer-32---ii-从上到下打印二叉树-ii)
  - [700. 二叉搜索树中的搜索](#700-二叉搜索树中的搜索)
  - [98. 验证二叉搜索树](#98-验证二叉搜索树)
  - [530. 二叉搜索树的最小绝对差](#530-二叉搜索树的最小绝对差)
  - [783. 二叉搜索树节点最小距离](#783-二叉搜索树节点最小距离)
  - [二叉搜索树的第k个结点](#二叉搜索树的第k个结点)
    - [二叉搜索树的后序遍历序列](#二叉搜索树的后序遍历序列)
  - [235. 二叉搜索树的最近公共祖先](#235-二叉搜索树的最近公共祖先)
  - [701.二叉搜索树中的插入操作](#701二叉搜索树中的插入操作)
  - [450.删除二叉搜索树中的节点](#450删除二叉搜索树中的节点)
  - [669. 修剪二叉搜索树](#669-修剪二叉搜索树)
  - [108.将有序数组转换为二叉搜索树](#108将有序数组转换为二叉搜索树)
  - [二叉树中和为某一值的路径](#二叉树中和为某一值的路径)
  - [112. 路径总和](#112-路径总和)
  - [236. 二叉树的最近公共祖先](#236-二叉树的最近公共祖先)


-------

## 面试写树的算法写不出我就是大猪蹄子

> 关于二叉树问题，用递归法能解决大部分问题

### 144. 二叉树的前序遍历

[leetcode题目](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

思路：

- 递归法

用另一个函数写递归

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root==nullptr) return {};
        vector<int> ans;
        traversal(root,ans);
        return ans;
    }
    void traversal(TreeNode* root,vector<int> &ans) {
        if(root == nullptr) return ;
        ans.push_back(root->val);
        if(root->left) traversal(root->left,ans);
        if(root->right) traversal(root->right,ans);
    }
};
```

- 迭代法

使用栈

注意栈是先进后出的，所以，右节点先进栈


```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr) return {};
        stack<TreeNode *> st;
        vector<int> ans;
        st.push(root);
        while(!st.empty()) {
            TreeNode *node = st.top();
            st.pop();
            ans.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return ans;
    }
};
```

### 145. 二叉树的后序遍历

[leetcode](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

- 递归法

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        if(root == nullptr) return ans;
        traversal(root,ans);
        return ans;
    }
    void traversal(TreeNode *node,vector<int> &ans) {
        if(node == nullptr) return;
        if(node->left) traversal(node->left,ans);
        if(node->right) traversal(node->right,ans);
        ans.push_back(node->val);
    }
};
```

- 迭代法


再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后再反转`res`数组，输出的结果顺序就是左右中了。

(前序)中左右--> 中右左-->(转)--> 左右中（后序）

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode *> st;
        st.push(root);
        while(!st.empty()) {
            //(前序)中左右--> 中右左-->(转)--> 左右中（后续）
            TreeNode* node = st.top();
            st.pop();
            res.push_back(node->val);
            //变成中右左，a按照栈的先进后出，所以先是左边入栈
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        } 
        //最后对res进行反转
        reverse(res.begin(),res.end());
        return res;
    }
};
```


### 94. 二叉树的中序遍历

[leetcode](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

- 递归法

```cpp
class Solution {
public:
    vector<int> ans;
    vector<int> inorderTraversal(TreeNode* root) {
        if(root == nullptr) return {};
        inorder(root);
        return ans;
    }
    void inorder(TreeNode *root) {
        if(root == nullptr) return;
        if(root->left) inorder(root->left);
        ans.push_back(root->val);
        if(root->right) inorder(root->right);
    }
};
```

- 迭代法

> 中序遍历不要让头结点一来就进栈        
> 注意 while 里面必须判断 cur != nullptr

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root == nullptr) return {};
        stack<TreeNode *> st;
        TreeNode *cur = root;
        vector<int> ans;
        //中序遍历不要一来就让头结点入栈
        while(cur != nullptr || !st.empty()) {
            if(cur != nullptr) {
                st.push(cur);
                cur = cur->left;
            }
            else {
                cur = st.top();
                ans.push_back(cur->val);
                st.pop();
                cur = cur->right;
            }
        }
        return ans;
    }
};
```

### 102. 二叉树的层序遍历

[leetcode](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)


```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        vector<int> resTemp;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size(); //记录每一层的个数
            //记得resTemp要清空,或者resTemp在这里再定义
            resTemp = {};
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for(int i=0;i<size;++i) {
                TreeNode * node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            //遍历完一层了后，加入 ans
            res.push_back(resTemp);
        }
        return res;
    }
};
```

#### 107. 二叉树的层序遍历 II

[leetcode](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
```
    3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层序遍历为：

```
[
  [15,7],
  [9,20],
  [3]
]
```

层次遍历翻转

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        vector<int> resTemp;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size(); //记录每一层的个数
            //记得resTemp要清空,或者resTemp在这里再定义
            resTemp = {};
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for(int i=0;i<size;++i) {
                TreeNode * node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            //遍历完一层了后，加入 ans
            res.push_back(resTemp);
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```


#### 按之字形顺序打印二叉树
#### 103. 二叉树的锯齿形层序遍历

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

[剑指offer题目](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&&tqId=11212&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 
例如:
```
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]
```

这题其实就是之字形打印树

用一个变量记录层次就可以了

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        int level = 0;  //记录层次
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            ++level;
            int size = que.size();
            // temp = {};
            temp.clear();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            if(level % 2 == 0) reverse(temp.begin(),temp.end());
            res.push_back(temp);
        }
        return res;
     }
};
```


#### 199. 二叉树的右视图

[leetcode](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```


层次遍历每一层取最后一个

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size(); 
            
            for(int i=0;i<size;++i) {
                TreeNode * node = que.front();
                que.pop();
                //只保留最后一个元素
                if(i == size - 1) 
                    res.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            
        }
        return res;
    }
};
```

#### 429. N 叉树的层序遍历

[leetcode](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> ans;
        if(root == nullptr) return ans;
        queue<Node *> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> temp;
            for(int i=0;i<size;++i) {
                Node *node = que.front();
                que.pop();
                temp.push_back(node->val);
                for(int j=0;j<node->children.size();++j) {
                    if(node->children[j]) que.push(node->children[j]);
                }
            }
            ans.push_back(temp);
        }
        return ans;
    }
};
```

#### 二叉树翻转

[leetcode](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转一棵二叉树。

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

思路：前序遍历

- 递归

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return nullptr;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
``

- 迭代法

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);          
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

- 使用层次遍历也可以做

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;
        queue<TreeNode *> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode *node = que.front();
                que.pop();
                swap(node->left,node->right);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

### 二叉树的镜像

[剑指offer题目](https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&&tqId=11171&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目-剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- 递归法

首先将根节点放入翻转函数中

交换左右子树，接下来使用递归翻转左右子树

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        if(pRoot == nullptr) return nullptr;
        reverse(pRoot);
        return pRoot;
    }
    void reverse(TreeNode* root) {
        if(root == nullptr) return ;
        //交换左右子树
        swap(root->left,root->right);
        //然后继续翻转下面的语句
        reverse(root->left);
        reverse(root->right);
    }
};
```

- 迭代法

使用队列，**层次遍历**，然后把左右子树翻转

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
       if(pRoot == nullptr) return nullptr;
        queue<TreeNode*> que;
        que.push(pRoot);
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left,node->right);
                //这里一定要放端 该节点是否存在再加入队列中
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return pRoot;
    }
};
```

#### 101. 对称二叉树

[leetcode](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。


```
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3
```

思路：

- 递归法

写个递归函数，写五个if else ,把各种 空 与 非空 判断一遍。

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        //题目： 1 <= size <= 1000
        if(root == nullptr) return true;
        return same(root->left,root->right);
    }
    bool same(TreeNode *left,TreeNode *right) {
        if(left == nullptr && right != nullptr) return false;
            else if(left != nullptr && right == nullptr) return false;
            else if(left == nullptr && right == nullptr) return true;
            else if(left->val != right->val) return false;
            else return same(left->left,right->right) && same(left->right,right->left);
    }
};
```


- 迭代法

使用层次遍历的思想，用 队列 遍历，但是不需要记录 size

先判断均不为空 就 continue，再判断 false 情况，最后入队，左子树的右子树，右子树的左子树

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode* >que;
        que.push(root->left);
        que.push(root->right);
        while(!que.empty()) {
            TreeNode *left = que.front();
            que.pop();
            TreeNode *right = que.front();
            que.pop();
            //两个节点为空，是对称的
            if( !left && !right) continue;
            //所有的 false 情况
            if( (!left && right) || (left && !right) || (left->val != right->val) ) {
                return false;
            }
            que.push(left->left);
            que.push(right->right);
            que.push(left->right);
            que.push(right->left);
        }
        return true;
    }
};
```

#### 100. 相同的树

[leetcode](https://leetcode-cn.com/problems/same-tree/)

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == nullptr && q == nullptr) return true;
        return isSame(p,q);
    }
    bool isSame(TreeNode *p,TreeNode *q) {
        if(p == nullptr && q != nullptr) return false;
        if(p != nullptr && q == nullptr) return false;
        if(q == nullptr && q == nullptr) return true;
        if(p->val != q->val) return false;
        return isSame(p->left,q->left) && isSame(p->right,q->right);
    }
};
```

#### 572. 另一个树的子树

[leetcode](https://leetcode-cn.com/problems/subtree-of-another-tree/)

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

```
给定的树 s:
     3
    / \
   4   5
  / \
 1   2

给定的树 t：
   4 
  / \
 1   2
```

返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值

思路：

使用 dfs ，判断左子树 或者 右子树 是否满足  

深搜里面 先判断各种 返回条件

最后返回 左子树 和 右子树 都为 true ，也就是都相等

```cpp
class Solution {
public:
    bool dfs(TreeNode *node, TreeNode *subRoot) {
        //判断递归退出条件
        if(node == nullptr && subRoot == nullptr) return true;
        //走到这肯定不可能两个都为空了,一个为空，一个不空
        if(node == nullptr || subRoot == nullptr) return false;
        //如果值不相等，那肯定返回false
        // if(node->val != subRoot->val) return false;
        if(node->val != subRoot->val) return false;
        return (dfs(node->left,subRoot->left) && dfs(node->right,subRoot->right));
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        // 如果这棵树为空，那么肯定没有子树
        if(root == nullptr) return false;
        //使用深度优先搜索遍历
        if(dfs(root,subRoot)) {
            return true;
        }
        return (isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot));
    }
};
```

### 104. 二叉树的最大深度

[leetcode](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

[剑指offer题目](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


使用递归，返回 左右最大值 + 1

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return max ( maxDepth(root->left),maxDepth(root->right) ) + 1;
    }
};
```

层次遍历可以实现

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

#### 559. N 叉树的最大深度

[leetcode](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```
输入：root = [1,null,3,2,4,null,5,6]
输出：3
```

- 递归，遍历每一层的节点

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if(root == nullptr)  return 0;
        int depth = 0; //这里必须给零，不能给最小值
        for(int i=0;i < root->children.size();++i) {
            depth =  max( maxDepth(root->children[i]),depth );
        }
        return depth + 1;
    }
};
```

- 迭代法，层次遍历

```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        int depth = 0;
        while (!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                Node* node = que.front();
                que.pop();
                for (int j = 0; j < node->children.size(); j++) {
                    if (node->children[j]) que.push(node->children[j]);
                }
            }
        }
        return depth;
    }
};
```

#### 111. 二叉树的最小深度

[leetcode](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

 ![](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

思路：

使用递归，后序遍历

注意：左子树为空，右子树不为空，这时不是最低点，所以判断并返回 右子树深度 + 1

最后去左右子树最低点的最小值

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        //使用后序遍历
        int left_depth = minDepth(root->left);
        int right_depth = minDepth(root->right);

        //左子树为空，右子树不为空，这时不是最低点
        if(root->left == nullptr && root->right != nullptr) {
            return right_depth+1;
        }
        if(root->right == nullptr && root->left != nullptr) {
            return left_depth+1;
        }
        return min(left_depth,right_depth) + 1;
    }
};
```

思路：

层次遍历+后序遍历，但是使用 队列。

先判断左右子树是否为空，不为空就 入队，都为空就 返回 depth + 1

最后返回 depth

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode *> que;
        que.push(root);
        int depth  = 0;
        while(!que.empty()) {
            TreeNode *node = que.front();
            que.pop();
            ++depth;
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);
            // 如果左右子树都为空就直接返回
            if(node->left != nullptr && node->right != nullptr) {
                return depth;
            }
        }
        return depth;
    }
};
```

### 222. 完全二叉树的节点个数

[leetcode](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

![](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

使用前序遍历，递归

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int num = 0;
        count(root,num);
        return num;
    }
    void count(TreeNode *root,int &num) {
        if(root == nullptr) return;
        ++num;
        if(root->left) count(root->left,num);
        if(root->right) count(root->right,num);
    }
};
```

迭代法：

层次遍历，使用 队列，不用求每一层的 size

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> que;
        que.push(root);
        int num = 0;
        while(!que.empty()) {
            TreeNode *node = que.front();
            que.pop();
            ++num;
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);
        }
        return num;
    }
};
```


### 110. 平衡二叉树

[leetcode](https://leetcode-cn.com/problems/balanced-binary-tree/)

![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

使用递归

获取左子树高度，左子树不平衡，返回 -1，

获取右子树高度，右子树不平衡，返回 -1

不平衡，递归返回 -1，否则返回高度，记得高度是左右子树高度最大值 + 1

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
       if(root == nullptr) return true;
       return getDepth(root) == -1 ? false : true;
    }
    int getDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        int lefth = getDepth(root->left);
        //如果返回已经不平衡了，就结束
        if(lefth == -1) return -1;
        int righth = getDepth(root->right);
        if(righth == -1) return -1;
        
        return abs(lefth - righth) > 1 ? -1 : 1 + max(lefth,righth);
    }
};
```

### 257. 二叉树的所有路径

[leetcode](https://leetcode-cn.com/problems/binary-tree-paths/)

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

使用回溯算法

回溯结束条件是左右子树为空，也就是叶子节点

先保存当前节点的值，然用一个字符串 spath 节点值拼接起来，放到 ans 中，

回溯，并取出 path 节点

```cpp
class Solution {
public:
    vector<string> ans;
    vector<int> path;
    vector<string> binaryTreePaths(TreeNode* root) {
        if(root == nullptr) return ans;
        backtracking(root);
        return ans;
    }
    void backtracking(TreeNode *root) {
        path.push_back(root->val);
        string spath;
        if (root->left == nullptr && root->right == nullptr) {
            //最后一个不需要加->
            int i = 0;
            for(;i<path.size()-1;++i){
                spath += to_string(path[i]);
                spath += "->";
            }
            spath += to_string(path[i]);
            ans.push_back(spath);
            return;
        }

        if(root->left) {
            binaryTreePaths(root->left);
            path.pop_back();  //回溯
        }
        if(root->right) {
            binaryTreePaths(root->right);
            path.pop_back();  //回溯
        }
    }
};
```

### 404. 左叶子之和

[leetcode](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

示例：

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

使用递归，后序遍历思想

判断左子树是不是叶子节点才算

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;
        int leftSum = sumOfLeftLeaves(root->left);
        int rightSum  = sumOfLeftLeaves(root->right);
        int midSum = 0;
        //判断左子树是不是叶子节点才算
        if(root->left != nullptr && root->left->left == nullptr && root->left->right == nullptr){
            midSum += root->left->val;
        }
        int sum = midSum + leftSum + rightSum;
        return sum;
    }
};
```

迭代法，使用前序遍历每个节点

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;
        int sum = 0;
        stack<TreeNode *> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode *node = st.top();
            st.pop();
            if(node->left != nullptr && node->left->left == nullptr && node->left->right == nullptr) {
                sum += node->left->val;
            }
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        return sum;
    }
};
```

### 513. 找树左下角的值

[leetcode](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。

假设二叉树中至少有一个节点。

![](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

```
输入: root = [2,1,3]
输出: 1
```

层次遍历，记录最后一行第一个元素，直接使用覆盖的方法就可以

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素，每一行都覆盖掉
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```


### 重建二叉树

[可以参考这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484950&idx=1&sn=3900f9433d36dd5406fc1ccb1df07703&scene=21#wechat_redirect)

#### 知道后序中序重建二叉树

[leetcode题目](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

首先判断遍历是否为空，如果为空直接返回 NULL

接着找到后序遍历的最后一个节点，创建并放在 root 节点中，判断如果只有一个节点就直接返回 root

在中序遍历中找到后序遍历最后一个元素的位置 mid

然后开始截取，先截取中序遍历，在 mid 位置处；

后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。所以要删掉先。

再截取后续遍历，在 `leftInorder.size()` 位置处

最后递归建左子树和右子树。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //判断节点是否为空
        if(inorder.size() == 0) {
            return nullptr;
        }
        //取出后序遍历最后一个节点，就是头结点
        int val = postorder[postorder.size() - 1];
        // 建立根节点
        TreeNode* root = new TreeNode(val);
        //如果只有一节点的话，就直接返回根节点
        if(postorder.size() == 1) return root;

        int mid ;
        //找出后序遍历最后的节点在中序遍历的位置
        for(int i=0;i<inorder.size();++i) {
            if(inorder[i] == root->val){
                mid = i;
                break;
            }
        }

        //先切割中序，再切割后序

        // 中序遍历，不要当前节点了
        // [9,3,15,20,7]   截取 9
        vector<int> leftInotder(inorder.begin(),inorder.begin() + mid); //mid = 1
        //注意这里不要已经遍历的节点了
        vector<int> rightInorder(inorder.begin() + mid + 1, inorder.end());

        //舍去没元素
        postorder.resize(postorder.size() - 1); //设置大小（size）,如果超过就删除后面的

        //后序遍历

        //[9,15,7,20]    9   （3已经被删除了）
        vector<int> leftPostorder (postorder.begin(),postorder.begin() + leftInotder.size());
        // 15,7,20  （3已经被删除了）
        vector<int> rightPostorder (postorder.begin() + leftInotder.size(),postorder.end());

        //递归建树
        root->left = buildTree(leftInotder,leftPostorder);
        root->right = buildTree(rightInorder,rightPostorder);

        return root;
    }
};
```

测试`vector`复制

```cpp
int main() {
    vector<int> temp = {1,2,3};
    vector<int> vec1 = {1,2,3,4,5};
    vector<int> vec2 (vec1.begin(),vec1.begin() + temp.size());
    vector<int> vec3 (vec1.begin() + temp.size(),vec1.end());

    vector<int>::iterator it = vec2.begin();
    for(;it!=vec2.end();++it) {
        cout << *it << " ";  //1,2,3,   也就是[1,2,3,4)    
    }
    cout << endl;
    vector<int>::iterator it3 = vec3.begin();
    for(;it3!=vec3.end();++it3) {
        cout << *it3 << " ";  //4,5    
    }
    cout << endl;
}
```

#### 知道前序中序重建二叉树


[剑指offer题目](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

思想和上一题一样

就是先找前序遍历在中序遍历中的位置，然后再切割。

最后递建 左右子树

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        //判断遍历是否为空
       if(pre.size() == 0) return NULL;
        
        //找到前序遍历第一个元素
        int val = pre[0];
        TreeNode* root = new TreeNode(val);
        // 如果只有一个元素，那么就是只有一个节点，直接返回root
        if(pre.size() == 1) return root;
        
        //找前序遍历第一个元素在中序遍历中的位置
        int mid = 0;
        for(;mid < vin.size();++mid) {
            if(vin[mid] == val) break;
        }
        
        //开始切割
        
        //中序遍历,不要正在遍历的节点
        vector<int> leftVin(vin.begin(),vin.begin() + mid);
        vector<int> rightVin(vin.begin() + mid + 1,vin.end());
        
        //删除前序遍历第一个节点
        pre.erase(pre.begin());
        
        //前序遍历
        vector<int> leftPre (pre.begin(),pre.begin() + leftVin.size());
        vector<int> rightPre (pre.begin() + leftVin.size(),pre.end());
        
        root->left = reConstructBinaryTree(leftPre, leftVin);
        root->right = reConstructBinaryTree(rightPre, rightVin);
        
        return root;
        
    }
};
```

### 617.合并二叉树

[leetcode](https://leetcode-cn.com/problems/merge-two-binary-trees/)

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

前序遍历思想

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr && root2 == nullptr) return nullptr;
        if(root1 == nullptr && root2 != nullptr) return root2;
        if(root1 != nullptr && root2 == nullptr) return root1;

        root1->val += root2->val;
        root1 ->left = mergeTrees(root1->left,root2->left);
        root1->right = mergeTrees(root1->right,root2->right);
        return root1;
    }
};
```


### 从上往下打印二叉树

[剑指offer题目](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

示例1

```
输入：
{5,4,#,3,#,2,#,1}
复制
返回值：
[5,4,3,2,1]
```

```cpp
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return  res;
        queue<TreeNode* > que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                res.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

#### 剑指 Offer 32 - II. 从上到下打印二叉树 II

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

- 用队列，然后使用层次遍历，先用一个数组存每一层的结果，在放到最终的返回数组中。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            temp = {};
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(temp);
        }
        return res;
     }
};
```

### 700. 二叉搜索树中的搜索

[leetcode](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)


给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

```
给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2
你应该返回如下子树:

      2     
     / \   
    1   3
```

前序遍历思想，大于 val 遍历左子树，小于 val 遍历右子树

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr) return nullptr;
        if(root->val == val) return root;
        //无论是哪边，找到就直接返回  
        //利用二叉搜索树的特性
        if(root->val > val) return searchBST(root->left,val);
        if(root->val < val) return searchBST(root->right,val);
        return nullptr;
    }
};
```

迭代法，这届使用二分查找思想，移动 root 指针

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr) return nullptr;
        while(root) {
            if(root->val > val) root = root->left;
            else if(root->val < val) root = root->right;
            //找到了
            else return root;
        }
        return nullptr;
    }
};
```

### 98. 验证二叉搜索树

[leetcode](https://leetcode-cn.com/problems/validate-binary-search-tree/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。

节点的右子树只包含大于当前节点的数。

所有左子树和右子树自身必须也是二叉搜索树。

```
输入:
    2
   / \
  1   3
输出: true
```

二叉搜索树的中序遍历是有序的，可以边搜索边比较

记得相等就不是二叉搜索树了

```cpp
class Solution {
public:
    long long maxVal = LONG_MIN;  //每次递归都用到，需要设置为全局变量
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        //中序遍历
        bool left = isValidBST(root->left);
        if(maxVal < root->val) maxVal = root->val;
        else return false;

        bool right = isValidBST(root->right);
        return left && right;
    }
};
```

迭代法

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        //if(root == nullptr) return true;
        stack<TreeNode *> st;
        TreeNode *cur = root;
        TreeNode *pre = nullptr;
        //中序遍历不要一来就让头结点进栈
        while( cur != nullptr || !st.empty()) {
            if(cur != nullptr) {
                st.push(cur);
                cur = cur->left;
            }
            else {
                cur = st.top();
                st.pop();
                if(pre != nullptr && cur->val <= pre->val)
                    return false;
                pre = cur;


                cur = cur->right;
            }
        }
        return true;
    }
};
```

### 530. 二叉搜索树的最小绝对差
### 783. 二叉搜索树节点最小距离

[leetcode](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

[leeetcode-783](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

 

示例：
```
输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
```

[思路参考](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485040&idx=1&sn=5076aed483d61d710eaf3db626df9c4e&scene=21#wechat_redirect)

```cpp
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组 
    traversal(root->right);
}
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
```



### 二叉搜索树的第k个结点

[剑指offer题目](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一棵二叉搜索树，请找出其中第k大的节点。

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

使用中序遍历，然后用一个数组保存

记住最后要判断 k 是否超过数组的长度

- 递归法

```cpp
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        if(pRoot==NULL||k<=0) return NULL;
        vector<TreeNode*> vec;
        midTraver(pRoot,vec);
        if(k > vec.size()) {
            return NULL;  //一定要判断是否越界
        }
        return vec[k-1];
    }
   void midTraver(TreeNode* pRoot,vector<TreeNode*> &vec) {
       if(pRoot == nullptr) return;
       if(pRoot->left) midTraver(pRoot->left, vec);
       vec.push_back(pRoot);
       if(pRoot->right) midTraver(pRoot->right, vec);
   }
    
};
```

#### 二叉搜索树的后序遍历序列

[剑指offer题目](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）

示例1
```
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true
```

使用一个函数传入后序遍历数组和前后位置

找到后序遍历的最后一个节点，再找左子树的最后位置，接着找右子树的最后位置。

最后右子树的最后位置正好是最后一个节点时说明是二叉搜索树，当然也要保证左右子树也是。


```cpp
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return myPostorder(postorder,0,postorder.size() - 1);
    }
    bool myPostorder(vector<int> postorder,int start,int len) {
        // 如果只有一个节点，也就是start == len 返回tre
        if(start >= len) {
            return true;
        }

        //找出左子树后续遍历的最后一个节点的位置。也就是比 len 位置小的
        int index = start;
        int rootVal = postorder[len];
        while(postorder[index] < rootVal)
        {
            ++index;
        }
        int leftLen = index - 1;

        //找右子树后续遍历的最后一个节点，如果正好遍历到 len 说明是 true，
        while(postorder[index] > rootVal ) {
            ++index;
        }
        //这棵子树是二叉搜索树，它的左右子树也必须是
        return index == len 
            && myPostorder(postorder,start,leftLen)
            && myPostorder(postorder,leftLen + 1,len-1);  //这里记得 -1，因为头接地那不要了
    }
};
```

### 235. 二叉搜索树的最近公共祖先

### 701.二叉搜索树中的插入操作

### 450.删除二叉搜索树中的节点

### 669. 修剪二叉搜索树

### 108.将有序数组转换为二叉搜索树

### 二叉树中和为某一值的路径

[剑指offer题目](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetocde题目](https://leetcode-cn.com/problems/path-sum-ii/)


输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

示例：

```
输入：
{10,5,12,4,7},22
返回值：
[[10,5,7],[10,12]]
```

使用回溯，采用目标和递减的方式，到 0 的时候结束

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        if(root == nullptr) return result;
        //先把根节点放进去
        path.push_back(root->val);
        backtracking(root,expectNumber - root->val);
        return result;
    }
    void backtracking(TreeNode* root,int target)
    {
        //结束条件
        //到叶子节点满足
        if(root->left == nullptr && root->right == nullptr && target == 0){
            result.push_back(path);
            return;
        }
        //遇到叶子节点而没有找到合适的边，直接返回
        if(root->left == nullptr && root->right == nullptr) return;
        
        //左子树
        if(root->left) {
            target -= root->left->val;
            path.push_back(root->left->val);
            backtracking(root->left, target);
            target += root->left->val;
            path.pop_back();            
        }
        //右子树
        if(root->right) {
            target -= root->right->val;
            path.push_back(root->right->val);
            backtracking(root->right, target);
            target += root->right->val;
            path.pop_back();            
        }
    }
};
```

### 112. 路径总和

[leetcode题目](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```

使用回溯法，，采用目标和递减的方式，到 0 的时候结束，左子树和右子树有一边满足就返回 true

需要注意，传入根节点的时候这时候和为 targetSum - root->val

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        return backtracking(root,targetSum - root->val); //已经遍历第一个节点，所以 targetSum - root->val
    }
    bool backtracking(TreeNode* root,int targetSum) {
        //满足条件
        if(root->left == nullptr && root->right == nullptr && targetSum == 0) return true;
        //已经到叶子节点了还不满足
        if(root->left == nullptr && root->right == nullptr && targetSum != 0) return false;

        //然后分别判断左右子树
        if(root->left) {
            targetSum -= root->left->val;
            if(backtracking(root->left,targetSum)) return true;
            targetSum += root->left->val;
        }
        if(root->right) {
            targetSum -= root->right->val;
            if(backtracking(root->right,targetSum)) return true;
            targetSum += root->right->val;
        }
        return false;
    }
};
```

### 236. 二叉树的最近公共祖先

[leetcode题目](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

[参考](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485072&idx=1&sn=1e6c6d28a70ad0f6986ca5f850b74abe&scene=21#wechat_redirect)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

思路：

- （1） 如果当前结点 root 等于 NULL，则直接返回 NULL
- （2） 如果 root 等于 p 或者 q ，那这棵树一定返回 p 或者 q
- （3） 然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 left 和 right 表示
- （4） 此时若 left 为空，那最终结果只要看 right；若 right 为空，那最终结果只要看 left
- （5） 如果 left 和 right  都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先
- （6） 如果 left 和 right 都为空，则返回空（其实已经包含在前面的情况中了）

时间复杂度是 $O(n)$：每个结点最多遍历一次或用主定理，空间复杂度是 $O(n)$：需要系统栈空间

```cpp

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return nullptr;
        if(root == p || root == q) {
            return root;
        }
        // 使用函数后可认为左右子树已经算出结果，用 leftleft 和 rightright 表示
        TreeNode *left = lowestCommonAncestor(root->left,p,q);
        TreeNode *right = lowestCommonAncestor(root->right,p,q);

        if(left == nullptr) {
            return right;
        }
        if(right == nullptr) {
            return left;
        }
        if(left && right) {
            return root;
        }
        return nullptr;
    }
};
```
