
-------

[题目参考](https://blog.csdn.net/dianshu1593/article/details/101523861?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant)

考虑将正整数 nn 拆分成几个不同的平方数之和，比如 $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$ , 而 8 不存在这样的拆分。


## 200. 岛屿数量

[leetcode题目](https://leetcode-cn.com/problems/number-of-islands/)

[牛客题目](https://www.nowcoder.com/practice/0c9664d1554e466aa107d899418e814e?tpId=188&&tqId=38590&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```


- 深度优先搜索

先遍历一遍找到单独的 1 ，就开始深搜这个节点，并把遍历过的置为 0，

再上下左右依次遍历判断

```cpp
class Solution {
public:
    void dfs(vector<vector<char>> &grid,int i,int j) {
        if(grid[i][j] == '0') {
            return;
        }
        int row = grid.size();
        int col = grid.front().size();
        //需要将当前遍历过得节点置为 0 
        grid[i][j] = '0';
        //判断上下左右
        if(i-1 >= 0 && grid[i-1][j] == '1') 
            dfs( grid,i-1,j );
        if(i+1 < row && grid[i+1][j] == '1') 
            dfs( grid,i+1,j );
        if(j-1 >= 0 && grid[i][j-1] == '1')
            dfs( grid,i,j-1 );
        if(j+1 < col && grid[i][j+1] == '1') 
           dfs( grid,i,j+1 );
    }
    int numIslands(vector<vector<char>>& grid) {
        if(grid.size() == 0) return 0;
        int row = grid.size();
        int col = grid.front().size();
        int ans = 0;
        //遍历所有空格，如果遇到有独立的1就开始深搜
        for(int i=0;i<row;++i) {
            for(int j=0;j<col;++j) {
                if(grid[i][j] == '1') {
                    ++ans;
                    dfs(grid,i,j);
                }
            }
        }
        return ans;
    }
};
```

