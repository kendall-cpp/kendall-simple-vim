
- [其他](#其他)
  - [设计LRU缓存结构](#设计lru缓存结构)

-------

## 其他

### 设计LRU缓存结构

[题目来源]()

设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能
set(key, value)：将记录(key, value)插入该结构
get(key)：返回key对应的value值

[要求]

set和get方法的时间复杂度为`O(1)`

某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。

当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。

若`opt=1`，接下来两个整数`x`, `y`，表示`set(x, y)`

若`opt=2`，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回`-1`
对于每个操作`2`，输出一个答案

```
输入：
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3
复制
返回值：
[1,-1]
```

```cpp
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        cap = k;
        vector<int> ans;
        for(auto &num : operators) {
            if(num[0] == 1) {
                set(num[1],num[2]);
            }
            else {
                ans.push_back(get(num[1]));
            }
        }
        return ans;
    }
    //插入
    //首先查找，如果有就删除，然后不管有没有都在队头插入
    void set(int key,int value) {
        auto it = mp.find(key);
        if(it != mp.end()) { //如果有，就删除
            cache.erase(it->second);
            mp.erase(key);
        }
        // 然后再插入队头
         pair<int, int> n(key,value);
        cache.push_front(n);
        mp.emplace(key,cache.begin());
        
        //如果缓冲区满了，就要删除对尾节点
        if(cap < cache.size()) {
            //哈希表删除
            mp.erase(cache.back().first);
            cache.pop_back();
        }
    }
    //获取
    //先查找哈希表，如果没有就结束，有就复制到头部，再删除原有位置元素
    int get(int key) {
        auto it = mp.find(key);
        if(it == mp.end() ) { //如果没有，就结束
            return -1;
        }
        //如果有
        //删除原有的，插入前面
        auto target_it = it->second;
        pair<int, int> n(key,target_it->second);
        cache.push_front(n);
        // 删除
        cache.erase(target_it);
        mp.erase(key);
        mp.emplace(key,cache.begin());
        
        return n.second;
    }
private:
    int cap;
    list<pair<int,int>> cache;
    unordered_map<int,list<pair<int, int>>::iterator> mp;
};
```