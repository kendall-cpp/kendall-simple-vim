
- [1. 两数之和](#1-两数之和)
- [15. 三数之和](#15-三数之和)
  - [18. 四数之和](#18-四数之和)
- [寻找第K大](#寻找第k大)
- [215. 数组中的第K个最大元素](#215-数组中的第k个最大元素)
- [88. 合并两个有序数组](#88-合并两个有序数组)
- [704. 二分查找](#704-二分查找)

------

## 1. 两数之和

[leetcode题目](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

> **答案不能出现重复**

- 直接暴力用两个循环遍历，看 target - num[i] 有没有在nums 中。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        for(int i=0;i<nums.size();++i) {
            for(int j=i + 1;j<nums.size();++j) {
                if(target - nums[i] == nums[j]) {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return res;
    }
};
```

- 使用哈希表来保存，每次先检查 `target-nums[i]` 有没有在哈希表里面，如果有直接返回。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();++i) {
            auto it = mp.find(target - nums[i]);
            if(it != mp.end() ) {
                return {it->second,i};
            }
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

## 15. 三数之和

[leetcode题目](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 `a + b + c = 0` ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

思路：

排序 + 双指针

先排序，从左到右选一个把柄，从这个把柄开始开始往后找其余两个数

如果这个把柄已经大于零了，后面不用找了，因为是排好序的

记得去重，用后一个和前一个比较的技巧

接着用两个指针，一个为 `startIndex + 1` 一个从后面开始，

根据三个数的和比 0 大还是小移动左右指针。

最后一样去重，先移动左右指针，用后一个和前一个比较的技巧


```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        // vector<int> temp;
        sort(nums.begin(),nums.end());
       for(int startIndex = 0;startIndex<nums.size();++startIndex) {
           //以startIndex 开始往后，找了个和它加起来等于 0
           //如果startIndex 都大于0了，就不用找了，因为是排好序的
           if(nums[startIndex] > 0) {
               break;
           }
           //去重
           //因为题目要求三元组不能重复，所以需要去重，去重用 后面的和前面的比这个技巧
           if(startIndex > 0 && nums[startIndex] == nums[startIndex - 1]) {
               continue;
           }
           //现在开始找后两个数
           int left = startIndex + 1;
           int right = nums.size() - 1;
           while (left < right) {
               int sum = nums[startIndex] + nums[left] + nums[right];
               //左右收缩left 和 right 指针
               if(sum < 0) {
                   ++left;
               }
               else if(sum > 0) {
                   --right;
               }
               //这时候已经相等了，就是要找的值
               else{
                   vector<int> temp;
                   temp.push_back(nums[startIndex]);
                   temp.push_back(nums[left]);
                   temp.push_back(nums[right]);
                   res.push_back(temp);
                   
                   //存完一个之后可能还有下一个，所以继续缩小窗口比较,
                   //因为是后面的一个跟前面的比较，所以要先执行这一步
                   ++left;
                   --right;
                    // 为了防止有重复的出现，所以要不停的缩小
                    while(left < right && nums[left] == nums[left - 1]) ++left;
                    while(left < right && nums[right] == nums[right+1]) --right;
               }
           }
       }
        return res;
    }
};
```

时间复杂度是 $O(n^2)$

空间复杂度 $O(1)$：指针使用常数大小的额外空间。


### 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 `a + b + c + d` 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。

和上一题思路一样，只是多了一层循环


```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        for(int start1 = 0;start1<nums.size();++start1) {
            // 这种剪枝是错误的，这道题目target 是任意值 ,但 target 为负数的时候就不对了
            // if (nums[start1] > target) {
            //     return res;
            // }
            //去重，使用后一个和前一个比较的技巧
            if(start1 > 0 && nums[start1] == nums[start1 - 1]) {
                continue;
            }
            for(int start2 = start1 + 1;start2  < nums.size();++start2) {
                //去重 注意这里不是 0， (start2 > start1 + 1
                if(start2 > start1 + 1 && nums[start2] == nums[start2 - 1]){
                    continue;
                }
                int left = start2 + 1;
                int right = nums.size() - 1;
                while(left < right) {
                    int sum = nums[start1] + nums[start2] + nums[left] + nums[right];
                    if(sum < target) {
                        ++left;
                    }
                    else if(sum > target) {
                        --right;
                    }
                    else{
                        //这就是目标值
                        vector<int> temp;
                        temp = {nums[start1],nums[start2],nums[left],nums[right]};
                        res.push_back(temp);

                        //去重
                        ++left;
                        --right;
                        while(left < right && nums[left] == nums[left - 1]) ++left;
                        while(left < right && nums[right] == nums[right + 1]) --right;
                    }
                }
            }
        }
        return res;
    }
};
```

## 寻找第K大

## 215. 数组中的第K个最大元素

[题目来源](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=190&tqId=35209&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

[leetcode题目](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

使用快速排序倒排，但是注意 left == right 也要判断，注意！！！

第 K 大一定在第 K-1 位置

```cpp
class Solution {
public:
    int res;
    int m_k;
    int findKthLargest(vector<int>& nums, int k) {
        m_k = k;
        int left = 0,right = nums.size()-1;
        quickSort(nums,left,right);
        return res;
    }

    void quickSort(vector<int>& nums,int left,int right) {
        if(left <= right) { //这里必须要加等于号，和快排不同的地方，必须注意
            //排序基准元素,返回排序号的位置
            int index = partition(nums,left,right);
            if(index == m_k-1) {
                res = nums[index];
                return;
            }
            else if(index < m_k-1) {
                quickSort(nums,index + 1,right);
            }
            else {
                quickSort(nums,left,index - 1);
            }
            
        }
    }
    int partition(vector<int> &nums,int left,int right) {
        //选择基准
        int pivot = nums[left];
        while(left < right) {
            // 从右往左
            while(left< right && nums[right] <= pivot) {
                --right;
            }
            //填坑
            nums[left] = nums[right];
            //从右往左
            while(left < right && nums[left] >= pivot) {
                ++left;
            }
            //填坑
            nums[right] = nums[left];
        }
        //把基准放到合适的位置
        //这时候left = right
        nums[left] = pivot;
        return left;
    }
};
```

- 还可以使用 大顶堆

```cpp
priority_queue< type, container, function >
```

- type：数据类型；
- container：实现优先队列的底层容器；
- function：元素之间的比较方式；

大顶堆

```cpp
//构造一个空的优先队列（此优先队列默认为大顶堆）
priority_queue<int> big_heap;   

//另一种构建大顶堆的方法
priority_queue<int,vector<int>,less<int> > big_heap2;  
```

小顶堆

```cpp
//构造一个空的优先队列,此优先队列是一个小顶堆
priority_queue<int,vector<int>,greater<int> > small_heap;   
```

使用大顶堆，然后移除最大的几个

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int len = nums.size();
        // priority_queue<int,vector<int>,greater<int> > small_heap;
        priority_queue<int> big_heap;
        for(int i=0;i<len;++i) {
            big_heap.push(nums[i]);
        }
        //第k大，那么
        for(int i=0;i<k-1;++i) {
            big_heap.pop();
        }
        return big_heap.top();
    }
};
```

## 88. 合并两个有序数组

[leetcode题目](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。

示例：

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

思路：从后往前存

别忘了补全num2

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {

        int pos = m + n - 1;
        int i = m-1;
        int j = n-1;
        while( i >= 0 && j >= 0) {
            if(nums1[i] > nums2[j]) {
                nums1[pos] = nums1[i];
                --i;
            }
            else {
                nums1[pos] = nums2[j];
                --j;
            }
            --pos;
        }
        //别忘了补全num2
        while(j >= 0) {
            nums1[pos--] = nums2[j--];
        }
    }
};
```

## 704. 二分查找

[leetcode题目](https://leetcode-cn.com/problems/binary-search/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

注意要等号还要比  `left <= right`

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                return mid;
            }
            else if(nums[mid] < target) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return -1;
    }
};
```

