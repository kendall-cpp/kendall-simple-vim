

------

> 通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用**单调栈**了。      
> 时间复杂度为O(n)。        
> 注意单调栈的递增顺序是从 栈头 到栈底 递增 ： top ——> 栈底



## 739. 每日温度

[leetcode](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

思路：

> [参考](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247489773&idx=1&sn=2022454b723475adc0507a2d43b68bdc&scene=21#wechat_redirect)


本题其实就是找找到一个元素右边第一个比自己大的元素。此时就应该想到用单调栈了。

- 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
  - 入栈
- 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
  - 入栈
- 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
  - 一直出栈到 `T[i] <= st.top()`
  - 这时候再入栈

> result 记录右边第一个比 T[i] 大的元素到 T[i] 的距离   
> 注意栈里面保存的是 距离

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        //全部初始化为 0，因为默认距离是 0(索引)
        vector<int> ans(temperatures.size(),0);
        // 第一个元素肯定进栈，所以让 0 先进栈，注意：栈里面存的是距离
        st.push(0);
        for(int i=1;i<temperatures.size();++i) {
            //第一种情况，当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
            if(temperatures[i] < temperatures[st.top()] ) {
                st.push(i);
            }
            else if(temperatures[i] == temperatures[st.top()]) {
                st.push(i);
            }
            else {
                //一直弹出到比当前元素大位置
                while(!st.empty() && temperatures[i] > temperatures[st.top()]) {
                    ans[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return ans;
    }
};
```

时间复杂度：O(n)

空间复杂度：O(n)

## 496. 下一个更大元素 I

[leetcode](https://leetcode-cn.com/problems/next-greater-element-i/)

注意题目中说是两个没有重复元素 的数组 nums1 和 nums2。

没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标，还可以判断`nums2[i]`是否在`nums1`中出现过。

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下表元素，value：下表
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] < nums2[st.top()]) {           // 情况一
                st.push(i);
            } else if (nums2[i] == nums2[st.top()]) {   // 情况二
                st.push(i);
            } else {                                    // 情况三
                while (!st.empty() && nums2[i] > nums2[st.top()]) {
                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下表
                        result[index] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

### 503. 下一个更大元素 II

[leetcode](https://leetcode-cn.com/problems/next-greater-element-ii/)

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

```
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

[思路参考](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247490736&idx=2&sn=d814d54a2675c5257e7cdb7567f15d02&scene=21#wechat_redirect)

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        if(nums.size() == 0) return ans;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) {
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                ans[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return ans;
    }
};
```

## 42. 接雨水

[题目来源](https://leetcode-cn.com/problems/trapping-rain-water/)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

[题解参考](https://mp.weixin.qq.com/s/bN7BIbcPlg8f6xgrKHp0vA)

- 暴力解法

找出每个格子左边和右边的最大高度的最小高度

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        for(int i=0;i<n;++i) {
            int l_max = 0,r_max = 0;
            //找右边的高度
            for(int j=i;j<n;++j) {
                r_max = max(r_max,height[j]);
            }
            //找左边的高度
            for(int j=i;j>=0;--j) {
                l_max = max(l_max,height[j]);
            }
            
            ans += min(l_max,r_max) - height[i];
        }
        return ans;
    }
};
```

时间复杂度 $O(N^2)$

空间复杂度 $O(1)$

- 带备忘录

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size()==0){
            return 0;
        }
        int len = height.size();
        int sum = 0;
        vector<int> lmax(len),rmax(len);
        //初始化
        lmax[0] = height[0];
        rmax[len-1] = height[len-1];  //注意这里是初始化后面的
        //左边
        for(int i=1;i<height.size();i++){
            lmax[i]=max(lmax[i-1],height[i]);
        }
        //右边
        for(int j=len-2;j>=0;j--){
            rmax[j]=max(rmax[j+1],height[j]);
        }
        for(int i=0;i<height.size();i++){
            sum+=min(lmax[i],rmax[i])-height[i];
        }
        return sum;
    }
};
```
时间复杂度 $O(N)$

空间复杂度 $O(N)$

- 双指针(记住这个解法)

边走边计算，一个从左边开始走，一个从右边开始走，找到左边的最大值，再找到右边的最大值。最后用小的来求能接多少水。并移动指针。

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() == 0) return 0;
        int left = 0,right =height.size() - 1;
        int lmax = height[0];
        int rmax = height[height.size() - 1];

        int sum = 0;
        while(left <= right) {
            //左边
            lmax = max(lmax,height[left]);
            //右边
            rmax = max(rmax,height[right]);

            //开始计算接水
            //sum+=min(lmax[i],rmax[i])-height[i];
            if(lmax < rmax) {
                sum += lmax - height[left];
                ++left;
            }
            else {
                sum += rmax - height[right];
                --right;
            }
        }
        return sum;
    }
};
```
时间复杂度 $O(N)$

空间复杂度 $O(1)$








