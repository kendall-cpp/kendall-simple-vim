## 一些知识点：
- 用数组来存储完全二叉树，如果父节点的数组下表是`i`，那么它的左孩子就是`i * 2 + 1`，右孩子就是 `i * 2 + 2`。

- 二叉树的定义（面试的时候可能会手写）
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL) {}
};
```
- 每次写递归，都按照这三要素来写，可以保证大家写出正 确的递归算法!
    * **确定递归函数的参数和返回值**:确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次 递归的返回值是什么进而确定递归函数的返回类型。
    * **确定终止条件**: 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不 对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存 栈必然就会溢出。
    * **确定单层递归的逻辑**: 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 递归法遍历二叉树

- [前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)
```cpp
class Solution {
public:
    void traversal(TreeNode* root,vector<int> &res) {
        if(root == nullptr) return; //确定终止条件
        //确定单层递归的逻辑，中左右
        res.push_back(root->val);
        traversal(root->left,res);
        traversal(root->right,res);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        //确定递归函数的参数和返回值
        traversal(root,res);
        return res;
    }
};
```
- [中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/)

```cpp
class Solution {
public:
    void traversal(TreeNode* root,vector<int> &res) {
        if(root == nullptr) return;
        traversal(root->left,res);
        res.push_back(root->val);
        traversal(root->right,res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        traversal(root,res);
        return res;

    }
};
```
- [后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)
```cpp
class Solution {
public:
    void traversal(TreeNode* root,vector<int> &res) {
        if(root == nullptr) return;
        traversal(root->left,res);
        traversal(root->right,res);
        res.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        traversal(root,res);
        return res;
    }
};
```
### 迭代法遍历二叉树

- [前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢? 因为这样出栈的时候才是中左右的顺序。

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr) return {};
        stack<TreeNode *> st;
        vector<int> res;
        // 前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。
        st.push(root); // 根节点入栈
        while(!st.empty()) {
            TreeNode* top = st.top();
            st.pop();
            res.push_back(top->val);
            if(top->right) st.push(top->right);
            if(top->left) st.push(top->left);
        }
        return res;
    }
};
```

- [中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/)

分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先 访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问 的元素和要处理的元素顺序是一致的，都是中间节点。

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点(也就是在把节点的数值放进`res`数组中)，这就造成了处理 顺序和访问顺序是不一致的。

那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode *> st;
        TreeNode* cur = root;
        while(cur != nullptr || !st.empty()) {
            //遍历到最左边
            if(cur != nullptr) {
                st.push(cur);
                cur = cur->left;
            }
            else {
                cur = st.top();
                res.push_back(cur->val);
                st.pop();
                cur = cur->right;
            }
        }
        return res;
    }
};
```


- [后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)

再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后再反转`res`数组，输出的结果顺序就是左右中了。

(前序)中左右--> 中右左-->(转)--> 左右中（后续）

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode *> st;
        st.push(root);
        while(!st.empty()) {
            //(前序)中左右--> 中右左-->(转)--> 左右中（后续）
            TreeNode* node = st.top();
            st.pop();
            res.push_back(node->val);
            //变成中右左，a按照栈的先进后出，所以先是左边入栈
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        } 
        //最后对res进行反转
        reverse(res.begin(),res.end());
        return res;
    }
};
```

### 总结

此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码⻛格，并不想递归写法那样代码稍做调整，就可以实现前后中序。

这是因为前序遍历中访问节点(遍历节点)和处理节点(将元素放进result数组中)可以同步处理，但 是中序就无法做到同步!

看完上面的知识点，赶紧做几道`leetcode`练练手

## 二叉树的层序遍历

[题目来源](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

题解：

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后 出适合模拟深度优先遍历也就是递归的逻辑。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        vector<int> resTemp;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size(); //记录每一层的个数
            //记得resTemp要清空,或者resTemp在这里再定义
            resTemp = {};
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for(int i=0;i<size;++i) {
                TreeNode * node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            //遍历完一层了后
            res.push_back(resTemp);
        }
        return res;
    }
};
```

## #层次遍历二叉树(从下往上)

[题目来源](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层序遍历为：
```
[
  [15,7],
  [9,20],
  [3]
]
```
题解：

先按照层次遍历的思路走完，然后将`res`反转即可。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> resTemp;
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(resTemp);
        }

        reverse(res.begin(),res.end());
        return res;
    }
};
```

### 二叉树的右视图

[题目来源](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

题解一：

利用层次遍历，然后取每一层的最后一个

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            vector<int> temp;
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                temp.push_back(node->val);
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(temp[temp.size() - 1]);
        }
        return res;
    }
};
```

题解二：优化上述程序，是一层最后一个元素才保存，省去新建一个数组的麻烦

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                //如果是最后一个元素才保存
                if(i == size - 1) res.push_back(node->val);
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

时间复杂度 : `O(n)`

空间复杂度 : `O(n)`


### 二叉树的层平均值

[题目来源](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。 

示例 1：
```
输入：
    3
   / \
  9  20
    /  \
   15   7

输出：[3, 14.5, 11]
解释：
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。
```

题解：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            double sum = 0.0;
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(sum / size);
        }
        return res;
    }
};
```

-----

## 1 重建二叉树
[题目来源剑指offer](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列`{1,2,4,7,3,5,6,8}`和中序遍历序列`{4,7,2,1,5,3,8,6}`，则重建二叉树并返回.

示例：

```
输入
[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]

返回值
{1,2,5,3,4,6,7}
```

题解：递归

首先用一个数组保存中序遍历的位置

找出根节点在中序遍历中的位置

找到根节点，左子树长度(跟节点的左边)，右子树长度(根节点的右边)

递归建立左子树和右子树

```cpp
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //记录中序遍历的位置,卸载这里就不用传了
    unordered_map<int,int> pos;
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
//         unordered_map<int,int> pos;
        for(int i=0;i<vin.size();++i) {
            pos[vin[i]] = i;
        }
//         return build(pos,pre,0,pre.size() - 1,vin,0,vin.size() - 1) ;
        return build(pre,0,pre.size() - 1,vin,0,vin.size() - 1);
    }
    TreeNode* build(vector<int>& preorder, int preLeft, int preRight, vector<int>& inorder, int inLeft, int inRight){
        // preLeft和preRight表示子树在前序遍历中的范围，inLeft和inRight表示子树在中序遍历中的范围
        if(preLeft > preRight){
            return nullptr;
        }
        //前序遍历的第一个位置为根节点
        TreeNode* root = new TreeNode(preorder[preLeft]);
        // 找到root在中序遍历中的位置
        int inRoot = pos[preorder[preLeft]];
        //左子树的长度
        int leftTreeLen = inRoot - inLeft;
        //右子树的长度
        int rightTreeLen = inRight - inRoot;

        root->left = build(preorder, preLeft + 1, preLeft + leftTreeLen, inorder, inLeft, inRoot - 1);
        root->right = build(preorder, preRight - rightTreeLen + 1, preRight, inorder, inRoot + 1, inRight);

        return root;
    }
};
```

### 2.二叉树的下一个节点

[题目来源剑指offer](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

在`TreeNode`的基础上，额外横向增加一个链接节点，数据的序列化格式在`TreeNode`的基础上，额外增加`next`节点的数据，图中红色链路为`next`。

![](./img/树/二叉树中的下一个节点.png)

上图中2节点的next为3节点，以上链接二叉树会被序列化为 `{[1,2,3,#,#,4,#,#,5],[#,3,#,#,#]}`

题解：

![](./img/树/二叉树中的下一个节点01.png)

红色数字是中序遍历的顺序。接下来，我们就假设，如果当前结点分别是`1, 2 3，4，5，6，7`，下一结点看有什么规律没？

```
1 => 2 // 显然下一结点是 1 的父亲结点
2 => 3 // 下一节点是当前结点右孩子的左孩子结点，其实你也应该想到了，应该是一直到左孩子为空的那个结点
3 => 4 // 跟 2 的情况相似，当前结点右孩子结点的左孩子为空的那个结点
4 => 5 // 5 是父亲结点 3 的父亲结点，发现和1有点像，因为 1，3,同样是父亲结点的左孩子
5 => 6 // 跟 4=>5 一样的道理
6 => 7 // 跟 3=>4 一样的道理
7 => null // 因为属于最尾结点
```

此时，可以总结一下：

[1] 是一类：特点：当前结点是父亲结点的左孩子
[2 3 6] 是一类，特点：当前结点右孩子结点，那么下一节点就是：右孩子结点的最左孩子结点,如果右孩子结点没有左孩子就是自己

[4 5]是一类，特点：当前结点为父亲结点的右孩子结点，本质还是[1]那一类

[7]是一类，特点：最尾结点

```cpp
/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        if(!pNode) {
            return pNode;
        }
        //属于【1，2，3】类
        if(pNode->right) {
            pNode = pNode->right;
            //找到右子树的最左节点
            while(pNode->left) {
                pNode = pNode->left;
            }
            return pNode;
        }
        // 属于 [1] 和 [4 5],当前节点在父亲节点的左子树上
        while(pNode->next) {
            TreeLinkNode *root = pNode->next;
            if(root->left == pNode) {
                return root;
            }
            pNode = pNode->next;
        }
        //属于[7]
        return nullptr;
    }
};
```

时间复杂度：最坏情况下为`O(N)`

空间复杂度：`O(1)`

### 3 数的子结构

输入两棵二叉树`A`，`B`，判断`B`是不是A的子结构。（`ps`：我们约定空树不是任意一个树的子结构）

示例：
```
输入：
{8,8,#,9,#,2,#,5},{8,9,#,2}

输出：
true
```

题解：


```cpp
 /*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(pRoot1 == nullptr || pRoot2 == nullptr) return false;
        //写一个函数判断p2是不是p1的子结构
        if(isPart(pRoot1,pRoot2)) return true;
        
        //否则就判断p2是不是p1左子树的子树 或者 p2是不是p1右子树的子树
        return HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);
    }
    bool isPart(TreeNode* pRoot1, TreeNode* pRoot2) {
        //如果p2已经遍历完了说明就是p2的子结构
        if(!pRoot2) return true;
        //如果p1已经遍历结束了p2还没结束或者 p1的值不等于p2的值，就返回false
        if(!pRoot1 || pRoot1->val != pRoot2->val) return false;
        
        //继续比较p1的左子树和p2的左子树 以及 p1的右子树和p2的右子树 
        return isPart(pRoot1->left, pRoot2->left) && isPart(pRoot1->right, pRoot2->right);
    }
};
```

### 4 二叉树的序列化与反序列化


请实现两个函数，分别用来序列化和反序列化二叉树

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果`str`，重构二叉树。

例如，我们可以把一个只有根节点为1的二叉树序列化为"1,"，然后通过自己的函数来解析回这个二叉树


```
输入：
{8,6,10,5,7,9,11}
输出：
{8,6,10,5,7,9,11}
```

题解一：

方法一
可以先把一棵二叉树序列化成一个前序遍历和一个中序遍历的序列，然后在反序列化时通过这两个序列重构出原二叉树

这种思路有两个缺点：

该方法要求二叉树中不能有数值重复的节点；
只有当两个序列中所有数据都读出后才能开始反序列化。如果两个遍历序列的数据是从一个流里读出来的，那么可能需要等待较长的时间

方法二

如果二叉树序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，可以根据前序遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二叉树碰到nullptr指针时，这些nullptr指针序列化为一个特殊的字符（如'#'）

对于如下二叉树，被序列化成字符串“1,2,4,#,#,#,3,5,#,#,6,#,#”

```
      1
     / \
    2   3
   /   / \
  4   5   6
```
反序列化时，第一个读出的数字是1。由于前序遍历是从根节点开始的，这是根节点的值。接下来读出的数字是2，根据前序遍历的规则，这是根节点的左子节点的值。同样，接下来的数字4是值为2的节点的左子节点。接着从序列化字符串里读出两个字符'#'，这表明值为4的节点的左、右子节点均为nullptr指针，因此它是一个叶节点。接下来回到值为2的节点，重建它的右子节点。由于下一个字符是'#'，这表明值为2的节点的右子节点为nullptr指针。这个节点的左、右子树都已经构建完毕，接下来回到根节点，反序列化根节点的右子树

下一个序列化字符串中的数字是3，因此右子树的根节点的值为3。它的左子节点是一个值为5的叶节点，因为接下来的三个字符是“5,#,#”。同样，它的右子节点是值为6的叶节点，因为最后3个字符是“6,#,#”

总结前面的过程，我们都是把二叉树分解成3部分：根节点、左子树和右子树。在处理（序列化或反序列化）它的根节点之后再分别处理它的左、右子树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    //序列化
    string serialize(TreeNode* root) {
        if(root == nullptr) {
            return "#";
        }
        //转成字符串
        return to_string(root->val) + "," + serialize(root->left) + "," + serialize(root->right);
        
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        return deserializeCore(data);
    }

    //反序列化核心代码，将字符串构建成二叉树
    TreeNode* deserializeCore(string &data) {
        //如果已经到字符串末尾了就结束
        if(data == "") return nullptr;

        if(data[0] == '#'){
            data = data.substr(data.find(',') + 1);  //找到#的下一位
            return NULL;
        }

        size_t idx;
        int val = stoi(data,&idx); //取出idx位置宇哥节点的值
        // substr返回一个字符串，从指定位置开始
        data = data.substr(idx + 1);

        //新建一个节点
        TreeNode *node = new TreeNode(val);
        
        node->left = deserializeCore(data);
        node->right = deserializeCore(data);
        

        return node;
    }
};

```

题解二：

广度优先 + 迭代法。其实题目的意思就是写一个函数将二叉树转成字符串（字符串的形式随你定，可以是题目所给的"`[1,2,3,null,null,4,5]`"，也可以是本文代码中"`1 2 3 null null 4 5`"的形式）。然后再写一个函数将字符串成功转回一开始的二叉树，此时最后返回的二叉树必须与题目给的一模一样。<br>
先放C++代码，思路清晰明了，基本注释已写好在代码中。


```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(!root){
            return ""; // 判空
        }
        ostringstream out;
        queue<TreeNode*> bfs;
        bfs.push(root);
        while(!bfs.empty()){
            // 迭代法
            TreeNode* temp = bfs.front();
            bfs.pop();
            if(temp){
                out<< temp -> val << " ";
                bfs.push(temp -> left);
                bfs.push(temp -> right);
            }
            else{
                out<< "null "; // 注意 null 后面有空格
            }
        }
        return out.str(); // out 用来将树转成字符串，元素之间用空格分隔
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(data.empty()){
            return nullptr; // 判空
        }
        istringstream input(data);
        string info;
        vector<TreeNode*> res; // res 用来将字符串里每个元素转成 TreeNode* 形式的元素
        while(input >> info){
            if(info == "null"){ // 注意 null 后面没空格（因为空格是用来分隔字符串的，不属于字符串）
                res.push_back(nullptr);
            }
            else{
                res.push_back(new TreeNode(stoi(info)));
            }
        }
        int pos = 1;
        for(int i = 0; pos < res.size(); ++i){
            // 本循环将 res 中的所有元素连起来，变成一棵二叉树
            if(!res[i]){
                continue;
            }
            res[i] -> left = res[pos++]; // pos 此时指向左子树，++后指向右子树
            if(pos < res.size()){
                res[i] -> right = res[pos++]; // pos 此时指向右子树，++后指向下一个节点的左子树
            }
        }
        return res[0];
    }
};

```

## 5.二叉树的中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

示例 :

![](./img/树/94-01.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]

输入：root = []
输出：[]

输入：root = [1]
输出：[1]
```

题解：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorderTraversal(root,res);
        return res;
    }
private:
    void inorderTraversal(TreeNode *root,vector<int> &res){
        if(!root)   return;
        
        inorderTraversal(root->left,res);
        res.push_back(root->val);
        inorderTraversal(root->right,res);
        
        return;
    }
};
```

## 1.6 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

示例：

```
输入:
    2
   / \
  1   3
输出: true

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

