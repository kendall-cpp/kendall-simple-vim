**动规五部曲如下**:

1. 确定dp数组(dp table)以及下标的含义 
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组(重要)

## 509.斐波那契数
[题目来源](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 `F(n)` 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给你 n ，请计算 F(n) 。
```

动规五部曲：

这里我们要用一个一维`dp`数组来保存递归的结果

1.确定`dp`数组以及下标的含义

`dp[i]`的定义为：第i个数的斐波那契数值是`dp[i]`

2.确定递推公式

为什么这是一道非常简单的入门题目呢？

因为题目已经把递推公式直接给我们了：状态转移方程 `dp[i] = dp[i - 1] + dp[i - 2];`

3.dp数组如何初始化

题目中把如何初始化也直接给我们了，如下：
```
dp[0] = 0;
dp[1] = 1;
```

4.确定遍历顺序

从递归公式`dp[i] = dp[i - 1] + dp[i - 2];`中可以看出，`dp[i]`是依赖 `dp[i - 1]` 和 `dp[i - 2]`，那么遍历的顺序一定是从前到后遍历的

5.举例推导`dp`数组

按照这个递推公式`dp[i] = dp[i - 1] + dp[i - 2]`，我们来推导一下，当`N`为`10`的时候，dp数组应该是如下的数列：

`0 1 1 2 3 5 8 13 21 34 55`

如果代码写出来，发现结果不对，就把`dp`数组打印出来看看和我们推导的数列是不是一致的。

以上我们用动规的方法分析完了，`C++`代码如下：

- 递归解法

```cpp
class Solution {
public:
    //确定返回值和参数
    int fib(int n) {
        // 确定结束条件
        if(n == 0) return 0;
        if(n == 1) return 1;
        // 单层逻辑
        return fib(n - 1 ) + fib(n - 2);
    }
};
```

时间复杂度：`O(2^n)`
空间复杂度：`O(n) ` 算上了编程语言中实现递归的系统栈所占空间

这道题解法直接对应[牛客-跳台阶](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=117&tqId=37764&rp=1&ru=%2Fta%2Fjob-code-high&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

- 使用非递归--数组

```cpp
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;
        vector<int> dp(n + 1);  //0~n
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2;i<=n;++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return  dp[n];
    }
};
```
时间复杂度：`O(n)`

空间复杂度：`O(n)`

可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。

```cpp
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;
        int num1 = 0;
        int num2 = 1;
        int ret;
        for(int i=2;i<=n;++i) {
            ret = num1 + num2;
            num1 = num2;
            num2 = ret;
        }
        return  ret;
    }
};
```
时间复杂度：`O(n)`

空间复杂度：`O(1)`

## 70.爬楼梯
[题目来源](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶


输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

题解：

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;
        vector<int> dp(n);
        dp[0] = 1;
        dp[1] = 2;
        for(int i=2;i<n;++i) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
    }
};
```

优化维护两个数

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;
        int num1 = 1;
        int num2 = 2;
        int ret;
        for(int i=3;i<=n;++i) {
            ret = num1 + num2;
            num1 = num2;
            num2 = ret;
        }
        return ret;
    }
};
```

## 746.使用最小花费爬楼梯

[题目来源](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

 

示例 1：
```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
```

思路：

**动规五部曲如下**:

1. 确定`dp`数组`(dp table)`以及下标的含义

使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组`dp[i]`就可以了。

`dp[i]`的定义：第`i`个台阶所花费的最少体力为`dp[i]`。

2. 确定递推公式

可以有两个途径得到`dp[i]`，一个是`dp[i-1]` 一个是`dp[i-2]`。

那么究竟是选`dp[i-1]`还是`dp[i-2]`呢？

一定是选最小的，所以`dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]`;

注意这里为什么是加`cost[i]`，而不是`cost[i-1],cost[i-2]`之类的，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值。

3. dp数组如何初始化

根据`dp`数组的定义，`dp`数组初始化其实是比较难的，因为不可能初始化为第`i`台阶所花费的最少体力。

那么看一下递归公式，`dp[i]`由`dp[i-1]`，`dp[i-2]`推出，既然初始化所有的`dp[i]`是不可能的，那么只初始化`dp[0]`和`dp[1]`就够了，其他的最终都是`dp[0]dp[1]`推出。

所以初始化代码为：
```cpp
vector<int> dp(cost.size());
dp[0] = cost[0];
dp[1] = cost[1];
```

4. 确定遍历顺序

最后一步，递归公式有了，初始化有了，如何遍历呢？

本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。

因为是模拟台阶，而且`dp[i]`又`dp[i-1]dp[i-2]`推出，所以是从前到后遍历`cost`数组就可以了。

但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来。

5. 举例推导dp数组(重要)

拿示例2：`cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] `，来模拟一下dp数组的状态变化，如下：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/746-01.5h896ui85zk0.png)

注意最后返回的是动态数组`dp`后两位最小的

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        //dp[i]的定义：第i个台阶所花费的最少体力为dp[i]。
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2;i<cost.size();++i) {
            dp[i] = min(dp[i-1],dp[i-2]) + cost[i];
        }
        return min(dp[dp.size() - 1],dp[dp.size() - 2]);
    }
};
```

时间复杂度：O(n)

空间复杂度：O(n)

**优化空间复杂度**

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 维护两个数就可以
        int num1 = cost[0];
        int num2 = cost[1];
        int ret;
        for(int i=2;i<cost.size();++i) {
            ret = min(num1,num2) + cost[i];
            num1 = num2;
            num2 = ret;
        }
        return min(num1,num2);
    }
};
```
时间复杂度：O(n)

空间复杂度：O(1)

## 62.不同路径

[题目来源](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例：
```
输入：m = 3, n = 7
输出：28

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```


