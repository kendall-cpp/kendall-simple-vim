# 数组

### 1.1 搜索插入位置

[题目来源leetcode](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例

```
输入: [1,3,5,6], 5
输出: 2

输入: [1,3,5,6], 2
输出: 1

输入: [1,3,5,6], 0
输出: 0
```

题解：使用二分查找

如果相等直接返回，如果不等就返回`rigth + 1`

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return mid;
            else if(nums[mid] < target) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return right + 1;
    }
};
```

### 1.2 旋转数组的最小数字

[题目来源剑指offer](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)


把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。

NOTE：给出的所有元素都大于`0`，若数组大小为`0`，请返回`0`。

示例：
```cpp
输入：
[3,4,5,1,2]
返回值：
1
```
题解：判断中间的数是否大于等于最右边的，如果是就说明，说明最小数在右边。否则说明在左边。

```cpp
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.empty()) return 0;
        int left = 0;
        int right = rotateArray.size() - 1;
        while (left < right) {  //不能等于，等于还会执行一次left就大于right了
            int mid = left + (right - left) / 2;
            //如果中的的数大于等于右边的,说明左边有序且最小数不可能在左边
            if(rotateArray[mid] >= rotateArray[right]) {
                left = mid + 1;
            }else { //否则中的的数没有大于等于右边，说明右边的有序，且最小数不可能在右边
                right = mid;  //也可能就是中间的数
            }
        }
//         return rotateArray[left];  //这个也行
        return rotateArray[right];
    }
};
```

时间复杂度：二分，所以为`O(longN)`， 但是如果是`[1, 1, 1, 1]`,会退化到`O(n)`

空间复杂度：没有开辟额外空间，为`O(1)`

### 1.3 搜索旋转排序数组

[题目来源leetcode](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 互不相同 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k（0 <= k < nums.length）`上进行了 旋转，使数组变为 [`nums[k], nums[k+1], ..., nums[n-1]`, `nums[0]`, `nums[1]`, `...`, `nums[k-1]]`（下标 从 0 开始 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]`。

给你 旋转后 的数组 nums 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的索引，否则返回 `-1` 。

示例：
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

输入：nums = [1], target = 0
输出：-1
```

题解一：

先判断左边是否有序，如果有序在判断`target`在左边还是右边，

如果左边无序，则右边有序，同样判断`target`在左边还是右边。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 1 && target == nums[0]) return 0;
        if(nums.size() == 1 && target != nums[0]) return -1; 
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return mid;
            //说明左边有序,
            if(nums[mid] >= nums[left]) {  //注意加上等号
            //为啥>=  [3 1] 1
            //只有在2个数的情况下  mid = left
            //说明左半部分是单调递增的7 8 9 0 1

            //    因为左边是有序的，所以可以判断target有没有在左边
                if(target >= nums[left] && target < nums[mid]) //在左边
                {
                    right = mid - 1;
                }else { //否则不在左边
                    left = mid + 1;
                }
            }
            //左边无需,右边是有序的
            else {
                //因为右边是有序的所以可以判断target有没有在右边
                if(target > nums[mid] && target <= nums[right]) { //在右边
                    left = mid + 1;
                }else { //不在右边
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

时间复杂度： `O(logn)`，其中 `n` 为 $nums$ 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 $O(logn)$。

空间复杂度： `O(1)` 。我们只需要常数级别的空间存放变量。

题解二：基于上述方法改进，主要针对`[3,1],1`

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = (int)nums.size() - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] > nums[left]) {
                //说明左半部分是单调递增的7 8 9 0 1
                if (target >= nums[left] && target < nums[mid]) {//7 8
                    right = mid - 1;
                }else{//0 1
                    left = mid + 1;
                }
            }else if (nums[mid] < nums[left]) {
                //说明右半部分是单调递增的7 8 9 0 1 2 3 4 5
                if (target > nums[mid] && target <= nums[right]) { //2 3 4 5
                    left = mid + 1;
                }else{//7 8 9 0
                    right = mid - 1;
                }
            }else{
                //[3,1] target = 1 nums[mid] = 3 不是我们需要的，且left = mid = 0，所以left也不是，所以过滤left->left++
                left++;
            }
        }
        return -1;
    }
};
```


### 1.4 搜索旋转排序数组II
[题目来源leetcode](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。

示例：

```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true

输入: nums = [2,5,6,0,0,1,2], target = 3
输出: false
```
> 这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素

用上诉题解二可以解决此题：

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        if(nums.empty()) return -1;
        int left = 0,right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return true;
            //判断左边是否有序
            if(nums[mid] > nums[left]) {
                //判断target在哪边
                if(target >= nums[left] && target < nums[mid]) {
                    //说明在左边
                    right = mid - 1;
                }
                else { //说明不在左边
                    left = mid + 1;
                }
            }
            //右边有序
            else if(nums[mid] < nums[left]) {
                //说明在右边
                if(target <= nums[right] && target > nums[mid]) {
                    left = mid + 1;
                }
                else {
                    right = mid - 1;
                }
            }
            else {
                ++left;
            }
        }
        return false;
    }
};
```
时间复杂度： `O(logn)`，其中 n 为  `nums` 数组的大小。整个算法时间复杂度即为二分查找的时间复杂度 `O(logn)`。

空间复杂度： `O(1) `

### 1.5 在排序数组中查找数字 I  

[题目来源](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

统计一个数字在排序数组中出现的次数。

 

示例 1:
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

题解：首先使用二叉查找找到`target`，找到了再往两边延伸找。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        int res = 0;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                ++res;
                //往两边走
                int front = mid - 1,last = mid + 1;
                while(front>=left && nums[front] == target) {
                    ++ res;
                    --front;
                }
                while(last<= right && nums[last] == target ) {
                    ++ res;
                    ++last;
                }
                return res;
            }
            else if(nums[mid] < target) {
                left = mid + 1;
            }else {
                right = mid - 1;
            }
        }
        return res;
    }
};
```

平均情况下，二分查找的时间复杂度为`O(log(n))`，当数组元素全部等于`target`时，退化到`O(n)`.

空间复杂度为`O(1)` 几个变量使用常数大小的额外空间。
     
#### 1.5.1  在排序数组中查找元素的第一个和最后一个位置

[题目来源](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 `nums`，和一个目标值` target`。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 `[-1, -1]`。

进阶：

你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？
 

示例 1：
```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```


这道题和上题是一样的，只是返回值不一样而已

题解：

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        vector<int> res{-1,-1};
        int lidx = -1,ridx = -1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                lidx = mid;
                ridx = mid;
                int front = mid - 1;
                int last = mid + 1;
                while(front >= left && nums[front] == target) {
                    --lidx;
                    --front;
                }
                while(last <= right && nums[last] == target) {
                    ++ridx;
                    ++last;
                }
                res[0] = lidx;
                res[1] = ridx;
                return res;
            }
            else if(nums[mid] < target) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return res;
    }
};
```
### 1.6 0～n-1中缺失的数字

[题目来源](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:
```
输入: [0,1,3]
输出: 2
示例 2:

输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

**题解一**：

判断数组索引和索引所在的值是否相等，如果相等，说明缺失数在右边，如果不等说明在左边。

最后注意，当没有缺失，也就是遍历到最后一个索引仍等于索引所在的值，这时候输出 索引后一位，否则就返回索引

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(mid == nums[mid]) {
                left = mid + 1;
            }
            else {
                right = mid;
            }
        }
        if(nums[left] == left) {
            return left + 1;  //如果没有缺失，就返回索引后一位
        }
        else 
            return left; //返回索引
    }
};
```
时间复杂度 `O(log N)`： 二分法为对数级别复杂度。

空间复杂度 `O(1)`： 几个变量使用常数大小的额外空间。

**题解二**：

直接遍历查找数组值与下标不等的

```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int i = 0 ;
        for(;i<nums.size();++i) {
            if(nums[i] != i) {
                return i;
            }
        }
        return i;
    }
};
```

### 1.7 寻找峰值

峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

示例 1：
```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

**题解**：

- 首先要注意题目条件，在题目描述中出现了 `nums[-1] = nums[n] = -∞`，这就代表着 只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值
- 根据上述结论，我们就可以使用二分查找找到峰值
- 查找时，左指针 `left`，右指针 `right`，以其保持左右顺序为循环条件
- 根据左右指针计算中间位置 `mid`，并比较 `mid` 与 `mid+1` 的值，如果 `mid` 较大，则左侧存在峰值，`right = mid`，如果 `mid + 1` 较大，则右侧存在峰值，`left = mid + 1`


```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0,right = nums.size() - 1;
        while (left < right ) {
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[mid + 1]) {
                //峰值在左边,而且mid的数可能就是峰值
                right = mid;
            }
            else  {
                //峰值在右边
                left = mid + 1;
            }
        }
        return left;
    }
};
```
时间负责度：`O(logN)`

空间复杂度：`O(1)`

### 1.7 寻找两个正序数组的中位数

[题目来源](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
 

示例 ：
```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```
    
题解：

参考：
https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/zong-he-bai-jia-ti-jie-zong-jie-zui-qing-xi-yi-don/


```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) 
    {
        int m = nums1.size();
        int n = nums2.size();
        //中位数 = （left + right）/2
        int left = (m + n + 1) / 2;
        int right = (m + n + 2) / 2;
        return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0;
    }
    //在两个有序数组中找到第k个元素（例如找第一个元素，k=1，即nums[0]）
    //i: nums1的起始位置 j: nums2的起始位置（i，j都是从0开始）
    int findKth(vector<int>& nums1, int i, vector<int>& nums2, int j, int k)
    {
        //若nums1为空（或是说其中数字全被淘汰了）
        //在nums2中找第k个元素，此时nums2起始位置是j，所以是j+k-1
        if(i >= nums1.size())    return nums2[j + k - 1];
        //nums2同理
        if(j >= nums2.size())    return nums1[i + k - 1];

        //递归出口
        if(k == 1)  return std::min(nums1[i], nums2[j]);

        //这两个数组的第K/2小的数字，若不足k/2个数字则赋值整型最大值，以便淘汰另一数组的前k/2个数字
        int midVal1 = (i + k/2 - 1 < nums1.size()) ? nums1[i + k/2 - 1] : INT_MAX;
        int midVal2 = (j + k/2 - 1 < nums2.size()) ? nums2[j + k/2 - 1] : INT_MAX;
        //二分法核心部分
        if(midVal1 < midVal2)
            return findKth(nums1, i + k/2, nums2, j, k - k/2);
        else
            return findKth(nums1, i, nums2, j + k/2, k - k/2);
    }
};

```
时间复杂度：`O（log (m+n)）`

空间复杂度：`O（1`），尾递归，编译器不需要不停地开辟栈空间

## 2.其他查找

### 2.1 两数之和

[题目来源](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例：

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 

输入：nums = [3,2,4], target = 6
输出：[1,2]
```

题解一:暴力法

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        for(int i=0;i<nums.size() - 1;++i) {
            for(int j=i+1;j<nums.size();++j) {
                if(nums[i] + nums[j] == target) {
                    res.push_back(i);
                    res.push_back(j);
                }
            }
        }
        return res;
    }
};
```

时间复杂度：`O(n^2)`

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> map;
        //使用哈希表：key:值，value:索引
        for(int i=0;i<nums.size();++i) {
            auto iter = map.find(target - nums[i]);
            //(*it).first会得到key，
            //(*it).second会得到value。
            if(iter != map.end()) {
                return {iter->second,i};
            }
            map.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

时间复杂度：`O(N)`