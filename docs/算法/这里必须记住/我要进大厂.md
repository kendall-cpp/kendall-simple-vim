
- [面试写树的算法写不出我就是大猪蹄子](#面试写树的算法写不出我就是大猪蹄子)
  - [重建二叉树](#重建二叉树)
    - [知道后序中序重建二叉树](#知道后序中序重建二叉树)
    - [知道前序中序重建二叉树](#知道前序中序重建二叉树)
  - [二叉搜索树的第k个结点](#二叉搜索树的第k个结点)
  - [二叉树的镜像](#二叉树的镜像)
  - [从上往下打印二叉树](#从上往下打印二叉树)
    - [剑指 Offer 32 - II. 从上到下打印二叉树 II](#剑指-offer-32---ii-从上到下打印二叉树-ii)
    - [剑指 Offer 32 - III. 从上到下打印二叉树 III](#剑指-offer-32---iii-从上到下打印二叉树-iii)
  - [二叉搜索树的后序遍历序列](#二叉搜索树的后序遍历序列)
- [链表相关](#链表相关)
  - [面试题 02.01. 移除重复节点-链表去重](#面试题-0201-移除重复节点-链表去重)


-------

## 面试写树的算法写不出我就是大猪蹄子

> 关于二叉树问题，用递归法能解决大部分问题

### 重建二叉树

[可以参考这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484950&idx=1&sn=3900f9433d36dd5406fc1ccb1df07703&scene=21#wechat_redirect)

#### 知道后序中序重建二叉树

[leetcode题目](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

首先判断遍历是否为空，如果为空直接返回 NULL

接着找到后序遍历的最后一个节点，创建并放在 root 节点中，判断如果只有一个节点就直接返回 root

在中序遍历中找到后序遍历最后一个元素的位置 mid

然后开始截取，先截取中序遍历，在 mid 位置处；

后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。所以要删掉先。

再截取后续遍历，在 `leftInorder.size()` 位置处

最后递归建左子树和右子树。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //判断节点是否为空
        if(inorder.size() == 0) {
            return nullptr;
        }
        //取出后序遍历最后一个节点，就是头结点
        int val = postorder[postorder.size() - 1];
        // 建立根节点
        TreeNode* root = new TreeNode(val);
        //如果只有一节点的话，就直接返回根节点
        if(postorder.size() == 1) return root;

        int mid ;
        //找出后序遍历最后的节点在中序遍历的位置
        for(int i=0;i<inorder.size();++i) {
            if(inorder[i] == root->val){
                mid = i;
                break;
            }
        }

        //先切割中序，再切割后序

        // 中序遍历，不要当前节点了
        // [9,3,15,20,7]   截取 9
        vector<int> leftInotder(inorder.begin(),inorder.begin() + mid); //mid = 1
        //注意这里不要已经遍历的节点了
        vector<int> rightInorder(inorder.begin() + mid + 1, inorder.end());

        //舍去没元素
        postorder.resize(postorder.size() - 1); //设置大小（size）,如果超过就删除后面的

        //后序遍历

        //[9,15,7,20]    9   （3已经被删除了）
        vector<int> leftPostorder (postorder.begin(),postorder.begin() + leftInotder.size());
        // 15,7,20  （3已经被删除了）
        vector<int> rightPostorder (postorder.begin() + leftInotder.size(),postorder.end());

        //递归建树
        root->left = buildTree(leftInotder,leftPostorder);
        root->right = buildTree(rightInorder,rightPostorder);

        return root;
    }
};
```

测试`vector`复制

```cpp
int main() {
    vector<int> temp = {1,2,3};
    vector<int> vec1 = {1,2,3,4,5};
    vector<int> vec2 (vec1.begin(),vec1.begin() + temp.size());
    vector<int> vec3 (vec1.begin() + temp.size(),vec1.end());

    vector<int>::iterator it = vec2.begin();
    for(;it!=vec2.end();++it) {
        cout << *it << " ";  //1,2,3,   也就是[1,2,3,4)    
    }
    cout << endl;
    vector<int>::iterator it3 = vec3.begin();
    for(;it3!=vec3.end();++it3) {
        cout << *it3 << " ";  //4,5    
    }
    cout << endl;
}
```

#### 知道前序中序重建二叉树

[剑指offer题目](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

思想和上一题一样

就是先找前序遍历在中序遍历中的位置，然后再切割。

最后递建 左右子树

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        //判断遍历是否为空
       if(pre.size() == 0) return NULL;
        
        //找到前序遍历第一个元素
        int val = pre[0];
        TreeNode* root = new TreeNode(val);
        // 如果只有一个元素，那么就是只有一个节点，直接返回root
        if(pre.size() == 1) return root;
        
        //找前序遍历第一个元素在中序遍历中的位置
        int mid = 0;
        for(;mid < vin.size();++mid) {
            if(vin[mid] == val) break;
        }
        
        //开始切割
        
        //中序遍历,不要正在遍历的节点
        vector<int> leftVin(vin.begin(),vin.begin() + mid);
        vector<int> rightVin(vin.begin() + mid + 1,vin.end());
        
        //删除前序遍历第一个节点
        pre.erase(pre.begin());
        
        //前序遍历
        vector<int> leftPre (pre.begin(),pre.begin() + leftVin.size());
        vector<int> rightPre (pre.begin() + leftVin.size(),pre.end());
        
        root->left = reConstructBinaryTree(leftPre, leftVin);
        root->right = reConstructBinaryTree(rightPre, rightVin);
        
        return root;
        
    }
};
```

### 二叉搜索树的第k个结点

[剑指offer题目](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一棵二叉搜索树，请找出其中第k大的节点。

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

使用中序遍历，然后用一个数组保存

记住最后要判断 k 是否超过数组的长度

- 递归法

```cpp
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        if(pRoot==NULL||k<=0) return NULL;
        vector<TreeNode*> vec;
        midTraver(pRoot,vec);
        if(k > vec.size()) {
            return NULL;  //一定要判断是否越界
        }
        return vec[k-1];
    }
   void midTraver(TreeNode* pRoot,vector<TreeNode*> &vec) {
       if(pRoot == nullptr) return;
       if(pRoot->left) midTraver(pRoot->left, vec);
       vec.push_back(pRoot);
       if(pRoot->right) midTraver(pRoot->right, vec);
   }
    
};
```

### 二叉树的镜像

[剑指offer题目](https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&&tqId=11171&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目-剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- 递归法

首先将根节点放入翻转函数中

交换左右子树，接下来使用递归翻转左右子树

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        if(pRoot == nullptr) return nullptr;
        reverse(pRoot);
        return pRoot;
    }
    void reverse(TreeNode* root) {
        if(root == nullptr) return ;
        //交换左右子树
        swap(root->left,root->right);
        //然后继续翻转下面的语句
        reverse(root->left);
        reverse(root->right);
    }
};
```

- 迭代法

使用队列，**层次遍历**，然后把左右子树翻转

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
       if(pRoot == nullptr) return nullptr;
        queue<TreeNode*> que;
        que.push(pRoot);
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left,node->right);
                //这里一定要放端 该节点是否存在再加入队列中
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return pRoot;
    }
};
```

### 从上往下打印二叉树

[剑指offer题目](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

示例1

```
输入：
{5,4,#,3,#,2,#,1}
复制
返回值：
[5,4,3,2,1]
```

```cpp
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return  res;
        queue<TreeNode* > que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                res.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

#### 剑指 Offer 32 - II. 从上到下打印二叉树 II

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

 ```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

- 用队列，然后使用层次遍历，先用一个数组存每一层的结果，在放到最终的返回数组中。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            temp = {};
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(temp);
        }
        return res;
     }
};
```


#### 剑指 Offer 32 - III. 从上到下打印二叉树 III

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 

例如:
```
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]
```

这题其实就是之字形打印树

用一个变量记录层次就可以了

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        int level = 0;  //记录层次
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            ++level;
            int size = que.size();
            temp = {};
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            if(level % 2 == 0) reverse(temp.begin(),temp.end());
            res.push_back(temp);
        }
        return res;
     }
};
```

### 二叉搜索树的后序遍历序列

[剑指offer题目](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）

示例1
```
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true
```


## 链表相关

### 面试题 02.01. 移除重复节点-链表去重

> 好未来实习二面

[题目来源](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:
```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

使用哈希表保存判断重复节点

注意一开始先让头节点数进入哈希表

然后传入 `p`( `p=head->next` )。pre 记录记录前面的节点

```cpp
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        unordered_map<int,int> mp;
        ListNode* p = head->next;
        ListNode* pre = head;
        //首先得把头结点放进哈希表
        mp[head->val] = 1;
        while(p) {
            if(mp.count(p->val) != 0) {    //已经存在
                pre->next = p->next;
                p = p->next;
            }
            else {
                mp[p->val] = 1;
                p = p->next;
                pre = pre->next;
            }
        }
        return head;
    }
};
```


