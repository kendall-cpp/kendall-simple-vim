
- [面试写树的算法写不出我就是大猪蹄子](#面试写树的算法写不出我就是大猪蹄子)
  - [重建二叉树](#重建二叉树)
    - [知道后序中序重建二叉树](#知道后序中序重建二叉树)
    - [知道前序中序重建二叉树](#知道前序中序重建二叉树)
  - [二叉搜索树的第k个结点](#二叉搜索树的第k个结点)
  - [二叉树的镜像](#二叉树的镜像)
  - [从上往下打印二叉树](#从上往下打印二叉树)
    - [剑指 Offer 32 - II. 从上到下打印二叉树 II](#剑指-offer-32---ii-从上到下打印二叉树-ii)
    - [按之字形顺序打印二叉树](#按之字形顺序打印二叉树)
  - [二叉搜索树的后序遍历序列](#二叉搜索树的后序遍历序列)
  - [二叉树中和为某一值的路径](#二叉树中和为某一值的路径)
  - [112. 路径总和](#112-路径总和)
  - [二叉树的深度](#二叉树的深度)
  - [对称的二叉树](#对称的二叉树)
  - [101. 对称二叉树](#101-对称二叉树)
- [链表相关](#链表相关)
  - [面试题 02.01. 移除重复节点-链表去重](#面试题-0201-移除重复节点-链表去重)
    - [82. 删除排序链表中的重复元素 II](#82-删除排序链表中的重复元素-ii)
  - [两个链表的第一个公共结点](#两个链表的第一个公共结点)
  - [环形链表（链表是否有环）](#环形链表链表是否有环)
    - [链表中环的入口结点](#链表中环的入口结点)
  - [两个链表的第一个公共结点](#两个链表的第一个公共结点-1)
  - [复杂链表的复制](#复杂链表的复制)
  - [合并两个排序的链表](#合并两个排序的链表)
  - [链表中倒数第k个结点(团灭3题)](#链表中倒数第k个结点团灭3题)
    - [19. 删除链表的倒数第 N 个结点](#19-删除链表的倒数第-n-个结点)
    - [面试题 02.02. 返回倒数第 k 个节点](#面试题-0202-返回倒数第-k-个节点)
  - [剑指 Offer 18. 删除链表的节点](#剑指-offer-18-删除链表的节点)
    - [237. 删除链表中的节点](#237-删除链表中的节点)
  - [反转链表](#反转链表)
  - [25. K 个一组翻转链表](#25-k-个一组翻转链表)
    - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
  - [203. 移除链表元素](#203-移除链表元素)
- [数组相关](#数组相关)
  - [1. 两数之和](#1-两数之和)
  - [15. 三数之和](#15-三数之和)
    - [18. 四数之和](#18-四数之和)
- [动态规划](#动态规划)
  - [322. 零钱兑换](#322-零钱兑换)
  - [1143. 最长公共子序列(重要)](#1143-最长公共子序列重要)
  - [72. 编辑距离(多看)](#72-编辑距离多看)
  - [股票问题](#股票问题)
    - [121. 买卖股票的最佳时机](#121-买卖股票的最佳时机)
    - [122.买卖股票的最佳时机 II](#122买卖股票的最佳时机-ii)
    - [123.买卖股票的最佳时机 III](#123买卖股票的最佳时机-iii)
    - [188.买卖股票的最佳时机 IV](#188买卖股票的最佳时机-iv)
    - [309. 最佳买卖股票时机含冷冻期](#309-最佳买卖股票时机含冷冻期)
    - [714. 买卖股票的最佳时机含手续费](#714-买卖股票的最佳时机含手续费)
  - [打家劫舍系列问题](#打家劫舍系列问题)
    - [198. 打家劫舍](#198-打家劫舍)
    - [213. 打家劫舍 II](#213-打家劫舍-ii)
  - [正则表达式匹配](#正则表达式匹配)
- [其他](#其他)
  - [设计LRU缓存结构](#设计lru缓存结构)
- [位运算相关](#位运算相关)
  - [136. 只出现一次的数字](#136-只出现一次的数字)
  - [137. 只出现一次的数字 II](#137-只出现一次的数字-ii)


-------

## 面试写树的算法写不出我就是大猪蹄子

> 关于二叉树问题，用递归法能解决大部分问题

### 重建二叉树

[可以参考这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484950&idx=1&sn=3900f9433d36dd5406fc1ccb1df07703&scene=21#wechat_redirect)

#### 知道后序中序重建二叉树

[leetcode题目](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

首先判断遍历是否为空，如果为空直接返回 NULL

接着找到后序遍历的最后一个节点，创建并放在 root 节点中，判断如果只有一个节点就直接返回 root

在中序遍历中找到后序遍历最后一个元素的位置 mid

然后开始截取，先截取中序遍历，在 mid 位置处；

后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。所以要删掉先。

再截取后续遍历，在 `leftInorder.size()` 位置处

最后递归建左子树和右子树。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //判断节点是否为空
        if(inorder.size() == 0) {
            return nullptr;
        }
        //取出后序遍历最后一个节点，就是头结点
        int val = postorder[postorder.size() - 1];
        // 建立根节点
        TreeNode* root = new TreeNode(val);
        //如果只有一节点的话，就直接返回根节点
        if(postorder.size() == 1) return root;

        int mid ;
        //找出后序遍历最后的节点在中序遍历的位置
        for(int i=0;i<inorder.size();++i) {
            if(inorder[i] == root->val){
                mid = i;
                break;
            }
        }

        //先切割中序，再切割后序

        // 中序遍历，不要当前节点了
        // [9,3,15,20,7]   截取 9
        vector<int> leftInotder(inorder.begin(),inorder.begin() + mid); //mid = 1
        //注意这里不要已经遍历的节点了
        vector<int> rightInorder(inorder.begin() + mid + 1, inorder.end());

        //舍去没元素
        postorder.resize(postorder.size() - 1); //设置大小（size）,如果超过就删除后面的

        //后序遍历

        //[9,15,7,20]    9   （3已经被删除了）
        vector<int> leftPostorder (postorder.begin(),postorder.begin() + leftInotder.size());
        // 15,7,20  （3已经被删除了）
        vector<int> rightPostorder (postorder.begin() + leftInotder.size(),postorder.end());

        //递归建树
        root->left = buildTree(leftInotder,leftPostorder);
        root->right = buildTree(rightInorder,rightPostorder);

        return root;
    }
};
```

测试`vector`复制

```cpp
int main() {
    vector<int> temp = {1,2,3};
    vector<int> vec1 = {1,2,3,4,5};
    vector<int> vec2 (vec1.begin(),vec1.begin() + temp.size());
    vector<int> vec3 (vec1.begin() + temp.size(),vec1.end());

    vector<int>::iterator it = vec2.begin();
    for(;it!=vec2.end();++it) {
        cout << *it << " ";  //1,2,3,   也就是[1,2,3,4)    
    }
    cout << endl;
    vector<int>::iterator it3 = vec3.begin();
    for(;it3!=vec3.end();++it3) {
        cout << *it3 << " ";  //4,5    
    }
    cout << endl;
}
```

#### 知道前序中序重建二叉树


[剑指offer题目](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

思想和上一题一样

就是先找前序遍历在中序遍历中的位置，然后再切割。

最后递建 左右子树

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        //判断遍历是否为空
       if(pre.size() == 0) return NULL;
        
        //找到前序遍历第一个元素
        int val = pre[0];
        TreeNode* root = new TreeNode(val);
        // 如果只有一个元素，那么就是只有一个节点，直接返回root
        if(pre.size() == 1) return root;
        
        //找前序遍历第一个元素在中序遍历中的位置
        int mid = 0;
        for(;mid < vin.size();++mid) {
            if(vin[mid] == val) break;
        }
        
        //开始切割
        
        //中序遍历,不要正在遍历的节点
        vector<int> leftVin(vin.begin(),vin.begin() + mid);
        vector<int> rightVin(vin.begin() + mid + 1,vin.end());
        
        //删除前序遍历第一个节点
        pre.erase(pre.begin());
        
        //前序遍历
        vector<int> leftPre (pre.begin(),pre.begin() + leftVin.size());
        vector<int> rightPre (pre.begin() + leftVin.size(),pre.end());
        
        root->left = reConstructBinaryTree(leftPre, leftVin);
        root->right = reConstructBinaryTree(rightPre, rightVin);
        
        return root;
        
    }
};
```

### 二叉搜索树的第k个结点

[剑指offer题目](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一棵二叉搜索树，请找出其中第k大的节点。

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

使用中序遍历，然后用一个数组保存

记住最后要判断 k 是否超过数组的长度

- 递归法

```cpp
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        if(pRoot==NULL||k<=0) return NULL;
        vector<TreeNode*> vec;
        midTraver(pRoot,vec);
        if(k > vec.size()) {
            return NULL;  //一定要判断是否越界
        }
        return vec[k-1];
    }
   void midTraver(TreeNode* pRoot,vector<TreeNode*> &vec) {
       if(pRoot == nullptr) return;
       if(pRoot->left) midTraver(pRoot->left, vec);
       vec.push_back(pRoot);
       if(pRoot->right) midTraver(pRoot->right, vec);
   }
    
};
```

### 二叉树的镜像

[剑指offer题目](https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&&tqId=11171&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目-剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- 递归法

首先将根节点放入翻转函数中

交换左右子树，接下来使用递归翻转左右子树

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        if(pRoot == nullptr) return nullptr;
        reverse(pRoot);
        return pRoot;
    }
    void reverse(TreeNode* root) {
        if(root == nullptr) return ;
        //交换左右子树
        swap(root->left,root->right);
        //然后继续翻转下面的语句
        reverse(root->left);
        reverse(root->right);
    }
};
```

- 迭代法

使用队列，**层次遍历**，然后把左右子树翻转

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
       if(pRoot == nullptr) return nullptr;
        queue<TreeNode*> que;
        que.push(pRoot);
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left,node->right);
                //这里一定要放端 该节点是否存在再加入队列中
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return pRoot;
    }
};
```

### 从上往下打印二叉树

[剑指offer题目](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

示例1

```
输入：
{5,4,#,3,#,2,#,1}
复制
返回值：
[5,4,3,2,1]
```

```cpp
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return  res;
        queue<TreeNode* > que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                res.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

#### 剑指 Offer 32 - II. 从上到下打印二叉树 II

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

- 用队列，然后使用层次遍历，先用一个数组存每一层的结果，在放到最终的返回数组中。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            temp = {};
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(temp);
        }
        return res;
     }
};
```


#### 按之字形顺序打印二叉树

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

[剑指offer题目](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&&tqId=11212&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 
例如:
```
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]
```

这题其实就是之字形打印树

用一个变量记录层次就可以了

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        int level = 0;  //记录层次
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            ++level;
            int size = que.size();
            // temp = {};
            temp.clear();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            if(level % 2 == 0) reverse(temp.begin(),temp.end());
            res.push_back(temp);
        }
        return res;
     }
};
```

### 二叉搜索树的后序遍历序列

[剑指offer题目](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）

示例1
```
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true
```

使用一个函数传入后序遍历数组和前后位置

找到后序遍历的最后一个节点，再找左子树的最后位置，接着找右子树的最后位置。

最后右子树的最后位置正好是最后一个节点时说明是二叉搜索树，当然也要保证左右子树也是。


```cpp
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return myPostorder(postorder,0,postorder.size() - 1);
    }
    bool myPostorder(vector<int> postorder,int start,int len) {
        // 如果只有一个节点，也就是start == len 返回tre
        if(start >= len) {
            return true;
        }

        //找出左子树后续遍历的最后一个节点的位置。也就是比 len 位置小的
        int index = start;
        int rootVal = postorder[len];
        while(postorder[index] < rootVal)
        {
            ++index;
        }
        int leftLen = index - 1;

        //找右子树后续遍历的最后一个节点，如果正好遍历到 len 说明是 true，
        while(postorder[index] > rootVal ) {
            ++index;
        }
        //这棵子树是二叉搜索树，它的左右子树也必须是
        return index == len 
            && myPostorder(postorder,start,leftLen)
            && myPostorder(postorder,leftLen + 1,len-1);  //这里记得 -1，因为头接地那不要了
    }
};
```

### 二叉树中和为某一值的路径

[剑指offer题目](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetocde题目](https://leetcode-cn.com/problems/path-sum-ii/)


输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

示例：

```
输入：
{10,5,12,4,7},22
返回值：
[[10,5,7],[10,12]]
```

使用回溯，采用目标和递减的方式，到 0 的时候结束

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        if(root == nullptr) return result;
        //先把根节点放进去
        path.push_back(root->val);
        backtracking(root,expectNumber - root->val);
        return result;
    }
    void backtracking(TreeNode* root,int target)
    {
        //结束条件
        //到叶子节点满足
        if(root->left == nullptr && root->right == nullptr && target == 0){
            result.push_back(path);
            return;
        }
        //遇到叶子节点而没有找到合适的边，直接返回
        if(root->left == nullptr && root->right == nullptr) return;
        
        //左子树
        if(root->left) {
            target -= root->left->val;
            path.push_back(root->left->val);
            backtracking(root->left, target);
            target += root->left->val;
            path.pop_back();            
        }
        //右子树
        if(root->right) {
            target -= root->right->val;
            path.push_back(root->right->val);
            backtracking(root->right, target);
            target += root->right->val;
            path.pop_back();            
        }
    }
};
```

### 112. 路径总和

[leetcode题目](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```

使用回溯法，，采用目标和递减的方式，到 0 的时候结束，左子树和右子树有一边满足就返回 true

需要注意，传入根节点的时候这时候和为 targetSum - root->val

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        return backtracking(root,targetSum - root->val); //已经遍历第一个节点，所以 targetSum - root->val
    }
    bool backtracking(TreeNode* root,int targetSum) {
        //满足条件
        if(root->left == nullptr && root->right == nullptr && targetSum == 0) return true;
        //已经到叶子节点了还不满足
        if(root->left == nullptr && root->right == nullptr && targetSum != 0) return false;

        //然后分别判断左右子树
        if(root->left) {
            targetSum -= root->left->val;
            if(backtracking(root->left,targetSum)) return true;
            targetSum += root->left->val;
        }
        if(root->right) {
            targetSum -= root->right->val;
            if(backtracking(root->right,targetSum)) return true;
            targetSum += root->right->val;
        }
        return false;
    }
};
```

### 二叉树的深度

[剑指offer题目](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

- 直接递归计算左右子树的最大值 + 本层（1）。

```cpp
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        if(pRoot == nullptr) return 0;
        return max(TreeDepth(pRoot->left),TreeDepth(pRoot->right)) + 1;
    }
};
```

- 层次遍历迭代法

```cpp
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        if(pRoot == nullptr) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(pRoot);
        while(!que.empty()) {
            int size = que.size();
            ++depth;
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 对称的二叉树

[对称的二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&&tqId=11211&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

示例1

```
输入：
{8,6,6,5,7,7,5}

返回值：
true
```

```cpp

```

### 101. 对称二叉树

[leetcode 题目来源](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

- 使用递归来做，先写个递归函数，分别传入左子树和右子树，然后判断左子树和右子树是否相等。不相等就直接返回 false，这时候记得判断左右子树是否有一边为空，为空就返回false，如果全为空就返回 true。

```cpp
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot==nullptr) return true; //至少有一个节点
        return myIsSymmetrical(pRoot->left, pRoot->right); 
    }
    bool myIsSymmetrical(TreeNode* lnode,TreeNode* rnode) {
        //如果一遍为空就返回false
        if(lnode == nullptr && rnode == nullptr) return true;
        if (  (lnode == nullptr && rnode != nullptr)
            || (lnode != nullptr && rnode == nullptr)
            )
        {
            return false;
        }
        // 如果不相等那么就返回false
        if(lnode->val != rnode->val) return false;
        
        bool lflag =  myIsSymmetrical(lnode->left,rnode->right);
        bool rflag = myIsSymmetrical(lnode->right, rnode->left);
        return lflag && rflag;
    }
};
```

- 使用队列,注意一开始要判断左右子树是否为空，然后根节点不用入队，直接判断孩子节点

```cpp
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot == nullptr || (pRoot->left == nullptr && pRoot->right == nullptr) ) return true;
        queue<TreeNode*> que;
        que.push(pRoot->left);
        que.push(pRoot->right);
        while(!que.empty())
        {
            TreeNode* nodeleft = que.front();
            que.pop();
            TreeNode* noderight = que.front();
            que.pop();
            //注意这里要先判断空再判断不空
            if(nodeleft == nullptr && noderight == nullptr) continue;
            if(!nodeleft || !noderight || (nodeleft->val != noderight->val)) {
                return false;
            }
            if(nodeleft->val != noderight->val) return false;
            
            que.push(nodeleft->left);  ///左子树左孩子
            que.push(noderight->right); ////右子树右孩子
            que.push(nodeleft->right);  ////左子树右孩子
            que.push(noderight->left);  ////右子树左孩子
        }
        return true;
    }
};
```


------


## 链表相关

### 面试题 02.01. 移除重复节点-链表去重

> 好未来实习二面

[题目来源](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)


编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:
```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

使用哈希表保存判断重复节点

注意一开始先让头节点数进入哈希表

然后传入 `p`( `p=head->next` ，pre 记录记录前面的节点

```cpp
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        unordered_map<int,int> mp;
        ListNode* p = head->next;
        ListNode* pre = head;
        //首先得把头结点放进哈希表
        mp[head->val] = 1;
        while(p) {
            if(mp.count(p->val) != 0) {    //已经存在
                pre->next = p->next;
                p = p->next;
            }
            else {
                mp[p->val] = 1;
                p = p->next;
                pre = pre->next;
            }
        }
        return head;
    }
};
```

- 或者用 unordered_set (效率很低)

```cpp
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr) return pHead;
        unordered_set<int> st;
        ListNode* p = pHead->next;
        ListNode* pre = pHead;
        st.insert(pHead->val);
        while(p) {
            if(st.count(p->val) == 1) {
                pre->next = p->next;
                p = p->next;
            }else {
                st.insert(p->val);
                p = p->next;
                pre = pre->next;
            }
        }
        return pHead;
    }
};
```

#### 82. 删除排序链表中的重复元素 II

[leetcode](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

[剑指offer题目](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。

返回同样按升序排列的结果链表。

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

注意这题是**排好序**了的

>几乎所有的链表题目，都具有相似的解题思路。

> 建一个「虚拟头节点」dummy 以减少边界判断，往后的答案链表会接在 dummy 后面

> 使用 tail 代表当前有效链表的结尾

> 通过原输入的 head 指针进行链表扫描

解题思路：

> 让 tail 指针一直指向有效链表的最后

设置一个虚拟节点，以 head 不空作为循环条件

如果下一个节点为空 或者下一个节点和当前节点不同，就让 tail 指向当前节点

如果下一个节点不空且和当前节点相同，就让 head 往后移

最后向后移动 head，直到 head 为空

记得让 `tail->next = nullptr;`

返回的是 `dumpy->next`;

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *dumpy = new ListNode(-1);
        ListNode *tail = dumpy;
        while(head) {
            //如果和后面一个节点值不同就让tail指向最后一个节点
            if(head->next == nullptr || head->val != head->next->val) {
                tail->next = head;
                tail = head;
            }
            //和下一个节点相同就一直往后移head
            while(head->next && head->val == head->next->val) {
                head = head->next;
            }
            head = head->next;
        }
        tail->next = nullptr;
        return dumpy->next;
    }
};
```

### 两个链表的第一个公共结点

[题目来源](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

思路：

使用一个哈希表保存第一个链表，然后再去第二个链表进行查找

```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        unordered_map<int,int> mp;
        ListNode* ph1 = pHead1;
        while(ph1) {
            mp[ph1->val] = ph1->val;
            ph1 = ph1->next;
        }
        ListNode* ph2 = pHead2;
        while(ph2)
        {
            if(mp.count(ph2->val) != 0) return ph2;
            ph2 = ph2->next;
        }
        return nullptr;
    }
};
```

### 环形链表（链表是否有环）

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

题解：快慢指针来做

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==NULL || head->next == NULL) return false;
        ListNode *slow = head;
        ListNode *fast = head;
        while(slow->next && fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) return true;  //不能比较值，因为可能值相同
        }
        return false;
    }
};
```

#### 链表中环的入口结点

[剑指offer题目](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

[leetcode题目](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。

思路：

使用快慢指针，但是注意不是快慢指针相等就是环的入口

如果有环就用一个指针从头开始追，追到慢指针就是入口啦

```cpp
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr) return nullptr;
        ListNode *fast = pHead;
        ListNode *slow = pHead;
        while(slow->next && fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) {
                //如果有环就用一个指针从头开始追
                ListNode *ptr = pHead;
                while(ptr != slow) {
                    ptr = ptr->next;
                    slow = slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
    }
};
```

### 两个链表的第一个公共结点

输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

题目说明一定有公共节点

- 使用哈希表

一般比较两串数是否相等，都可以想是不能使用哈希表

key -- 节点

value -- 节点值

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_map<ListNode *,int> mp;
        ListNode *p = headA;
        while(p) {
            mp[p] = p->val;
            p = p->next;
        }
        p = headB;
        while(p) {
            if(mp.count(p) == 1) {
                return p;
            }
            p = p->next;
        }
        return p;
    }
};
```

- 双指针

题目说明一定有重复节点，所以 p1 到 第一个链表结尾的时候指向 pHead2 继续，p2 同样 指向 pHead1 继续。

```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode *p1 = pHead1;
        ListNode *p2 = pHead2;
        while(p1 != p2) {
            p1 = p1 != nullptr ? p1->next : pHead2;
            p2 = p2 != nullptr ? p2->next : pHead1;
        }
        return p1;
    }
};
```

### 复杂链表的复制

[剑指offer题目](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

[leetcode题目](https://leetcode-cn.com/problems/copy-list-with-random-pointer/submissions/)

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

- 使用 哈希表

先把所有节点存在哈希表中 ，next 和 random 才能指向。

```
mp[cur]->next = mp[cur->next];
mp[cur]->random = mp[cur->random];
```

题解：

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr) return nullptr;
        unordered_map<Node*,Node*> mp;
        Node *cur = head;
        while(cur) {
            mp[cur] = new Node(cur->val);
            cur = cur->next;
        }
        cur = head;
        while(cur) {
            mp[cur]->next = mp[cur->next];
            mp[cur]->random = mp[cur->random];
            cur = cur->next;
        }
        return mp[head];
    }
};
```

时间复杂度 O(N)  ： 两轮遍历链表，使用 O(N) 时间。

空间复杂度 O(N) ： 哈希表 dic 使用线性大小的额外空间。

- **拼接，拆分**

1. 复制各节点，并构建拼接链表

2. 构建各新节点的 random 指向

3. 拆分两链表，需要断开前面的节点

最后断开最后一个节点的前面指针

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr) return nullptr;
        Node *cur = head;
        //1. 复制各节点，并构建拼接链表
        while(cur) {
            Node *temp = new Node(cur->val);
            temp->next = cur->next;
            cur->next = temp;
            cur = temp->next;
        }
        //2. 构建各新节点的 random 指向
        cur = head;
        while(cur) {
            if(cur->random != nullptr)
                cur->next->random = cur->random->next;
            cur = cur->next->next; //一定是双倍的，所以不存会在cur->next为空
        }
        // 3. 拆分两链表，需要断开前面的节点
        cur = head->next;
        Node* pre = head,*myhead = cur;
        while(cur->next) {
            pre->next = pre->next->next;
            cur->next = cur->next->next;
            cur = cur->next;
            pre = pre->next;
        }
        pre->next = nullptr;  //记得断开最后一个节点的前面指针
        return myhead;
    }
};
```
时间复杂度 O(N) ： 三轮遍历链表，使用 O(N) 时间。

空间复杂度 O(1) ： 节点引用变量使用常数大小的额外空间。

### 合并两个排序的链表

[剑指offer](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

[leetcode题目](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/submissions/)

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

示例1
```
输入：
{1,3,5},{2,4,6}

返回值：
{1,2,3,4,5,6}
```

题解：用一个新的链表来接

```cpp
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode *res = new ListNode{-1};
        ListNode *temp = res;
        ListNode *p1 = pHead1,*p2 = pHead2;
        while(p1 && p2) {
            if(p1->val < p2->val) {
                temp->next = p1;
                temp = temp->next;
                p1 = p1->next;
            }
            else {
                temp->next = p2;
                temp = temp->next;
                p2 = p2->next;
            }
        }
        if(p1) {
            temp->next = p1;
        }
        if(p2) {
            temp->next = p2;
        }
        return res->next;
    }
};
```

时间复杂度 O(M+N)

空间复杂度 O(1)

### 链表中倒数第k个结点(团灭3题)

输入一个链表，输出该链表中倒数第k个结点。

如果该链表长度小于k，请返回空。

```
输入：
{1,2,3,4,5},1 

返回值：
{5}
```


思路：

用两个指针，第一个指针先走到第 k 个节点，然后第二个指针才开始走，等第一个指针走到结尾的时候，第二个指针正好是倒数第 k 个。

```cpp
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        ListNode *right = pHead;
        ListNode *left = pHead;
        //先让快指针走到第k位置
        for(int i=1;i<=k;++i) {
            if(right) {
                right = right->next;
            }
            //如果没走到已经空了说明长度小于k
            else {
                return NULL;
            }
        }
        //这时候慢指针开始走
        while(right) {
            left = left->next;
            right = right->next;
        }
        
        return left;
    }
};
```

#### 19. 删除链表的倒数第 N 个结点

[leetcode题目](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```


用两个指针，第一个指针先走到第 k 个节点，然后第二个指针才开始走，等第一个指针走到结尾的时候，第二个指针正好是倒数第 k 个。

这里需要用一个 pre 指针保存第二个指针的前一个节点，以便删除 left

注意要考虑删除删除的可能是 head，这时候 left 还是等于 head，直接返回 `head->next` 即可

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *right = head;
        ListNode *left = head;
        //先让快指针走到第k位置
        for(int i=1;i<=n;++i) {
            if(right) {
                right = right->next;
            }
            //如果没走到已经空了说明长度小于k
            else {
                return NULL;
            }
        }
        //这时候慢指针开始走
        ListNode *pre;
        while(right) {
            pre = left;
            left = left->next;
            right = right->next;
        }
        //可能删除的就是头结点
        if(left == head) {
            return head->next;
        }
        else {
            pre->next = left->next;
            return head;
        }
    }
};
```

#### 面试题 02.02. 返回倒数第 k 个节点

[leetcode题目](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

这题和上面「链表中倒数第k个结点」相同。只是这题返回的是第 k 个节点位置的值

```cpp
class Solution {
public:
    int kthToLast(ListNode* head, int k) {
        if(head == NULL) return -1;
        ListNode *left = head;
        ListNode *right = head;
        for(int i=1;i<=k;++i) {
            //题目说保证k一定有效，所以不会越界
            right = right->next;
        }
        while(right) {
            left = left->next;
            right = right->next;
        }
        return left->val;
    }
};
```

### 剑指 Offer 18. 删除链表的节点


[leetcode题目](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:
```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```
遍历找到就删除，需要一个 pre 记录前一个节点

```cpp
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if(head == NULL) return head;
        if(head->val == val) return head->next;
        ListNode* p = head;
        ListNode* pre;
        while(p) {
            //走到这里已经不可能删除头结点了
            if(p->val == val) {
                pre->next = p->next;
                break;
            }
            //这个必须写在这里
            pre = p;
            p = p->next;
        }
        return head;
    }
};
```

#### 237. 删除链表中的节点

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。

```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

这题值传入一个删除的节点，只能用值替换法

```cpp
class Solution {
public:
    void deleteNode(ListNode* node) {
        // swap(node->val,node->next->val);
        //因为要删除，可以不考虑交换
        node->val = node->next->val;
        node->next = node->next->next;
        
    }
};
```

### 反转链表

[剑指offer题目](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

- 尾插法

先让一个节点指向 head，然后把 head 指向空，循环的时候需要一个指针 q 记录 `p->next`

```cpp
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode *p = pHead;
        ListNode *q;
        pHead = nullptr;
        while(p) {
            q = p->next;
            p->next = pHead;
            pHead = p;
            p = q;
        }
        return pHead;
     }
};
```

- 递归法（逻辑不好理解，得多看）

递归终止条件：有一个节点或者节点为空

用一个新的头结点接受递归返回

然后让 `head->next->next = head`

把 head 指向空，返回 newHead

```cpp
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr ) return pHead;
        ListNode *newHead = ReverseList(pHead->next);
        pHead->next->next = pHead;
        pHead->next = nullptr;
        return newHead;
    }
};
```

### 25. K 个一组翻转链表

[题目来源](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

进阶：

你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

```
head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

需要设置一个虚拟头结点

具体见图

- 初始化指针，并将 start 移动到要翻转的最后一个节点

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-01.1y03qeggrlmo.png)

- 将翻转的为节点下一个指向空，并让 start 移动到要翻转的开始位置，准备翻转链表

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-02.5djbua117m80.png)

- 开始进行翻转,具体逻辑见代码吧

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-03.4p0snogncw40.png)

- 移动指针，准备下一轮翻转

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/25-04.6mirl8yjtdk0.png)

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        //如果没有节点，或者只有一个节点，或者k==1,直接返回head
        if(head == nullptr || head->next == nullptr || k == 1) return head;
        // 定义一个虚拟头结点，（很多链表题都可以这么做）
        ListNode *dumpy = new ListNode(-1);
        dumpy->next = head;
        // pre指向头结点的前一个，start从head开始
        ListNode *pre = dumpy,*start = head;
        ListNode *last,*temp;  //last记录翻转最后一个节点的后一个，也就是下一组的第一个，temp记录翻转前的第一个，用来拼接用
        while(start) {
            //将start移动至翻转的最后一个节点，比如说k=3,start本来就在头结点了，只移动 1，2次就可以
            for(int i=1;i<k && start!=nullptr;++i) {
                start = start->next;
            }
            //如果start到最后了就结束了
            if(start == nullptr) break;

            //记录下一组的第一个
            last = start->next;
            //将当前翻转的后一个指向空，以便后面循环判断
            start->next = nullptr;

            start = pre->next;
            temp = start; //记录要拼接的节点
            while(start) {
                ListNode *cur = start;
                start = start->next;
                cur->next = last;
                last = cur;
            }
            //join
            pre->next = last;
            //移动start 和 pre 准备下一轮翻转
            pre = temp;
            start = pre->next;
        }
        return dumpy->next;
    }
};
```

#### 24. 两两交换链表中的节点

[题目来源]https://leetcode-cn.com/problems/swap-nodes-in-pairs/

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

```
head = [1,2,3,4]
输出：[2,1,4,3]
```

题解：

直接借鉴上面的方法，将 k 改为 2

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *dumpy = new ListNode(-1);
        dumpy->next = head;
        ListNode *pre = dumpy;
        ListNode* start = head;
        ListNode *last,*temp;
        while(start) {
            // for(int i=1;i<2 && start != nullptr;++i) {
            //     start = start->next;
            // }
            // 因为k=2，可以直接写
            start = start->next;

            if(start == nullptr) break;

            last = start->next;
            start->next = nullptr;
            //让start指向开头
            start = pre->next;
            temp = start;
            while(start) {
                ListNode *cur = start;
                start = start->next;
                cur->next = last;
                last = cur;
            }
            //先把虚拟节点接上
            pre->next = last;
            pre = temp;
            start = pre->next;
        }
        return dumpy->next;
    }
};
```



### 203. 移除链表元素

[leetocde题目](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

输入：head = [], val = 1
输出：[]
```

设置一个虚拟头结点，然后用一个指针遍历寻找。从新开一个链表拼接

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *dumpy = new ListNode(-1);
        ListNode *cur = dumpy;
        while(head) {
            if(head->val != val) {
                cur->next = head;
                cur = head;
            }
            head = head->next;
        }
        cur->next = nullptr; // 一定要记得让最后一个节点指向空
        return dumpy->next;
    }
};
```

也是设置一个虚拟头结点，不过是直接在原链表上操作

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *dumpy = new ListNode(-1);
        dumpy->next = head;
        ListNode *cur = head,*pre = dumpy;
        while(cur) {
            if(cur->val == val) {
                pre->next = cur->next;
            }
            else {
                pre = pre->next;
            }
            cur = cur->next;
        }
        return dumpy->next;
    }
};
```



------

## 数组相关

### 1. 两数之和

[leetcode题目](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

- 直接暴力用两个循环遍历，看 target - num[i] 有没有在nums 中。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        for(int i=0;i<nums.size();++i) {
            for(int j=i + 1;j<nums.size();++j) {
                if(target - nums[i] == nums[j]) {
                    res.push_back(i);
                    res.push_back(j);
                    return res;
                }
            }
        }
        return res;
    }
};
```

- 使用哈希表来保存，每次先检查 `target-nums[i]` 有没有在哈希表里面，如果有直接返回。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int,int> mp;
        for(int i=0;i<nums.size();++i) {
            auto it = mp.find(target - nums[i]);
            if(it != mp.end() ) {
                return {it->second,i};
            }
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

### 15. 三数之和

[leetcode题目](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 `a + b + c = 0` ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

思路：

排序 + 双指针

先排序，从左到右选一个把柄，从这个把柄开始开始往后找其余两个数

如果这个把柄已经大于零了，后面不用找了，因为是排好序的

记得去重，用后一个和前一个比较的技巧

接着用两个指针，一个为 `startIndex + 1` 一个从后面开始，

根据三个数的和比 0 大还是小移动左右指针。

最后一样去重，先移动左右指针，用后一个和前一个比较的技巧


```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> temp;
        sort(nums.begin(),nums.end());
       for(int startIndex = 0;startIndex<nums.size();++startIndex) {
           //以startIndex 开始往后，找了个和它加起来等于 0
           //如果startIndex 都大于0了，就不用找了，因为是排好序的
           if(nums[startIndex] > 0) {
               break;
           }
           //去重
           //因为题目要求三元组不能重复，所以需要去重，去重用 后面的和前面的比这个技巧
           if(startIndex > 0 && nums[startIndex] == nums[startIndex - 1]) {
               continue;
           }
           //现在开始找后两个数
           int left = startIndex + 1;
           int right = nums.size() - 1;
           while (left < right) {
               int sum = nums[startIndex] + nums[left] + nums[right];
               //左右收缩left 和 right 指针
               if(sum < 0) {
                   ++left;
               }
               else if(sum > 0) {
                   --right;
               }
               //这时候已经相等了，就是要找的值
               else{
                   vector<int> temp;
                   temp.push_back(nums[startIndex]);
                   temp.push_back(nums[left]);
                   temp.push_back(nums[right]);
                   res.push_back(temp);
                   
                   //存完一个之后可能还有下一个，所以继续缩小窗口比较,
                   //因为是后面的一个跟前面的比较，所以要先执行这一步
                   ++left;
                   --right;
                    // 为了防止有重复的出现，所以要不停的缩小
                    while(left < right && nums[left] == nums[left - 1]) ++left;
                    while(left < right && nums[right] == nums[right+1]) --right;
               }
           }
       }
        return res;
    }
};
```

时间复杂度是 $O(n^2)$

空间复杂度 $O(1)$：指针使用常数大小的额外空间。


#### 18. 四数之和

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 `a + b + c + d` 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。

和上一题思路一样，只是多了一层循环


```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        for(int start1 = 0;start1<nums.size();++start1) {
            // 这种剪枝是错误的，这道题目target 是任意值 ,但 target 为负数的时候就不对了
            // if (nums[start1] > target) {
            //     return res;
            // }
            //去重，使用后一个和前一个比较的技巧
            if(start1 > 0 && nums[start1] == nums[start1 - 1]) {
                continue;
            }
            for(int start2 = start1 + 1;start2  < nums.size();++start2) {
                //去重 注意这里不是 0， (start2 > start1 + 1
                if(start2 > start1 + 1 && nums[start2] == nums[start2 - 1]){
                    continue;
                }
                int left = start2 + 1;
                int right = nums.size() - 1;
                while(left < right) {
                    int sum = nums[start1] + nums[start2] + nums[left] + nums[right];
                    if(sum < target) {
                        ++left;
                    }
                    else if(sum > target) {
                        --right;
                    }
                    else{
                        //这就是目标值
                        vector<int> temp;
                        temp = {nums[start1],nums[start2],nums[left],nums[right]};
                        res.push_back(temp);

                        //去重
                        ++left;
                        --right;
                        while(left < right && nums[left] == nums[left - 1]) ++left;
                        while(left < right && nums[right] == nums[right + 1]) --right;
                    }
                }
            }
        }
        return res;
    }
};
```



-------


## 动态规划

动态规划可以解决的问题：

- 字符串匹配
  - [正则表达式匹配](#正则表达式匹配)
- 求最值问题

### 322. 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例 1：
```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

题解：

`dp[i] = x`表示，当目标金额为`i`时，至少需要`x`枚硬币。

base case : 当目标金额为 0 的时候，需要 0 枚硬币

对于目标金额 i，如果取，就是前一个 + 1，不取就直接是 dp[i]

`dp[i] = min(dp[i-coin] + 1,dp[i])`

**注意初始化和返回值**

> PS：为啥dp数组初始化为amount + 1呢，因为凑成amount金额的硬币数最多只可能等于amount（全用 1 元面值的硬币），所以初始化为amount + 1就相当于初始化为正无穷，便于后续取最小值。


```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // dp[i] = x表示，当目标金额为i时，至少需要x枚硬币。
        vector<int> dp(amount + 1,amount + 1);  
        // base case
        dp[0] = 0;
        for(int i=0;i<=amount;++i) {
            for(auto coin : coins) {
                if(i - coin < 0) continue;
                dp[i] = min(dp[i-coin] + 1, dp[i]);
            }
        }
        return dp[amount] == amount + 1 ? -1 : dp[amount] ;
    }
};
```

### 1143. 最长公共子序列(重要)

[题目来源](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```cpp
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 
```

- dp[i][j] 表示长度为`[0, i - 1]`的字符串`text1`与长度为`[0, j - 1]`的字符串`text2`的最长公共子序列为`dp[i][j]`

- 主要就是两大情况： `text1[i - 1]` 与 `text2[j - 1]`相同，`text1[i - 1]` 与 `text2[j - 1]`不相同

    - 如果`text1[i - 1]` 与 `text2[j - 1]`相同，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1`;

    - 如果`text1[i - 1]` 与 `text2[j - 1]`不相同，那就看看`text1[0, i - 2]`与`text2[0, j - 1]`的最长公共子序列 和 `text1[0, i - 1]`与`text2[0, j - 2]`的最长公共子序列，取最大的。

- base case: 
  - dp[i][0] = 0: text2 为空，当然是 0
  - dp[0][j] = 0; text1 为空，当然是 0
  - 所以直接初始化全为 0 就可以啦

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.size(),len2 = text2.size();
        vector<vector<int>> dp(len1+1,vector<int> (len2+1,0));
        //base case 上一步已经完成了

        // 状态转移
        for(int i=1;i<=len1;++i) {
            for(int j=1;j<=len2;++j) {
                // 相同
                if(text1[i-1] == text2[j-1]) { //注意这里是 -1
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                //不同:那就看看text1[0, i - 1]与text2[0, j - 1]的最长公共子序列 
                //和 text1[0, i - 1]与text2[1, j - 1]的最长公共子序列，取最大的。
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[len1][len2];
    }
};
```


### 72. 编辑距离(多看)

[题目来源](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符
 
```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```


[参考题解](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=3&sn=aa642cbf670feee73e20428775dff0b5&chksm=9bd7fb33aca0722568ab71ead8d23e3a9422515800f0587ff7c6ef93ad45b91b9e9920d8728e&scene=21#wechat_redirect)

**解决两个字符串的动态规划问题，一般都是用两个指针i,j分别指向两个字符串的最前，然后一步步往后走，扩大问题的规模**。


`dp[i][j]` 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数

**base case**：

需要考虑 word1 或 word2 一个字母都没有，即全增加/删除的情况，所以预留 `dp[0][j]` 和 `dp[i][0]`

`dp[0][j] = j` 和 `dp[i][0] = i`


如果相同，就等于前一个操作的距离，啥都不做：`dp[i][j] = dp[i-1][j-1]`

如果不同，
- 三选一取编辑距离最小的
    - 插入（insert）：`dp[i][j] = dp[i][j-1] + 1`
    - 删除（delete）：`dp[i][j] = dp[i-1][j] + 1` 
    - 替换（replace）：`dp[i][j] = dp[i-1][j-1] + 1` 
    - 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size(),len2 = word2.size();
        //dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数
        vector<vector<int>> dp(len1+1,vector<int> (len2+1,0));
        //base case
        for(int i=1;i<=len1;++i) {
            dp[i][0] = i;
        }
        for(int j=1;j<=len2;++j) {
            dp[0][j] = j;
        }
        //状态转移
        for(int i=1;i<=len1;++i) {
            for(int j=1;j<=len2;++j) {
                //相同，啥也不做
                if(word1[i-1] == word2[j-1]) {  //注意这里是 -1
                    dp[i][j] = dp[i-1][j-1];
                }
                //不同，插入，删除，替换
                else {
                    dp[i][j] = min ( dp[i][j-1] + 1,  //插入
                                    min(dp[i-1][j] + 1,    //删除
                                        dp[i-1][j-1] + 1)  //替换
                                    );
                }
            }
        }
        return dp[len1][len2];
    }
};
```


### 股票问题

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1：

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

题解：

这道题的状态有三个：

- 天数
- 当天允许交易的最大次数
- 当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）

> dp -- 最大利润

比如说 `dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 `dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。

天数：0 <= i <= n-1

最大交易次数：k

持有状态：0 / 1

我们想求的最终答案是 `dp[n - 1][K][0]`，即最后一天，最多允许 K 次交易，所能获取的最大利润。读者可能问为什么不是 `dp[n - 1][K][1]`？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

我们的选择是 buy, sell, rest，而这些选择是和「持有状态」相关的，所以只看「持有状态」

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/188-01.4yiyi51d2w80.jpeg)

通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：

```
dp[i][k][0] = max( dp[i-1][k][0] + dp[i-1][k-1][1] + prices[i] )
              max(      选择 rest      选择 sell  )

今天没有持有股票，有两种可能：
1.昨天就没有持有，今天选择误操作 rest ,所以今天也是不持有
2.昨天持有，今天卖出了，所以不持有了，价值也增加了


dp[i][k][1] = max( dp[i-1][k][1] + dp[i-1][k-1][0] - prices[i] )
              max(      选择 rest      选择 buy  )
今天持有，有两种可能：
1.昨天就持有了，今天无操作，所以今天依然持有
2.昨天没有持有，今天买入了，今天就持有了，价值也减少了
```

**而且注意 k 的限制，我们在选择 buy 的时候，把最大交易数 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的**

现在，我们已经完成了动态规划中最困难的一步：**状态转移方程**

接下来就是初始化，就是**定义 base case**

```
dp[-1][k][0] = 0
天数从0开始的，-1意味着还没开始，所以这时候的利润也是0

dp[-1][k][1] = -INT_MAX
还没开始，是不可能有股票的，所以只能为负无穷


第 i 天

dp[i][0][0] = 0
第 i 天，k = 0,然后一次都不能交易，固然利润也是0

dp[i][0][1] = - INT_MAX
第 i 天，一次都不能交易，是不可能持有的，因此只能是负无穷
```

**开始解题**：

#### 121. 买卖股票的最佳时机

第一题，当 k = 1

[题目来源](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

直接套状态转移方程，根据 base case，可以做一些化简：

```cpp
//今天不持有  无操作或者卖出
dp[i][1][0] = max( dp[i-1][1][0], dp[i-1][1][1] + prices[i] )

//今天持有  无操作或者买入
dp[i][1][1] = max( dp[[i-1][1][1], dp[i-1][1][0] - prices[i] ) 

//k = 0 的 base bace，dp[i-1][0][0] = 0
//第 i 天，k = 0,然后一次都不能交易，固然利润也是0

// 现在 k =1,所以k并不会影响状态转移方程
dp[i][0] = max( dp[i-1][0], dp[i-1][1] + prices[i] )
dp[i][1] = max( dp[i-1][1], -prices[i] )
```

转化成代码：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size() ;  //天数
        // base bace
        vector<vector<int>> dp(n,vector<int>(2));
        for(int i=0;i<n;++i) {
            if(i-1 < 0) {
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                //    dp[i][1] = max( dp[-1][1], dp[-1][0] - prices[i] )
                //  = dp[i][1] = max( -INT_MAX, 0-prices[i] )  
                //  = -prices[i]
                continue;

            }
            //今天不持有
            dp[i][0] = max( dp[i-1][0], dp[i-1][1] + prices[i] );
            //今天持有，卖出了，说明一次交易完成，k-1,所以dp[i-1][k-1][0] = dp[i-1][0][0] = 0
            dp[i][1] = max( dp[i-1][1], -prices[i] );
        }
        return dp[n-1][0];
    }
};
```

第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要两个变量储存所需的状态就足够了，这样可以把空间复杂度降到 $O(1)$:

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size() ;  //天数
        // base bace
        // vector<vector<int>> dp(n,vector<int>(2));
        int dp_i_1 = INT_MIN,dp_i_0 = 0;
        for(int i=0;i<n;++i) {

            //今天不持有
            dp_i_0 = max(dp_i_0,dp_i_1 + prices[i]);
            //今天持有
            dp_i_1 = max(dp_i_1 , -prices[i]);

        }
        return dp_i_0;
    }
};
```

#### 122.买卖股票的最佳时机 II

[题目来源](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**这题 k 为正无穷**，可以进行无穷次交易。

那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：

```
dp[i][k][0] = max( dp[i-1][k][0] + dp[i-1][k-1][1] + prices[i] )
              max(      选择 rest      选择 sell  )

dp[i][k][1] = max( dp[i-1][k][1] + dp[i-1][k-1][0] - prices[i] )
              max(      选择 rest      选择 buy  )

我们可以看出 k 已经不会变了，所以 k 不会影响状态转移方程

dp[i][0] = max( dp[i-1][0] + dp[i-1][1] + prices[i] )

dp[i][1] = max( dp[i-1][1] + dp[i-1][0] - prices[i] )
```

题解：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int day = prices.size();
        vector<vector<int>> dp(day, vector<int>(2));
        for(int i=0;i<day;++i) {
            if(i-1 < 0) {
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }

            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[day-1][0];
    }
};
```

维护两个数即可

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int day = prices.size();
        int dp_i_0 = 0, dp_i_1 = INT_MIN;
        for(int i=0;i<day;++i) {
            int temp = dp_i_0;
            dp_i_0 = max(dp_i_0,dp_i_1 + prices[i]);
            dp_i_1 = max(dp_i_1,temp - prices[i]);
        }
        return dp_i_0;
    }
};
```

#### 123.买卖股票的最佳时机 III

[题目来源](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**这题 k = 2**

```
原始的状态转移，没有化简的地方
dp[i][k][0] = max( dp[i-1][k][0] + dp[i-1][k-1][1] + prices[i] )
              max(      选择 rest      选择 sell  )

dp[i][k][1] = max( dp[i-1][k][1] + dp[i-1][k-1][0] - prices[i] )
              max(      选择 rest      选择 buy  )
```

按照之前的代码，我们可能想当然这样写代码（错误的）

```cpp
int maxProfit(vector<int>& prices) {
    int day = prices.size();
    vector<vector<vector>>> dp(day,vector<vector>>(k+1,vector<int>(2)));
    for(int i=0;i<day;++i) {
        if(i-1<0) { /* 处理base case */}
        dp[i][k][0] = max( dp[i][k][0],  dp[i][k][1] + prices[i] );
        dp[i][k][1] = max( dp[i][k][1],  dp[i][k-1][0] - prices[i] );
    }
    return dp[day][k][0];
}
```

为什么错误？我这不是照着状态转移方程写的吗？

还记得前面总结的「穷举框架」吗？就在强调必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了，所以没有对 k 的穷举。比如说第一题，k = 1：

```cpp
for(int i=0;i<day;++i)  //穷举天数

//穷举持有状态
dp[i][0]
dp[i][1]
```

这道题由于没有消掉 k 的影响，所以必须要用 for 循环对 k 进行穷举才是正确的：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int day = prices.size();
        int max_k = 2;
        vector< vector< vector<int> > > dp(day,vector< vector<int> >(max_k + 1,vector<int>(2)));
        for(int i=0;i<day;++i) {
            for(int k=max_k;k>0;--k) {
                if(i-1<0) { 
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = max( dp[i-1][k][0],  dp[i-1][k][1] + prices[i] );
                dp[i][k][1] = max( dp[i-1][k][1],  dp[i-1][k-1][0] - prices[i] );
            }

        }
        return dp[day-1][max_k][0];
    }
};
```

第二种解法：因为这里 k 取值范围比较小，所以也可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也是一样的。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int day = prices.size();
        int dp_i10 = 0,dp_i11 = INT_MIN;
        int dp_i20 = 0,dp_i21 = INT_MIN;
        for(int i=0;i<day;++i) {
            dp_i20 = max(dp_i20,dp_i21 + prices[i]);
            dp_i21 = max(dp_i21,dp_i10 - prices[i]);  //k-1
            dp_i10 = max(dp_i10,dp_i11 + prices[i]);
            dp_i11 = max(dp_i11,- prices[i]);  //k-1
        }
        return dp_i20;
    }
};
```

#### 188.买卖股票的最佳时机 IV

[题目来源](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 
示例 1：

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**k 是任意数**

思路：

一次交易由买入和卖出构成，至少需要两天。所以说有效的限制次数 k 应该不超过 `day/2`，如果超过，就没有约束作用了，相当于 `k = +infinity`。这种情况是之前解决过的

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int day = prices.size();
        //相当于k是正无穷
        if(k > day / 2) {
            return maxProfit_k_inf(prices);
        }
        vector<vector<vector<int>>> dp(day,vector<vector<int>> (k+1,vector<int>(2)));
        for(int i=0;i<day;++i) {
            for(int ki = k;ki>0;--ki ) {
                if(i-1<0) {
                    dp[i][ki][0] = 0;
                    dp[i][ki][1] = -prices[i];
                    continue;
                }
                dp[i][ki][0] = max(dp[i-1][ki][0],dp[i-1][ki][1] + prices[i]);
                dp[i][ki][1] = max(dp[i-1][ki][1],dp[i-1][ki-1][0] - prices[i]);
            }
        }
        return dp[day-1][k][0];
    }

    int maxProfit_k_inf(const vector<int> &prices) {
        int day = prices.size();
        int dp_i_0 = 0,dp_i_1 = INT_MIN;
        for(int i=0;i<day;++i) {
            int temp = dp_i_0;
            dp_i_0 = max(dp_i_0,dp_i_1 + prices[i]);
            dp_i_1 = max( dp_i_1, temp - prices[i] );
        }
        return dp_i_0;
    }
};
```

#### 309. 最佳买卖股票时机含冷冻期

[题目来源](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**K 无穷次，并且有冷冻期**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int day = prices.size();
        if(day <= 1) return 0;
        int dp_i_0 = 0,dp_i_1 = INT_MIN;
        int dp_pre_0 = 0;
        for(int i=0;i<day;++i) {
            int temp = dp_i_0;
            dp_i_0 = max( dp_i_0,dp_i_1 + prices[i] );
            dp_i_1 = max( dp_i_1,dp_pre_0 - prices[i] );
            dp_pre_0 = temp;
        }
        return dp_i_0;
    }
};
```

#### 714. 买卖股票的最佳时机含手续费

[题目来源](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

示例 1:

```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**k 无穷次，并且有手续费**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int day = prices.size();
        if(day <= 1) return 0;
        int dp_i_0 = 0,dp_i_1 = INT_MIN;
        for(int i=0;i<day;++i) {
            int temp = dp_i_0;
            dp_i_0 = max( dp_i_0, dp_i_1 + prices[i] );
            //这里还需要支付手续费
            dp_i_1 = max( dp_i_1,temp - prices[i] - fee );
        }
        return dp_i_0;
    }
};
```

------

### 打家劫舍系列问题

#### 198. 打家劫舍

[题目来源](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

[我写的题解](https://leetcode-cn.com/problems/house-robber/solution/lian-wo-du-neng-kan-dong-de-dong-tai-gui-k9rt/?)

示例 1：
```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

- 使用动态数组 dp

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        vector<vector<int>> dp(nums.size() + 1,vector<int>(2));
        //0代表0号房间，并不是1号房间
        dp[0][0] = 0;
        dp[0][1] = INT_MIN;
        for(int i=1;i<=nums.size();++i) {
            dp[i][0] = max( dp[i-1][1],dp[i-1][0] );
            dp[i][1] = dp[i-1][0] + nums[i-1];  //num是从0开始的
        }

        return max(dp[nums.size() ][0],dp[nums.size()][1]);
    }
};
```

时间复杂度是：O(n)

空间复杂度是：O(2n)

- 维护两个数

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];

        int dp_i_0 = 0;
        int dp_i_1 = INT_MIN;
        for(int i=1;i<=nums.size();++i) {
            int temp = dp_i_0; 
            dp_i_0 = max( dp_i_1,dp_i_0 );
            dp_i_1 = temp + nums[i-1];  //num是从0开始的
        }

        return max(dp_i_0,dp_i_1);
    }
};
```

时间复杂度是：O(n)

空间复杂度是：O(1)

- [参考`labuladong`的解法](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484800&idx=1&sn=1016975b9e8df0b8f6df996a5fded0af&chksm=9bd7fb88aca0729eb2d450cca8111abd8f861236b04125ce556171cb520e298ddec4d90823b3&scene=21#wechat_redirect)

使用动态规划函数来做，取 偷 和 不偷 的最大值


```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        return dp(nums,0);
    }
    int dp(vector<int> &nums,int start) {
        if(start >= nums.size()) {
            return 0;
        }
        // 偷或者不偷的最大值
        int ret = max( 
            dp(nums,start+1),  //不偷，去下家
            nums[start] + dp(nums,start+2)  //偷，去下下家，下家肯定不能再偷了
            );
        return ret;
    }
};
```

有重叠子问题，超时

使用哈希表来做备忘录，当然也可以使用数组。

```cpp
class Solution {
public:
    unordered_map<int,int> mp;

    int rob(vector<int>& nums) {
        return dp(nums,0);
    }
    int dp(vector<int> &nums,int start) {
        if(start >= nums.size()) {
            return 0;
        }

        //消除重叠子问题
        if(mp.find( start ) != mp.end() ) return mp[start];
        // 偷或者不偷的最大值
        int ret = max( 
            dp(nums,start+1),  //不偷，去下家
            nums[start] + dp(nums,start+2)  //偷，去下下家，下家肯定不能再偷了
            );
        
        //记入备忘录
        mp[start] = ret;
        return ret;
    }
};
```

#### 213. 打家劫舍 II

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/213.3nts842w34o0.png)

但是情况一明显取到的钱比情况二和三少。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max( nums[0],nums[1] );

        int dp_i_0 = 0;
        int dp_i_1 = INT_MIN;

        int dp_j_0 = 0;
        int dp_j_1 = INT_MIN;

        for(int i=0,j=1;i<nums.size() - 1 && j < nums.size();++i,++j) {

            // 算的是第一种情况
            int temp = dp_i_0; 
            dp_i_0 = max( dp_i_1,dp_i_0 );
            dp_i_1 = temp + nums[i];  //num是从0开始的

            //算的是第二种情况
            int temp1 = dp_j_0; 
            dp_j_0 = max( dp_j_1,dp_j_0 );
            dp_j_1 = temp1 + nums[j];  //num是从0开始的
        }
        return max(max(dp_i_0,dp_i_1),max(dp_j_0,dp_j_1));
    }
};
```





### 正则表达式匹配

[题目来源](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)


------

## 其他

### 设计LRU缓存结构

[题目来源]()

设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能
set(key, value)：将记录(key, value)插入该结构
get(key)：返回key对应的value值

[要求]

set和get方法的时间复杂度为`O(1)`

某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。

当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。

若`opt=1`，接下来两个整数`x`, `y`，表示`set(x, y)`

若`opt=2`，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回`-1`
对于每个操作`2`，输出一个答案

```
输入：
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3
复制
返回值：
[1,-1]
```

```cpp
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        cap = k;
        vector<int> ans;
        for(auto &num : operators) {
            if(num[0] == 1) {
                set(num[1],num[2]);
            }
            else {
                ans.push_back(get(num[1]));
            }
        }
        return ans;
    }
    //插入
    //首先查找，如果有就删除，然后不管有没有都在队头插入
    void set(int key,int value) {
        auto it = mp.find(key);
        if(it != mp.end()) { //如果有，就删除
            cache.erase(it->second);
            mp.erase(key);
        }
        // 然后再插入队头
         pair<int, int> n(key,value);
        cache.push_front(n);
        mp.emplace(key,cache.begin());
        
        //如果缓冲区满了，就要删除对尾节点
        if(cap < cache.size()) {
            //哈希表删除
            mp.erase(cache.back().first);
            cache.pop_back();
        }
    }
    //获取
    //先查找哈希表，如果没有就结束，有就复制到头部，再删除原有位置元素
    int get(int key) {
        auto it = mp.find(key);
        if(it == mp.end() ) { //如果没有，就结束
            return -1;
        }
        //如果有
        //删除原有的，插入前面
        auto target_it = it->second;
        pair<int, int> n(key,target_it->second);
        cache.push_front(n);
        // 删除
        cache.erase(target_it);
        mp.erase(key);
        mp.emplace(key,cache.begin());
        
        return n.second;
    }
private:
    int cap;
    list<pair<int,int>> cache;
    unordered_map<int,list<pair<int, int>>::iterator> mp;
};
```

## 位运算相关

### 136. 只出现一次的数字

[题目来源](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
```
输入: [2,2,1]
输出: 1
```

- 第一种思路：使用 unordered_set 哈希集

> 这种方法效率很低，用于学习使用 unordered_set

> unordered_set 无序集是没有特定顺序存储唯一元素的容器，**不允许有重复值**。set 是有序容器

> `unordered_set` 不能用来保存`pair<int, int>`，但是 set 可以。因为`unordered_set`是基于哈希的，而 C++ 并没有给`pair`事先写好哈希方法。`set`是基于比较的树结构，所以`pair`里的数据结构只要都支持比较就能储存。 

提供的方法：

```cpp
unordered_set::insert
unordered_set::find
unordered_set::erase
unordered_set::count
```
`count()`: 在容器中搜索值为k的元素，并返回找到的元素个数。因为unordered_set容器不允许重复的值，这意味着如果容器中存在具有该值的元素，该函数实际上返回1，否则返回0。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> st;
        int ans;
        for(auto num : nums) {
            //count(): 在容器中搜索值为k的元素，并返回找到的元素个数。因为unordered_set容器不允许重复的值，这意味着如果容器中存在具有该值的元素，该函数实际上返回1，否则返回0。
            if(st.count(num) == 1) //存在
            {
                st.erase(num);
            }
            else {  //不存在
                st.insert(num);
            }
        }
        //最后剩下的就是不重复的数字,这里实际上只剩下一个元素了
        for(auto t : st) {
            ans =  t;
        }
        return ans;
    }
};
```

- 第二种思路：使用双指针，先排序后查找前后是否相等，注意最后如果在循环中没有找到，考虑总数是单数的原因返回最后一个数。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        sort(nums.begin(),nums.end());
        for(int i=0,j=1;j<nums.size();i+=2,j+=2) {
            if(nums[i] != nums[j]) {
                return nums[i];
            }
        }
        //如果nums个数是单数
        return nums[nums.size()  -1];
    }
};
```

- **位运算**

注意是换成二进制算

```
1 ⊕ 1 = 0

0 ⊕ 0 = 0

1 ⊕ 0 = 1

0 ⊕ 1 = 1

a ^ a = 0
0 ^ a = a
```

> 相同为 0，不同为 1

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans =0;
        for(int num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```

### 137. 只出现一次的数字 II

[题目来源](https://leetcode-cn.com/problems/single-number-ii/)

- 不会做












