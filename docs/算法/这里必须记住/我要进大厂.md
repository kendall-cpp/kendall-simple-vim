
- [面试写树的算法写不出我就是大猪蹄子](#面试写树的算法写不出我就是大猪蹄子)
  - [重建二叉树](#重建二叉树)
    - [知道后序中序重建二叉树](#知道后序中序重建二叉树)
    - [知道前序中序重建二叉树](#知道前序中序重建二叉树)
  - [二叉搜索树的第k个结点](#二叉搜索树的第k个结点)


-------

## 面试写树的算法写不出我就是大猪蹄子

### 重建二叉树

[可以参考这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484950&idx=1&sn=3900f9433d36dd5406fc1ccb1df07703&scene=21#wechat_redirect)

#### 知道后序中序重建二叉树

[leetcode题目](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

首先判断遍历是否为空，如果为空直接返回 NULL

接着找到后序遍历的最后一个节点，创建并放在 root 节点中，判断如果只有一个节点就直接返回 root

在中序遍历中找到后序遍历最后一个元素的位置 mid

然后开始截取，先截取中序遍历，在 mid 位置处；

后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。所以要删掉先。

再截取后续遍历，在 `leftInorder.size()` 位置处

最后递归建左子树和右子树。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //判断节点是否为空
        if(inorder.size() == 0) {
            return nullptr;
        }
        //取出后序遍历最后一个节点，就是头结点
        int val = postorder[postorder.size() - 1];
        // 建立根节点
        TreeNode* root = new TreeNode(val);
        //如果只有一节点的话，就直接返回根节点
        if(postorder.size() == 1) return root;

        int mid ;
        //找出后序遍历最后的节点在中序遍历的位置
        for(int i=0;i<inorder.size();++i) {
            if(inorder[i] == root->val){
                mid = i;
                break;
            }
        }

        //先切割中序，再切割后序

        // 中序遍历，不要当前节点了
        // [9,3,15,20,7]   截取 9
        vector<int> leftInotder(inorder.begin(),inorder.begin() + mid); //mid = 1
        //注意这里不要已经遍历的节点了
        vector<int> rightInorder(inorder.begin() + mid + 1, inorder.end());

        //舍去没元素
        postorder.resize(postorder.size() - 1); //设置大小（size）,如果超过就删除后面的

        //后序遍历

        //[9,15,7,20]    9   （3已经被删除了）
        vector<int> leftPostorder (postorder.begin(),postorder.begin() + leftInotder.size());
        // 15,7,20  （3已经被删除了）
        vector<int> rightPostorder (postorder.begin() + leftInotder.size(),postorder.end());

        //递归建树
        root->left = buildTree(leftInotder,leftPostorder);
        root->right = buildTree(rightInorder,rightPostorder);

        return root;
    }
};
```

测试`vector`复制

```cpp
int main() {
    vector<int> temp = {1,2,3};
    vector<int> vec1 = {1,2,3,4,5};
    vector<int> vec2 (vec1.begin(),vec1.begin() + temp.size());
    vector<int> vec3 (vec1.begin() + temp.size(),vec1.end());

    vector<int>::iterator it = vec2.begin();
    for(;it!=vec2.end();++it) {
        cout << *it << " ";  //1,2,3,   也就是[1,2,3,4)    
    }
    cout << endl;
    vector<int>::iterator it3 = vec3.begin();
    for(;it3!=vec3.end();++it3) {
        cout << *it3 << " ";  //4,5    
    }
    cout << endl;
}
```

#### 知道前序中序重建二叉树

[剑指offer题目](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

思想和上一题一样

就是先找前序遍历在中序遍历中的位置，然后再切割。

最后递建 左右子树

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        //判断遍历是否为空
       if(pre.size() == 0) return NULL;
        
        //找到前序遍历第一个元素
        int val = pre[0];
        TreeNode* root = new TreeNode(val);
        // 如果只有一个元素，那么就是只有一个节点，直接返回root
        if(pre.size() == 1) return root;
        
        //找前序遍历第一个元素在中序遍历中的位置
        int mid = 0;
        for(;mid < vin.size();++mid) {
            if(vin[mid] == val) break;
        }
        
        //开始切割
        
        //中序遍历,不要正在遍历的节点
        vector<int> leftVin(vin.begin(),vin.begin() + mid);
        vector<int> rightVin(vin.begin() + mid + 1,vin.end());
        
        //删除前序遍历第一个节点
        pre.erase(pre.begin());
        
        //前序遍历
        vector<int> leftPre (pre.begin(),pre.begin() + leftVin.size());
        vector<int> rightPre (pre.begin() + leftVin.size(),pre.end());
        
        root->left = reConstructBinaryTree(leftPre, leftVin);
        root->right = reConstructBinaryTree(rightPre, rightVin);
        
        return root;
        
    }
};
```

### 二叉搜索树的第k个结点

[剑指offer题目](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一棵二叉搜索树，请找出其中第k大的节点。

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

使用中序遍历，然后用一个数组保存

记住最后要判断 k 是否超过数组的长度

- 递归法

```cpp
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        if(pRoot==NULL||k<=0) return NULL;
        vector<TreeNode*> vec;
        midTraver(pRoot,vec);
        if(k > vec.size()) {
            return NULL;  //一定要判断是否越界
        }
        return vec[k-1];
    }
   void midTraver(TreeNode* pRoot,vector<TreeNode*> &vec) {
       if(pRoot == nullptr) return;
       if(pRoot->left) midTraver(pRoot->left, vec);
       vec.push_back(pRoot);
       if(pRoot->right) midTraver(pRoot->right, vec);
   }
    
};
```


