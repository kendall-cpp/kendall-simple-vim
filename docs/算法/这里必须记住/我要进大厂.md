
- [面试写树的算法写不出我就是大猪蹄子](#面试写树的算法写不出我就是大猪蹄子)
  - [重建二叉树](#重建二叉树)
    - [知道后序中序重建二叉树](#知道后序中序重建二叉树)
    - [知道前序中序重建二叉树](#知道前序中序重建二叉树)
  - [二叉搜索树的第k个结点](#二叉搜索树的第k个结点)
  - [二叉树的镜像](#二叉树的镜像)
  - [从上往下打印二叉树](#从上往下打印二叉树)
    - [剑指 Offer 32 - II. 从上到下打印二叉树 II](#剑指-offer-32---ii-从上到下打印二叉树-ii)
    - [按之字形顺序打印二叉树](#按之字形顺序打印二叉树)
  - [二叉搜索树的后序遍历序列](#二叉搜索树的后序遍历序列)
  - [二叉树中和为某一值的路径](#二叉树中和为某一值的路径)
  - [112. 路径总和](#112-路径总和)
  - [二叉树的深度](#二叉树的深度)
  - [对称的二叉树](#对称的二叉树)
  - [101. 对称二叉树](#101-对称二叉树)
- [链表相关](#链表相关)
  - [面试题 02.01. 移除重复节点-链表去重](#面试题-0201-移除重复节点-链表去重)
  - [82. 删除排序链表中的重复元素 II](#82-删除排序链表中的重复元素-ii)
  - [删除链表中重复的结点](#删除链表中重复的结点)
  - [两个链表的第一个公共结点](#两个链表的第一个公共结点)
- [其他](#其他)
  - [设计LRU缓存结构](#设计lru缓存结构)
- [位运算相关](#位运算相关)
  - [136. 只出现一次的数字](#136-只出现一次的数字)
  - [137. 只出现一次的数字 II](#137-只出现一次的数字-ii)


-------

## 面试写树的算法写不出我就是大猪蹄子

> 关于二叉树问题，用递归法能解决大部分问题

### 重建二叉树

[可以参考这里](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484950&idx=1&sn=3900f9433d36dd5406fc1ccb1df07703&scene=21#wechat_redirect)

#### 知道后序中序重建二叉树

[leetcode题目](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

首先判断遍历是否为空，如果为空直接返回 NULL

接着找到后序遍历的最后一个节点，创建并放在 root 节点中，判断如果只有一个节点就直接返回 root

在中序遍历中找到后序遍历最后一个元素的位置 mid

然后开始截取，先截取中序遍历，在 mid 位置处；

后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。所以要删掉先。

再截取后续遍历，在 `leftInorder.size()` 位置处

最后递归建左子树和右子树。

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //判断节点是否为空
        if(inorder.size() == 0) {
            return nullptr;
        }
        //取出后序遍历最后一个节点，就是头结点
        int val = postorder[postorder.size() - 1];
        // 建立根节点
        TreeNode* root = new TreeNode(val);
        //如果只有一节点的话，就直接返回根节点
        if(postorder.size() == 1) return root;

        int mid ;
        //找出后序遍历最后的节点在中序遍历的位置
        for(int i=0;i<inorder.size();++i) {
            if(inorder[i] == root->val){
                mid = i;
                break;
            }
        }

        //先切割中序，再切割后序

        // 中序遍历，不要当前节点了
        // [9,3,15,20,7]   截取 9
        vector<int> leftInotder(inorder.begin(),inorder.begin() + mid); //mid = 1
        //注意这里不要已经遍历的节点了
        vector<int> rightInorder(inorder.begin() + mid + 1, inorder.end());

        //舍去没元素
        postorder.resize(postorder.size() - 1); //设置大小（size）,如果超过就删除后面的

        //后序遍历

        //[9,15,7,20]    9   （3已经被删除了）
        vector<int> leftPostorder (postorder.begin(),postorder.begin() + leftInotder.size());
        // 15,7,20  （3已经被删除了）
        vector<int> rightPostorder (postorder.begin() + leftInotder.size(),postorder.end());

        //递归建树
        root->left = buildTree(leftInotder,leftPostorder);
        root->right = buildTree(rightInorder,rightPostorder);

        return root;
    }
};
```

测试`vector`复制

```cpp
int main() {
    vector<int> temp = {1,2,3};
    vector<int> vec1 = {1,2,3,4,5};
    vector<int> vec2 (vec1.begin(),vec1.begin() + temp.size());
    vector<int> vec3 (vec1.begin() + temp.size(),vec1.end());

    vector<int>::iterator it = vec2.begin();
    for(;it!=vec2.end();++it) {
        cout << *it << " ";  //1,2,3,   也就是[1,2,3,4)    
    }
    cout << endl;
    vector<int>::iterator it3 = vec3.begin();
    for(;it3!=vec3.end();++it3) {
        cout << *it3 << " ";  //4,5    
    }
    cout << endl;
}
```

#### 知道前序中序重建二叉树

[剑指offer题目](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

思想和上一题一样

就是先找前序遍历在中序遍历中的位置，然后再切割。

最后递建 左右子树

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        //判断遍历是否为空
       if(pre.size() == 0) return NULL;
        
        //找到前序遍历第一个元素
        int val = pre[0];
        TreeNode* root = new TreeNode(val);
        // 如果只有一个元素，那么就是只有一个节点，直接返回root
        if(pre.size() == 1) return root;
        
        //找前序遍历第一个元素在中序遍历中的位置
        int mid = 0;
        for(;mid < vin.size();++mid) {
            if(vin[mid] == val) break;
        }
        
        //开始切割
        
        //中序遍历,不要正在遍历的节点
        vector<int> leftVin(vin.begin(),vin.begin() + mid);
        vector<int> rightVin(vin.begin() + mid + 1,vin.end());
        
        //删除前序遍历第一个节点
        pre.erase(pre.begin());
        
        //前序遍历
        vector<int> leftPre (pre.begin(),pre.begin() + leftVin.size());
        vector<int> rightPre (pre.begin() + leftVin.size(),pre.end());
        
        root->left = reConstructBinaryTree(leftPre, leftVin);
        root->right = reConstructBinaryTree(rightPre, rightVin);
        
        return root;
        
    }
};
```

### 二叉搜索树的第k个结点

[剑指offer题目](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一棵二叉搜索树，请找出其中第k大的节点。

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

使用中序遍历，然后用一个数组保存

记住最后要判断 k 是否超过数组的长度

- 递归法

```cpp
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        if(pRoot==NULL||k<=0) return NULL;
        vector<TreeNode*> vec;
        midTraver(pRoot,vec);
        if(k > vec.size()) {
            return NULL;  //一定要判断是否越界
        }
        return vec[k-1];
    }
   void midTraver(TreeNode* pRoot,vector<TreeNode*> &vec) {
       if(pRoot == nullptr) return;
       if(pRoot->left) midTraver(pRoot->left, vec);
       vec.push_back(pRoot);
       if(pRoot->right) midTraver(pRoot->right, vec);
   }
    
};
```

### 二叉树的镜像

[剑指offer题目](https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&&tqId=11171&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目-剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- 递归法

首先将根节点放入翻转函数中

交换左右子树，接下来使用递归翻转左右子树

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
        if(pRoot == nullptr) return nullptr;
        reverse(pRoot);
        return pRoot;
    }
    void reverse(TreeNode* root) {
        if(root == nullptr) return ;
        //交换左右子树
        swap(root->left,root->right);
        //然后继续翻转下面的语句
        reverse(root->left);
        reverse(root->right);
    }
};
```

- 迭代法

使用队列，**层次遍历**，然后把左右子树翻转

```cpp
class Solution {
public:
    TreeNode* Mirror(TreeNode* pRoot) {
       if(pRoot == nullptr) return nullptr;
        queue<TreeNode*> que;
        que.push(pRoot);
        while(!que.empty())
        {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left,node->right);
                //这里一定要放端 该节点是否存在再加入队列中
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return pRoot;
    }
};
```

### 从上往下打印二叉树

[剑指offer题目](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

示例1

```
输入：
{5,4,#,3,#,2,#,1}
复制
返回值：
[5,4,3,2,1]
```

```cpp
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(root == NULL) return  res;
        queue<TreeNode* > que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                res.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return res;
    }
};
```

#### 剑指 Offer 32 - II. 从上到下打印二叉树 II

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

```
例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

- 用队列，然后使用层次遍历，先用一个数组存每一层的结果，在放到最终的返回数组中。

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            temp = {};
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(temp);
        }
        return res;
     }
};
```


#### 按之字形顺序打印二叉树

[leetcode题目](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

[剑指offer题目](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&&tqId=11212&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 
例如:
```
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [20,9],
  [15,7]
]
```

这题其实就是之字形打印树

用一个变量记录层次就可以了

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == NULL) return res;
        int level = 0;  //记录层次
        vector<int> temp;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            ++level;
            int size = que.size();
            // temp = {};
            temp.clear();
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                temp.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            if(level % 2 == 0) reverse(temp.begin(),temp.end());
            res.push_back(temp);
        }
        return res;
     }
};
```

### 二叉搜索树的后序遍历序列

[剑指offer题目](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetcode题目](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）

示例1
```
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true
```

使用一个函数传入后序遍历数组和前后位置

找到后序遍历的最后一个节点，再找左子树的最后位置，接着找右子树的最后位置。

最后右子树的最后位置正好是最后一个节点时说明是二叉搜索树，当然也要保证左右子树也是。


```cpp
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return myPostorder(postorder,0,postorder.size() - 1);
    }
    bool myPostorder(vector<int> postorder,int start,int len) {
        // 如果只有一个节点，也就是start == len 返回tre
        if(start >= len) {
            return true;
        }

        //找出左子树后续遍历的最后一个节点的位置。也就是比 len 位置小的
        int index = start;
        int rootVal = postorder[len];
        while(postorder[index] < rootVal)
        {
            ++index;
        }
        int leftLen = index - 1;

        //找右子树后续遍历的最后一个节点，如果正好遍历到 len 说明是 true，
        while(postorder[index] > rootVal ) {
            ++index;
        }
        //这棵子树是二叉搜索树，它的左右子树也必须是
        return index == len 
            && myPostorder(postorder,start,leftLen)
            && myPostorder(postorder,leftLen + 1,len-1);  //这里记得 -1，因为头接地那不要了
    }
};
```

### 二叉树中和为某一值的路径

[剑指offer题目](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

[leetocde题目](https://leetcode-cn.com/problems/path-sum-ii/)


输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

示例：

```
输入：
{10,5,12,4,7},22
返回值：
[[10,5,7],[10,12]]
```

使用回溯，采用目标和递减的方式，到 0 的时候结束

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        if(root == nullptr) return result;
        //先把根节点放进去
        path.push_back(root->val);
        backtracking(root,expectNumber - root->val);
        return result;
    }
    void backtracking(TreeNode* root,int target)
    {
        //结束条件
        //到叶子节点满足
        if(root->left == nullptr && root->right == nullptr && target == 0){
            result.push_back(path);
            return;
        }
        //遇到叶子节点而没有找到合适的边，直接返回
        if(root->left == nullptr && root->right == nullptr) return;
        
        //左子树
        if(root->left) {
            target -= root->left->val;
            path.push_back(root->left->val);
            backtracking(root->left, target);
            target += root->left->val;
            path.pop_back();            
        }
        //右子树
        if(root->right) {
            target -= root->right->val;
            path.push_back(root->right->val);
            backtracking(root->right, target);
            target += root->right->val;
            path.pop_back();            
        }
    }
};
```

### 112. 路径总和

[leetcode题目](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
```

使用回溯法，，采用目标和递减的方式，到 0 的时候结束，左子树和右子树有一边满足就返回 true

需要注意，传入根节点的时候这时候和为 targetSum - root->val

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        return backtracking(root,targetSum - root->val); //已经遍历第一个节点，所以 targetSum - root->val
    }
    bool backtracking(TreeNode* root,int targetSum) {
        //满足条件
        if(root->left == nullptr && root->right == nullptr && targetSum == 0) return true;
        //已经到叶子节点了还不满足
        if(root->left == nullptr && root->right == nullptr && targetSum != 0) return false;

        //然后分别判断左右子树
        if(root->left) {
            targetSum -= root->left->val;
            if(backtracking(root->left,targetSum)) return true;
            targetSum += root->left->val;
        }
        if(root->right) {
            targetSum -= root->right->val;
            if(backtracking(root->right,targetSum)) return true;
            targetSum += root->right->val;
        }
        return false;
    }
};
```

### 二叉树的深度

[剑指offer题目](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

- 直接递归计算左右子树的最大值 + 本层（1）。

```cpp
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        if(pRoot == nullptr) return 0;
        return max(TreeDepth(pRoot->left),TreeDepth(pRoot->right)) + 1;
    }
};
```

- 层次遍历迭代法

```cpp
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
        if(pRoot == nullptr) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(pRoot);
        while(!que.empty()) {
            int size = que.size();
            ++depth;
            for(int i=0;i<size;++i) {
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 对称的二叉树

[对称的二叉树](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&&tqId=11211&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

示例1

```
输入：
{8,6,6,5,7,7,5}

返回值：
true
```

```cpp

```

### 101. 对称二叉树

[leetcode 题目来源](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

- 使用递归来做，先写个递归函数，分别传入左子树和右子树，然后判断左子树和右子树是否相等。不相等就直接返回 false，这时候记得判断左右子树是否有一边为空，为空就返回false，如果全为空就返回 true。

```cpp
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot==nullptr) return true; //至少有一个节点
        return myIsSymmetrical(pRoot->left, pRoot->right); 
    }
    bool myIsSymmetrical(TreeNode* lnode,TreeNode* rnode) {
        //如果一遍为空就返回false
        if(lnode == nullptr && rnode == nullptr) return true;
        if (  (lnode == nullptr && rnode != nullptr)
            || (lnode != nullptr && rnode == nullptr)
            )
        {
            return false;
        }
        // 如果不相等那么就返回false
        if(lnode->val != rnode->val) return false;
        
        bool lflag =  myIsSymmetrical(lnode->left,rnode->right);
        bool rflag = myIsSymmetrical(lnode->right, rnode->left);
        return lflag && rflag;
    }
};
```

- 使用队列,注意一开始要判断左右子树是否为空，然后根节点不用入队，直接判断孩子节点

```cpp
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot) {
        if(pRoot == nullptr || (pRoot->left == nullptr && pRoot->right == nullptr) ) return true;
        queue<TreeNode*> que;
        que.push(pRoot->left);
        que.push(pRoot->right);
        while(!que.empty())
        {
            TreeNode* nodeleft = que.front();
            que.pop();
            TreeNode* noderight = que.front();
            que.pop();
            //注意这里要先判断空再判断不空
            if(nodeleft == nullptr && noderight == nullptr) continue;
            if(!nodeleft || !noderight || (nodeleft->val != noderight->val)) {
                return false;
            }
            if(nodeleft->val != noderight->val) return false;
            
            que.push(nodeleft->left);  ///左子树左孩子
            que.push(noderight->right); ////右子树右孩子
            que.push(nodeleft->right);  ////左子树右孩子
            que.push(noderight->left);  ////右子树左孩子
        }
        return true;
    }
};
```


------


## 链表相关

### 面试题 02.01. 移除重复节点-链表去重

> 好未来实习二面

[题目来源](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)


编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:
```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

使用哈希表保存判断重复节点

注意一开始先让头节点数进入哈希表

然后传入 `p`( `p=head->next` ，pre 记录记录前面的节点

```cpp
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        unordered_map<int,int> mp;
        ListNode* p = head->next;
        ListNode* pre = head;
        //首先得把头结点放进哈希表
        mp[head->val] = 1;
        while(p) {
            if(mp.count(p->val) != 0) {    //已经存在
                pre->next = p->next;
                p = p->next;
            }
            else {
                mp[p->val] = 1;
                p = p->next;
                pre = pre->next;
            }
        }
        return head;
    }
};
```

- 或者用 unordered_set (效率很低)

```cpp
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* pHead) {
        if(pHead == nullptr || pHead->next == nullptr) return pHead;
        unordered_set<int> st;
        ListNode* p = pHead->next;
        ListNode* pre = pHead;
        st.insert(pHead->val);
        while(p) {
            if(st.count(p->val) == 1) {
                pre->next = p->next;
                p = p->next;
            }else {
                st.insert(p->val);
                p = p->next;
                pre = pre->next;
            }
        }
        return pHead;
    }
};
```

### 82. 删除排序链表中的重复元素 II

[leetcode](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。

返回同样按升序排列的结果链表。

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

注意这题是排好序了的，下面那题不是排好序的



### 删除链表中重复的结点

[剑指offer题目](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

[leetcode题目](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表`1->2->3->3->4->4->5` 处理后为 `1->2->5`

示例1

```
输入：
{1,2,3,3,4,4,5}

返回值：
{1,2,5}
```
**这题是把重复的接节点全部删除**

思路：

```cpp

```



### 两个链表的第一个公共结点

[题目来源](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

思路：

使用一个哈希表保存第一个链表，然后再去第二个链表进行查找

```cpp
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        unordered_map<int,int> mp;
        ListNode* ph1 = pHead1;
        while(ph1) {
            mp[ph1->val] = ph1->val;
            ph1 = ph1->next;
        }
        ListNode* ph2 = pHead2;
        while(ph2)
        {
            if(mp.count(ph2->val) != 0) return ph2;
            ph2 = ph2->next;
        }
        return nullptr;
    }
};
```



------

## 其他

### 设计LRU缓存结构

[题目来源]()

设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能
set(key, value)：将记录(key, value)插入该结构
get(key)：返回key对应的value值

[要求]

set和get方法的时间复杂度为`O(1)`

某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。

当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。

若`opt=1`，接下来两个整数`x`, `y`，表示`set(x, y)`

若`opt=2`，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回`-1`
对于每个操作`2`，输出一个答案

```
输入：
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3
复制
返回值：
[1,-1]
```

```cpp
class Solution {
public:
    /**
     * lru design
     * @param operators int整型vector<vector<>> the ops
     * @param k int整型 the k
     * @return int整型vector
     */
    vector<int> LRU(vector<vector<int> >& operators, int k) {
        cap = k;
        vector<int> ans;
        for(auto &num : operators) {
            if(num[0] == 1) {
                set(num[1],num[2]);
            }
            else {
                ans.push_back(get(num[1]));
            }
        }
        return ans;
    }
    //插入
    //首先查找，如果有就删除，然后不管有没有都在队头插入
    void set(int key,int value) {
        auto it = mp.find(key);
        if(it != mp.end()) { //如果有，就删除
            cache.erase(it->second);
            mp.erase(key);
        }
        // 然后再插入队头
         pair<int, int> n(key,value);
        cache.push_front(n);
        mp.emplace(key,cache.begin());
        
        //如果缓冲区满了，就要删除对尾节点
        if(cap < cache.size()) {
            //哈希表删除
            mp.erase(cache.back().first);
            cache.pop_back();
        }
    }
    //获取
    //先查找哈希表，如果没有就结束，有就复制到头部，再删除原有位置元素
    int get(int key) {
        auto it = mp.find(key);
        if(it == mp.end() ) { //如果没有，就结束
            return -1;
        }
        //如果有
        //删除原有的，插入前面
        auto target_it = it->second;
        pair<int, int> n(key,target_it->second);
        cache.push_front(n);
        // 删除
        cache.erase(target_it);
        mp.erase(key);
        mp.emplace(key,cache.begin());
        
        return n.second;
    }
private:
    int cap;
    list<pair<int,int>> cache;
    unordered_map<int,list<pair<int, int>>::iterator> mp;
};
```

## 位运算相关

### 136. 只出现一次的数字

[题目来源](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:
```
输入: [2,2,1]
输出: 1
```

- 第一种思路：使用 unordered_set 哈希集

> 这种方法效率很低，用于学习使用 unordered_set

> unordered_set 无序集是没有特定顺序存储唯一元素的容器，**不允许有重复值**。set 是有序容器

> `unordered_set` 不能用来保存`pair<int, int>`，但是 set 可以。因为`unordered_set`是基于哈希的，而 C++ 并没有给`pair`事先写好哈希方法。`set`是基于比较的树结构，所以`pair`里的数据结构只要都支持比较就能储存。 

提供的方法：

```cpp
unordered_set::insert
unordered_set::find
unordered_set::erase
unordered_set::count
```
`count()`: 在容器中搜索值为k的元素，并返回找到的元素个数。因为unordered_set容器不允许重复的值，这意味着如果容器中存在具有该值的元素，该函数实际上返回1，否则返回0。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> st;
        int ans;
        for(auto num : nums) {
            //count(): 在容器中搜索值为k的元素，并返回找到的元素个数。因为unordered_set容器不允许重复的值，这意味着如果容器中存在具有该值的元素，该函数实际上返回1，否则返回0。
            if(st.count(num) == 1) //存在
            {
                st.erase(num);
            }
            else {  //不存在
                st.insert(num);
            }
        }
        //最后剩下的就是不重复的数字,这里实际上只剩下一个元素了
        for(auto t : st) {
            ans =  t;
        }
        return ans;
    }
};
```

- 第二种思路：使用双指针，先排序后查找前后是否相等，注意最后如果在循环中没有找到，考虑总数是单数的原因返回最后一个数。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        sort(nums.begin(),nums.end());
        for(int i=0,j=1;j<nums.size();i+=2,j+=2) {
            if(nums[i] != nums[j]) {
                return nums[i];
            }
        }
        //如果nums个数是单数
        return nums[nums.size()  -1];
    }
};
```

- **位运算**

注意是换成二进制算

```
1 ⊕ 1 = 0

0 ⊕ 0 = 0

1 ⊕ 0 = 1

0 ⊕ 1 = 1

a ^ a = 0
0 ^ a = a
```

> 相同为 0，不同为 1

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans =0;
        for(int num : nums) {
            ans ^= num;
        }
        return ans;
    }
};
```

### 137. 只出现一次的数字 II

[题目来源](https://leetcode-cn.com/problems/single-number-ii/)

- 不会做












