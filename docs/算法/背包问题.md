## 背包问题

现在有物件商品w[0,1,2,3,4],放入总容量为20的背包。具体价格和实现如下图。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包01.25pyvxpd5xxc.png)

假如：`B(2, 20)` 表示偷了`[0~2]`件商品后，背包中剩余的容量时`20`。

背包问题主要是围绕着下面这个公式进行：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包02.4pes05ob2qa0.png)


举例子：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包03.27tl7wzxgyas.png)

代码实现：

```cpp
#include <iostream>
#include <vector>

using namespace std;

#define N 6  //物件物品，定义成6
#define M 21  //总的容量，定义成20

// 动态规划数组,价值
int B[N][M] = {0};  //全部初始化成0

//物件商品，设置成6，第一件空出来，方便实现
int w[6] = {0,2,3,4,5,9}; //每件商品的重量
int v[6] = {0,3,4,5,8,10};  //每件商品的价格

//实现背包
void knpack() {
    int k,C;  //K表示第K个商品，C表示最大容量
    for(k=1;k<N;++k) {
        for(C=1;C<M;++C) {
            //如果第k件商品该种，装不下
            if(w[k] > C) {
                B[k][C] = B[k-1][C];
            }
            else {
                //偷
                int value1 = B[k-1][C-w[k]] + v[k];
                //不偷
                int value2 = B[k-1][C];
                // 然后再比较这两个大小
                if(value1 > value2) {
                    //更新最大价值
                    B[k][C] = value1;
                }
                else {
                    B[k][C] = value2;
                }
            }
        }
    }
}

int main() {
    knpack();
    cout << B[5][20] << endl;;  //5个商品，背包总容量是20的时候，最大价值
}

//输出：26
```

---
## 背包问题-二维数组

[参考](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486598&idx=1&sn=dd7d0530dd7a5caef7ce70cc3d6eee3f&scene=21#wechat_redirect)

`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。

注意：初始化时**一定要倒叙遍历，保证物品0只被放入一次！这一点对01背包很重要，后面在讲解滚动数组的时候，还会用到倒叙遍历来保证物品使用一次！**

```cpp
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;  //表示背包最多能容纳的重量

    // 二维数组
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));

    // 初始化 只有一个物品的时候
    for (int j = bagWeight; j >= weight[0]; j--) {
        dp[0][j] = dp[0][j - weight[0]] + value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            //如果不能装下
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];

            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagWeight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}

```

### 背包问题-一维数组

在一维`dp`数组中，`dp[j]`表示：容量为`j`的背包，所背的物品价值可以最大为`dp[j]`。

公式：

一种是取`i`，那么重量就得减去`i`的重量，并加上`i`的价值。如果不选`i`，那么最大价值就是目前这个（剩余）重量的价值。

```cpp
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

注意，在遍历的时候：

**二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小**。



```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化，全部初始化为0就可以了,注意容量时bagWeight + 1（重量）
    vector<int> dp(bagWeight + 1, 0);

    //遍历
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}

```

---

## 416.分割等和子集

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

示例 
```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

题解：

参考背包问题-一维数组

`dp[i]`表示 背包总容量是`i`，最大可以凑成`i`的子集总和为`dp[i]`。

本题，相当于背包里放入数值，那么物品i的重量是`nums[i]`，其价值也是`nums[i]`。

从`dp[j]`的定义来看，首先`dp[0]`一定是`0`。

> 如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {

        int sum = 0;
        for(int i=0;i<nums.size();++i) {
            sum += nums[i];
        }
        // 如果是奇数就直接返回
        if(sum % 2 != 0) return false;
        int target = sum / 2;

        // 定义并初始化
        // dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]。
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 那么背包内总和不会大于20000，所以定义一个20000大的数组。
        vector<int> dp(20001,0);  //注意这里的i表示和，不能是nums.size()

        // 相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

        //遍历
        for(int i=0;i<nums.size();++i) {
            // 每一个元素一定是不可重复放入，所以从大到小遍历
            for(int j=target;j>=nums[i];--j) {
                // dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
                //如果取i，那么子集背包中加上i之后的容量，再加上i的值，如果不取i，那么久在目前这个（剩余）容量的价(和)
                dp[j] = max(dp[j],dp[j-nums[i]] + nums[i]);
            }
        }
        if(dp[target] == target) return true;
        return false;
        
    }
};
```
时间复杂度：$O(n)$

空间复杂度：$O(n)$，虽然dp数组大小为一个常数，但是大常数

