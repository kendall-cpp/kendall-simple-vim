
> 一般是求从一些元素中取出一部分，然后求最值        
> 背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。        
> 即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。


## 背包问题

现在有物件商品w[0,1,2,3,4],放入总容量为20的背包。具体价格和实现如下图。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包01.25pyvxpd5xxc.png)

假如：`B(2, 20)` 表示偷了`[0~2]`件商品后，背包中剩余的容量时`20`。

背包问题主要是围绕着下面这个公式进行：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包02.4pes05ob2qa0.png)


举例子：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包03.27tl7wzxgyas.png)

代码实现：

```cpp
#include <iostream>
#include <vector>

using namespace std;

#define N 6  //物件物品，定义成6
#define M 21  //总的容量，定义成20

// 动态规划数组,价值
int B[N][M] = {0};  //全部初始化成0

//物件商品，设置成6，第一件空出来，方便实现
int w[6] = {0,2,3,4,5,9}; //每件商品的重量
int v[6] = {0,3,4,5,8,10};  //每件商品的价格

//实现背包
void knpack() {
    int k,C;  //K表示第K个商品，C表示最大容量
    for(k=1;k<N;++k) {
        for(C=1;C<M;++C) {
            //如果第k件商品该种，装不下
            if(w[k] > C) {
                B[k][C] = B[k-1][C];
            }
            else {
                //偷
                int value1 = B[k-1][C-w[k]] + v[k];
                //不偷
                int value2 = B[k-1][C];
                // 然后再比较这两个大小
                if(value1 > value2) {
                    //更新最大价值
                    B[k][C] = value1;
                }
                else {
                    B[k][C] = value2;
                }
            }
        }
    }
}

int main() {
    knpack();
    cout << B[5][20] << endl;;  //5个商品，背包总容量是20的时候，最大价值
}

//输出：26
```

---
## 背包问题-二维数组

[参考](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486598&idx=1&sn=dd7d0530dd7a5caef7ce70cc3d6eee3f&scene=21#wechat_redirect)

`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。

注意：初始化时**一定要倒叙遍历，保证物品0只被放入一次！这一点对01背包很重要，后面在讲解滚动数组的时候，还会用到倒叙遍历来保证物品使用一次！**

```cpp
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;  //表示背包最多能容纳的重量

    // 二维数组
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));

    // 初始化 只有一个物品的时候
    for (int j = bagWeight; j >= weight[0]; j--) {
        dp[0][j] = dp[0][j - weight[0]] + value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            //如果不能装下
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];

            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagWeight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}

```

### 背包问题-一维数组

在一维`dp`数组中，`dp[j]`表示：容量为`j`的背包，所背的物品价值可以最大为`dp[j]`。

公式：

一种是取`i`，那么重量就得减去`i`的重量，并加上`i`的价值。如果不选`i`，那么最大价值就是目前这个（剩余）重量的价值。

```cpp
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

注意，在遍历的时候：

**二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小**。



```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化，全部初始化为0就可以了,注意容量时bagWeight + 1（重量）
    vector<int> dp(bagWeight + 1, 0);

    //遍历
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}

```

---

## 416.分割等和子集

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

示例 
```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

题解：

只有确定了如下四点，才能把01背包问题套到本题上来。

- 背包的体积为`sum / 2`
- 背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值
- 背包如何正好装满，说明找到了总和为 `sum / 2` 的子集。
- 背包中每一个元素是不可重复放入。

参考背包问题-一维数组

`dp[i]`表示 背包总容量是`i`，最大可以凑成`i`的子集总和为`dp[i]`。

本题，相当于背包里放入数值，那么物品i的重量是`nums[i]`，其价值也是`nums[i]`。

从`dp[j]`的定义来看，首先`dp[0]`一定是`0`。

> 如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {

        int sum = 0;
        for(int i=0;i<nums.size();++i) {
            sum += nums[i];
        }
        // 如果是奇数就直接返回
        if(sum % 2 != 0) return false;
        int target = sum / 2;

        // 定义并初始化
        // dp[i]表示 背包总容量是i，最大可以凑成i的子集总和为dp[i]。
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 那么背包内总和不会大于20000，所以定义一个20000大的数组。
        vector<int> dp(20001,0);  //注意这里的i表示和，不能是nums.size()

        // 相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

        //遍历
        for(int i=0;i<nums.size();++i) {
            // 每一个元素一定是不可重复放入，所以从大到小遍历
            for(int j=target;j>=nums[i];--j) {
                // dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
                //如果取i，那么子集背包中加上i之后的容量，再加上i的值，如果不取i，那么就在目前这个（剩余）容量的价值(和)
                dp[j] = max(dp[j],dp[j-nums[i]] + nums[i]);
            }
        }
        if(dp[target] == target) return true;
        return false;
        
    }
};
```
时间复杂度：$O(n)$

空间复杂度：$O(n)$，虽然dp数组大小为一个常数，但是大常数

## 1049.最后一块石头的重量 II

[题目来源](https://leetcode-cn.com/problems/last-stone-weight-ii/)


有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 `x <= y`。那么粉碎的可能结果如下：

如果 `x == y`，那么两块石头都会被完全粉碎；

如果 `x != y`，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

 

示例：
```
输入：[2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

提示：
```
1 <= stones.length <= 30
1 <= stones[i] <= 1000
```

题解：

> 先利用动态规划-背包把石头分成尽重量尽可能接近的两部分，也就是上一题[416.分割等和子集]的`sum/2`问题。然后再相减。

动态规划五部曲

- 确定dp数组以及下标的含义

`dp[j]`表示容量（这里说容量更形象，其实就是重量）为`j`的背包，最多可以背`dp[j]`这么重的石头。

- 确定递推公式

> 重量和价值都是石头的重量

01背包的递推公式为：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`

本题则是：`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);`

- dp数组如何初始化

既然 `dp[j]`中的`j`表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。

因为提示中给出`1 <= stones.length <= 30，1 <= stones[i] <= 1000`，所以最大重量就是`30 * 1000` 。

而我们要求的`target`其实只是最大重量的一半，所以dp数组开到`15000`大小就可以了。

当然也可以把石头遍历一遍，计算出石头总重量 然后除`2`，得到`dp`数组的大小。

因为重量都不会是负数，所以`dp[j]`都初始化为0就可以了，这样在递归公式`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])`中`dp[j]`才不会初始值所覆盖。

- 确定遍历顺序

```cpp

for (int i = 0; i < stones.size(); i++) { // 遍历物品
    for (int j = target; j >= stones[i]; j--) { // 遍历背包,从大到小
        dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
    }
}
```

- 举例推导dp数组

---

最后`dp[target]`里是容量为`target`的背包所能背的最大重量。

那么分成两堆石头，一堆石头的总重量是`dp[target]`，另一堆就是`sum - dp[target]`。

在计算target的时候，`target = sum / 2` 因为是向下取整，所以`sum - dp[target] `一定是大于等于dp[target]的。或者去绝对值。

那么相撞之后剩下的最小石头重量就是 `(sum - dp[target]) - dp[target]`

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        //定义动态数组和初始化
        vector<int> dp(15001,0);

        int sum = 0;
        for(int i=0;i<stones.size();++i) {
            sum += stones[i];
        }
        int target = sum / 2;

        // 遍历
        for(int i=0;i<stones.size();++i) {
            for(int j=target;j>=stones[i];--j) { //j是重量
                dp[j] = max(dp[j],dp[j - stones[i]] + stones[i]);
            }
        }
        // return (sum - dp[target]) - dp[target];
        return abs( dp[target] - (sum - dp[target]) );
    }
};
```

时间复杂度：$O(m * n)$ , m是石头总重量（准确的说是总重量的一半），n为石头块数

空间复杂度：$O(m)$

## 494.目标和

[题目来源](https://leetcode-cn.com/problems/target-sum/)

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。


示例：
```
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

