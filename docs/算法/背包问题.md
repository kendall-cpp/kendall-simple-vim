## 背包问题

现在有物件商品w[0,1,2,3,4],放入总容量为20的背包。具体价格和实现如下图。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包01.25pyvxpd5xxc.png)

假如：`B(2, 20)` 表示偷了`[0~2]`件商品后，背包中剩余的容量时`20`。

背包问题主要是围绕着下面这个公式进行：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包02.4pes05ob2qa0.png)


举例子：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包03.27tl7wzxgyas.png)

代码实现：

```cpp
#include <iostream>
#include <vector>

using namespace std;

#define N 6  //物件物品，定义成6
#define M 21  //总的容量，定义成20

// 动态规划数组,价值
int B[N][M] = {0};  //全部初始化成0

//物件商品，设置成6，第一件空出来，方便实现
int w[6] = {0,2,3,4,5,9}; //每件商品的重量
int v[6] = {0,3,4,5,8,10};  //每件商品的价格

//实现背包
void knpack() {
    int k,C;  //K表示第K个商品，C表示最大容量
    for(k=1;k<N;++k) {
        for(C=1;C<M;++C) {
            //如果第k件商品该种，装不下
            if(w[k] > C) {
                B[k][C] = B[k-1][C];
            }
            else {
                //偷
                int value1 = B[k-1][C-w[k]] + v[k];
                //不偷
                int value2 = B[k-1][C];
                // 然后再比较这两个大小
                if(value1 > value2) {
                    //更新最大价值
                    B[k][C] = value1;
                }
                else {
                    B[k][C] = value2;
                }
            }
        }
    }
}

int main() {
    knpack();
    cout << B[5][20] << endl;;  //5个商品，背包总容量是20的时候，最大价值
}

//输出：26
```
