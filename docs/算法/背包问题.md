## 背包问题

现在有物件商品w[0,1,2,3,4],放入总容量为20的背包。具体价格和实现如下图。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包01.25pyvxpd5xxc.png)

假如：`B(2, 20)` 表示偷了`[0~2]`件商品后，背包中剩余的容量时`20`。

背包问题主要是围绕着下面这个公式进行：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包02.4pes05ob2qa0.png)


举例子：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/背包03.27tl7wzxgyas.png)

代码实现：

```cpp
#include <iostream>
#include <vector>

using namespace std;

#define N 6  //物件物品，定义成6
#define M 21  //总的容量，定义成20

// 动态规划数组,价值
int B[N][M] = {0};  //全部初始化成0

//物件商品，设置成6，第一件空出来，方便实现
int w[6] = {0,2,3,4,5,9}; //每件商品的重量
int v[6] = {0,3,4,5,8,10};  //每件商品的价格

//实现背包
void knpack() {
    int k,C;  //K表示第K个商品，C表示最大容量
    for(k=1;k<N;++k) {
        for(C=1;C<M;++C) {
            //如果第k件商品该种，装不下
            if(w[k] > C) {
                B[k][C] = B[k-1][C];
            }
            else {
                //偷
                int value1 = B[k-1][C-w[k]] + v[k];
                //不偷
                int value2 = B[k-1][C];
                // 然后再比较这两个大小
                if(value1 > value2) {
                    //更新最大价值
                    B[k][C] = value1;
                }
                else {
                    B[k][C] = value2;
                }
            }
        }
    }
}

int main() {
    knpack();
    cout << B[5][20] << endl;;  //5个商品，背包总容量是20的时候，最大价值
}

//输出：26
```

---

## 416.分割等和子集

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

示例 
```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

题解：

动态规划

- 在若干个物品中选出一些物品，每个物品只能使用一次，这些物品恰好能装满容量为`sum/2`的背包，
- 0-1背包问题：在 M 件物品中取出若干个物品放入体积为 W 的背包，每件物品只有一件，他们有各自的体积和价值，问如何能使背包能容纳的价值最多。

**步骤**

- 设置状态：`dp[i][j]`表示考虑下标`[0,1]`这个区间所有整数，在他们当中是否能够选出一些数，使得这些数之和恰好等于 `j`。

- 状态转移方程：
  - 不选`num[i]`:`dp[i][j] = dp[i-1][j]`
  - 选择`num[i]`：还需要考虑是否超过`sum/2`
    - 1.如果`num[i] = j`,`dp[i][j] = true`;
    - 2.如果`num[i] <= j`,`dp[i][j] = dp[i-1][j-num[i]]`;
- 初始化：`dp[i][j] = false`;
- 输出：`dp[len-1][sum/2]`;

下表列是`sum/2`

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/416-01.2pr4atcnqok0.png)

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int len = nums.size();

        // 我们要求的是sum/2的子集，那么先求出sum
        int sum = 0;
        for(auto num: nums) {
            sum += num;
        }
        // 如果是奇数，那可以直接返回，因为两个子集的和相等
        if((sum & 1) == 1) {
            return false;
        }
        int target = sum / 2;
        //初始化一个动态规划二维表格，行就是有多少个数，列要考虑0这个数组，所以是target + 1
        vector<vector<bool>> dp(len,vector<bool>(target + 1));

        // 第一行只能填满num[0]这个背包
        if(nums[0] <= target) {
            dp[0][nums[0]] = true;
        }
        for(int i=1;i<len;++i) {
            for(int j=0;j<=target;++j) {
                // 不考虑当前的元素，直接将上一行的元素赋值下来
                dp[i][j] = dp[i-1][j];

                //考虑当前元素的值,两种情况
                if(nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                else if(nums[i] < j) {
                    //状态转移  或者是上一行的值，或者是当期那的值做减法
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                }

            }
        }
        return dp[len - 1][target];
    }
};
```
[参考](https://www.bilibili.com/video/BV1oZ4y1G7QY?from=search&seid=4741897690610601572)

题解二：

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;  //总和
        for(int num: nums) 
            sum += num;
            //和是奇数的时候，不能划分为两个相等的集合
        if( sum % 2 != 0 ) return false;
        int n = nums.size();
        // 每一个集合的和
        sum = sum / 2;
        // dp[i][j] = x 表示，对于前 i 个物品，当前背包的容量为 j 时，
        //若 x 为 true，则说明可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满。
        vector<vector<bool>> dp(n + 1,vector<bool>(sum + 1,false));

        for(int i = 0;i <= n; ++i) {
            dp[i][0] = true;
        }
        for(int i=1;i<=n;++i) {
            for(int j=1;j <= sum;++j) {
                if(j-nums[i-1] < 0) {
                    //背包容量不足，不能转入第i个物品
                    dp[i][j] = dp[i-1][j];
                }else {
                    //装入或不装入背包
                    dp[i][j] = dp[i - 1][j] || dp[i-1][j-nums[i-1]];
                }
            }
        }
        return dp[n][sum];
        
    }
};
```