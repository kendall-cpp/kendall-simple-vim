C++ 中的`&`与C语言中的不一样，C语言中的`&`表示取地址符号，取地址符常常用来用在**函数传参**中的**指针赋值**。但是C++中`&`符号，是提高代码执行效率和增强代码质量的一个很好的办法。

## 引用的简介

#### 什么是引用
引用就是变量的别名，操作一个变量的引用也就相当于操作变量本身，这一点跟指针很类似。

#### 为什么需要引用
C语言之中大量利用指针作为形参或者函数返回值，这是由于值拷贝会有很大的消耗（比如传入传出一个大的结构体）。所以在C++之中使用引用作为函数参数和返回值的目的和使用指针是一样的。而且形式上更加直观，所以C++提倡使用引用。

> **引用的声明方法**：[类型标识符] `&`[引用名]=[目标变量名]         
> `int a; int &ra=a;` //定义引用ra,它是变量a的引用，即别名

#### 关于引用的说明
- `&`在此不是求地址运算，而是起标识作用。
- 引用在声明时就必须对它进行初始化
- 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。`ra=1; `等价于 `a=1;`
- 引用本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。`&ra`与`&a`相等。
- 不能为数组建立引用，因为数组是由若干个元素组成，所以不能建立数组的别名。

## 引用的应用
### 引用作为参数
当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。当以这种方式将数据传递给形参时，该实参被称为按**引用传递**。
```js
#include <iostream>
using namespace  std;

//参数传递:值传递
void swap1(int x,int y) {
    int temp = x;
    x = y;
    y = temp;
}
//参数传递：地址传递 --> (本质还是)值传递
void swap2(int * px,int * py) {
    int temp = *px;
    *px = *py;
    *py = temp;
}  
//参数传递：引用传递
//引用传递它减少了数据的复制, 可以提高程序的执行效率
//引用传递操作的就是实参本身
void swap3(int & x,int & y) {
    int temp = x;
    x = y;
    y = temp;
}
int main() {

    int x = 10,y = 20;
    swap1(x,y);
    cout << "x = " << x << endl;  //x = 10
    cout << "y = " << y << endl;  //y = 20

    swap2(&x,&y);
    cout << "x = " << x << endl;  //x = 20
    cout << "y = " << y << endl;  //y = 10

    swap3(x,y);
    cout << "x = " << x << endl;  //x = 10
    cout << "y = " << y << endl;  //y = 20
    return 0;
}
```
通过值传递，并不会改变原始的值。      
通过地址传递，可以改变原始的值，本质还是值传递          
通过引用传递，操作的就是原始数据本身，所以会改变原始的值.引用传递减少了数值的赋值，提高效率。

**指针与引用的区别：**
> 1. 指针是可以独立存在的; 但是引用不行         
> 2. 引用必须要进行初始化，指针没有必要         
> 3. 指针可以设置为NULL， 但是引用不行          
> 4. 引用一旦进行初始化之后，不会再改变其指向；但指针可以

### 引用作为函数的返回值 
**语法：**
> 语法：类型 &函数名（形参列表）{ 函数体 }

**注意：**
> 1.引用作为函数的返回值时，必须在定义函数时在函数名前将&

> 2.用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本

```js
#include <iostream>
using namespace  std;

int arr[5] = {0,1,2,3,4};
//返回引用的方式
int & func(int idx) { // 返回值是引用，返回的变量生命周期一定要大于函数本身
    return arr[idx];
}
//返回值的方式
int func1(int idx) {
    return arr[idx];
}
int main() {

    // 用返回引用的方式调用函数
    int a = func(0);
    cout << a << endl;  //0
    func(0) = 10;
    cout << func(0) << endl; //10

    // 用返回值方式调用函数
    int a1 = func1(1);
    cout << a1 << endl;  //1
//    func1(1) = 10;  //不能直接修改

    // 用函数的返回值初始化引用的方式调用函数
//    int &a2 = func1(2);  // error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int'
                             //（有些编译器可以成功编译该语句，但会给出一个warning）

    // 函数返回的引用作为新引用的初始化值的方式来调用函数
    int &a3 = func(3);
    cout << a3 << endl;  //3
    return 0;
}
```
- 用返回值方式调用函数          
返回全局数组元素`arr[1]`时，C++会在内存中创建临时变量并将`arr[1]`的值拷贝给该临时变量,当返回到主函数`main`后，赋值语句`int a1 = func(1);`会把临时变量的值再拷贝给变量a1。也不能直接通过函数返回修改`arr[1]`【临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束)】。

- 用返回引用的方式调用函数          
这种情况下，函数`func()`的返回值不产生副本，而是直接将`arr[0]`返回给主函数，即主函数的赋值语句中的左值是直接从`arr[0]`中拷贝而来（也就是说a只是`arr[0]`的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当`arr[0]`这个变量是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。

- 用函数的返回值初始化引用的方式调用函数            
这种情况下，函数`func1(2)`是以值方式返回到，返回时，首先拷贝`arr[2]`的值给临时变量。返回到主函数后，用临时变量来初始化引用变量`a2`，使得`a2`成为该临时变量的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句`int &a2 = func1(2);`;之后） ，所以`a2`面临无效的危险，很有可能以后的值是个无法确定的值。

 如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用：
```js
int a2 = func1(2);
int &b = a2;
```

- 用函数返回的引用作为新引用的初始化值的方式来调用函数      
这种情况下，函数`func(3)`的返回值不产生副本，而是直接将变量`arr[3]`返回给主函数。在主函数中，一个引用声明`a3`用该返回值初始化，也就是说此时`a3`成为变量`arr[3]`的别名。由于`arr[3]`是全局变量，所以在`a3`的有效期内`arr[3]`始终保持有效，故这种做法是安全的。

**注意：**          
- 不要返回一个局部变量的引用
> 如下面的例子，如果`number`是局部变量，那么它会在函数返回后被销毁，此时对`number`的引用就会成为“无所指”的引用，程序会进入未知状态。   
      
- 不要轻易返回一个堆空间变量的引用，除非有了一个回收空间的策略。
> 虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生

```js
//不要返回一个局部变量的引用
int & func2() {
    int number = 10;
    return number;
}
//不要轻易返回一个堆空间变量的引用，
//除非有了一个回收空间的策略
int & func3()
{
    int * p = new int(11);
    return *p;
}
int main() {

    cout << func2() << endl;  //局部变量number的声明周期可能会结束了
    int &num = func2();

    int a = 3, b = 4;
    int c = a + b + func3();//每调用一次func3函数，就会产生一次内存泄漏
    cout << "c = " << c << endl;

    //回收空间策略
    int & ref = func3();
    cout << "ref = " << ref << endl;
    delete &ref;

    return 0;
}
```







