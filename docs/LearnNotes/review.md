# review

# linux内核

## 用户模式和内核模式

- 用户模式 和 内核模式分别是操作系统运行的两种不同的状态。用户模式下程序只能访问自己的内存空间，而不能直接访问操作系统内核的内存。而内核模式下则可以访问所有内存空间。

- 用户模式和内核模式的区别在于对系统资源(如内存、外设等)的访问权限不同。在用户模式下，应用程序只能访问自己拥有的资源，并且不能直接访问内核资源；在内核模式下，操作系统可以访问所有资源。此外，内核模式在处理中断时具有更高的优先级，因此能够更快速地响应硬件事件。

> 内核模式和用户模式之间如何进行切换？

- 核模式和用户模式之间的切换是由操作系统控制的，通过特定的系统调用或者异常处理机制实现。当某个应用程序需要访问系统资源时，它会向操作系统发起一个系统调用请求，这时操作系统会将 CPU 的工作模式从用户模式切换到内核模式，以便能够访问所需的系统资源。当操作完成后，操作系统会将 CPU 重新切换回用户模式，使得应用程序能够继续执行。

> 用户模式程序可能会发生哪些异常情况导致进入内核模式？

- 用户模式程序可能会遇到各种异常情况，例如访问非法内存、除数为0等等。这些异常会触发硬件中断或者异常处理程序，使得CPU从用户模式切换到内核模式，操作系统将处理这些异常并采取适当的措施，最终将CPU重新切换回用户模式，以便应用程序能够继续执行。

> 为什么需要区分用户模式和内核模式？

- 区分用户模式和内核模式可以有效地保障操作系统的安全性和稳定性。由于应用程序只能访问自己拥有的资源，因此可以避免应用程序对系统资源的误操作或者恶意攻击。同时，内核模式具有更高的权限和优先级，可以更加快速地响应硬件事件，并且更好地管理系统资源。

## linux 常见物理内存的管理方法有哪些

- Buddy 系统（伙伴系统）：将可用物理内存块分成大小相等的块，并使用二叉树结构来跟踪每个块的可用性和状态。
  - 通常用于分配**大块内存**。它的优势是简单高效，适用于对**内存碎片化要求较低**的场景。
  - 例如数组、图像、视频或者音频文件。这些对象通常需要长期存储，并且在整个程序运行期间都可能被多次访问

- Slab分配器：是一种基于对象缓存的内存分配器，用于分配小块内存。它通过缓存已经分配过的对象来提高性能，并具有更好的内存碎片管理能力。它的优势是可以减少内存碎片化，适合频繁分配和释放**小块内存**的场景。
  - 例如，在编写循环或函数时，可能需要使用小块内存来存储迭代器或局部变量。通常用于存储数据结构、变量、指针等较小的数据对象

### 伙伴系统

“伙伴系统”用于在计算机操作系统中分配和释放内存。它的目的是最大化可用内存的利用率，并减少内存浪费的情况。

伙伴系统将整个物理内存划分为大小相等的块，并将这些块组成一个二叉树。每个节点都代表一组块，称为“伙伴块”。每个伙伴块的大小是 2 的某个幂次方。根据二叉树结构，每个节点都有两个子节点，称为左子节点和右子节点。左子节点表示较小的伙伴块，而右子节点表示较大的伙伴块。（注意，这里的“左”和“右”仅用于表示树结构，与实际内存地址无关。）

当需要分配一块内存时，伙伴系统会从根节点开始遍历二叉树，找到大小最接近所需内存大小的伙伴块。如果该伙伴块已被占用，则继续遍历其子节点。直到找到一个空闲的伙伴块，然后将其拆分为两个更小的伙伴块，其中一个作为分配出去的内存，另一个则返回到二叉树中。如果拆分后的伙伴块大小仍然大于所需内存，那么继续递归拆分，直到找到合适大小的伙伴块。

当需要释放一块内存时，伙伴系统会将其返回到二叉树中，并检查该块的“伙伴块”是否空闲。如果相邻的两个伙伴块都是空闲的，那么它们就会被合并成一个更大的伙伴块，然后递归向上合并，直到无法再合并为止。

在 linux 内核源码中，各个不同的空闲块是通过链表来管理的，每个链表对应于一组大小相同的空闲块。这些块的大小都是2的幂次方，并且都属于同一个区间。例如，假设物理内存大小为1GB，伙伴系统将其分成了大小为4KB、8KB、16KB等的多个块，那么就会有多个链表，分别管理大小为4KB、8KB、16KB等的空闲块。

> 没记错的话在源码中将所有的页面分配成 11 个内存块链表，分别包括 1，2，8，16，...,1024 个连续的页面。

```c
// include/linux/mmzone.h 
#define MAX_ORDER 11
```

当某个进程请求一定大小的内存时，伙伴系统会在二叉树上查找与请求大小最接近的空闲块，并将其分割成两个大小相等的伙伴块，其中一个用于返回给请求进程，另一个则插入到相应大小的块链表中。如果分割后的伙伴块也是空闲的，则会递归地合并这两个伙伴块，并将合并后的块插入到更大的块链表中。

### slab 分配器

它原理比较简单：在内存中预先分配一些固定大小的区域（称为 slab），每个 slab 能够容纳一定数量的相同类型的内核对象。当内核需要分配某种类型的内核对象时，就从对应类型的 slab 中取出一个可用的空间来使用，当内核不再需要这个内核对象时，将其释放回对应的 slab 中即可。

具体来说，在内核启动过程中，会为各种类型的内核对象（如进程描述符、文件描述符等）预先分配一定数目的 slab，每个 slab 中包含多个连续的内存块，其中每个内存块都和其他内存块的大小相同，并且都能够容纳一个特定类型的内核对象。在 slab 中新增内核对象时，只需要找到一个空闲的内存块即可，如果 slab 已经满了，则需要重新分配一个新的 slab。

在 slab 分配器中，还有一个重要的结构体 kmem_cache，它表示了一个特定类型的内核对象的相关信息，包括对象的大小、对齐方式等。kmem_cache 中维护着该类型内核对象所使用的 slab，以及当前 slab 中空闲内存块的数量等信息。在进行内核对象的分配和释放时，slab 分配器会根据 kmem_cache 中的信息来选择合适的 slab 进行分配或释放操作。

总的来说，slab 分配器的优点是能够提高内存的利用率，同时也避免了常规内存分配算法中频繁的内存分配和释放带来的性能问题。

