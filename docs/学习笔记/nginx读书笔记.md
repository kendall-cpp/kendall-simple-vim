
- [第 2 章](#第-2-章)
	- [为什么要把worker进程数量设置得与CPU核心数量一致呢？](#为什么要把worker进程数量设置得与cpu核心数量一致呢)
	- [nginx 配置](#nginx-配置)
	- [Nginx的反向代理](#nginx的反向代理)
	- [为什么说 Nginx  这种反向代理工作方式就能降低上游服务器的负载](#为什么说-nginx--这种反向代理工作方式就能降低上游服务器的负载)
- [第 3 章](#第-3-章)
	- [HTTP 模块是如何处理用户请求](#http-模块是如何处理用户请求)
	- [ngx_list_t 数据结构](#ngx_list_t-数据结构)
		- [ngx_list_t 这种数据结构设计有什么优势](#ngx_list_t-这种数据结构设计有什么优势)



----------

## 第 2 章

### 为什么要把worker进程数量设置得与CPU核心数量一致呢？

这正是 Nginx 与 Apache 服务器的不同之处。在 Apache 上每个进程在一个时刻只处理一个请求，因此，如果希望 Web 服务器拥有并发处理的请求数更多，就要把 Apache 的进程或线程数设置得更多，通常会达到一台服务器拥有几百个工作进程，这样大量的进程间切换将带来无谓的系统资源消耗。

而Nginx则不然，一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构设计上，不同的worker进程之间处理并发请求时几乎没有同步锁的限制，worker进程通常不会进入睡眠状态，因此，当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心），进程间切换的代价是最小的。

### nginx 配置

- 监听端口

```
listen 127.0.0.1:8000;
listen 127.0.0.1; #注意：不加端口时，默认监听80端口
```

- 主机名称

```
server_name www.testweb.com 、download.testweb.com; # server_name后可以跟多个主机名称
```

### Nginx的反向代理

当客户端发来HTTP请求时，Nginx并不会立刻转发到上游服务器，而是先把用户的请求（包括HTTP包体）完整地接收到Nginx所在服务器的硬盘或者内存中，然后再向上游服务器发起连接，把缓存的客户端请求转发到上游服务器。

比如 Nginx 在接收到完整的客户端请求（如1GB的文件）后，才会与上游服务器建立连接转发请求，由于是内网，所以这个转发过程会执行得很快。这样，一个客户端请求占用上游服务器的连接时间就会非常短，也就是说，**Nginx 的这种反向代理方案主要是为了降低上游服务器的并发压力**。

**Nginx的这种工作方式有什么优缺点呢**？

很明显，缺点是延长了一个请求的处理时间，并增加了用于缓存请求内容的内存和磁盘空间。而优点则是降低了上游服务器的负载，尽量把压力放在 Nginx 服务器上。


### 为什么说 Nginx  这种反向代理工作方式就能降低上游服务器的负载

因为客户端和代理服务器之间的网络环境是比较复杂的，一般走的是 公网 ，网速平均下来可能会比较慢，因此一个请求可能要持续很久才能完成。

就比如一个请求要上传一个 1GB 的文件，nginx 在接收到完整的客户端请求（如1GB的文件）后，才会与上游服务器建立连接转发请求，由于是内网，所以这个转发过程会执行得很快。这样，一个客户端请求占用上游服务器的连接时间就会非常短，也就是说，nginx 的这种反向代理方案主要是为了降低上游服务器的并发压力。

## 第 3 章

### HTTP 模块是如何处理用户请求

worker 进程会在回一个 for 循环语句里反复调用事件模块检测网络事件，当事件模块检测到某个客户端发起的 TCP 请求时（也就是接受到SYN包），将会为它建立 TCP 连接，成功建立连接后根据 nginx.conf 文件中的配置会叫给 HTTP 框架处理。

HTTP 框架会试图接收完整的 HTTP 头部，并在接收完整的 HTTP 头部后就请求分发到具体的 HTTP 模块中处理。比如说根据请求的 URI 和 nginx.conf 里 location 配置项的匹配度来决定如何分发。

HTTP 模块在处理请求结束时，大多会向客户端发送响应，此时会自动地依次调用所有的 HTTP 过滤模块，每个过滤模块可以根据配置文件决定自己的行为，

例如，gzip 过滤模块根据配置文件中的 gzip on|off 来决定是否压缩响应。 HTTP 处理模块在返回时会将控制权交给 HTTP 框架，如果在返回前设置了 subrequest ，那么 HTTP 框架还会继续异步地调用合适的 HTTP 模块处理子请求。

### ngx_list_t 数据结构

```c
typedef struct ngx_list_part_s ngx_list_part_t ;
struct ngx_list_part_s {        //链表节点结构
     void              * elts ;    //指向该节点实际的数据区(该数据区中可以存放nalloc个大小为size的元素)
     ngx_uint_t         nelts ;    //实际存放的元素个数
     ngx_list_part_t  * next ;    //指向下一个节点
} ;
typedef struct {                //链表头结构
     ngx_list_part_t  * last ;    //指向链表最后一个节点(part)
     ngx_list_part_t   part ;    //链表头中包含的第一个节点(part)
     size_t             size ;    //每个元素大小
     ngx_uint_t         nalloc ; //链表所含空间个数，即实际分配的小空间的个数
     ngx_pool_t       * pool ;    //该链表节点空间在此内存池中分配
} ngx_list_t ;
```

ngx_list_t 可以理解为是一个链表容器，以为每个链表元素 ngx_list_part_t 又是一个数组，拥有连续的内存，它既依赖 ngx_list_t 里的 size 和 nalloc 表示数据的容量，同时又依赖每个 ngx_list_part_t 成员中 nelts 来表示数组当前已使用了多少容量。

#### ngx_list_t 这种数据结构设计有什么优势

因为链表中存储的元素是灵活的，它可以是任何一种数据结构

还有链表中的元素须要占用的内存由 ngx_list_t 管理，它已经通过数组分配好了。

小块的内存如果直接用链表访问效率会标比较低，使用数组通过偏移量来直接访问内存就会高效很多。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ngx_list_t.1my0hxp46kqo.png)

我们可以使用 ngx_list_create 来创建新的链表，可以使用 ngx_list_init 来初始化一个已有的链表

