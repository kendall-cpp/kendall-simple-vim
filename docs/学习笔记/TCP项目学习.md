

- [线程池专题](#线程池专题)
  - [为什么引入线程池](#为什么引入线程池)
  - [线程的回收](#线程的回收)
- [数据发送过程](#数据发送过程)
  - [GDB 调试](#gdb-调试)
- [服务器安全](#服务器安全)
  - [心跳包概念](#心跳包概念)
  - [处理不发心跳包的客户端](#处理不发心跳包的客户端)
  - [控制客户端连入数，黑客攻击防范以及及畸形包应对](#控制客户端连入数黑客攻击防范以及及畸形包应对)
- [超负荷安全处理，压力测试](#超负荷安全处理压力测试)
  - [惊群的解决](#惊群的解决)

-----

## 线程池专题

用线程来解决客户端发送过来的数据包，在项目中也就是在 worker 中处理。「使用多线程处理业务逻辑」。

> 在往消息队列中发送消息的时候，首先是主线程把消息送入消息队列，也就是送入完整的数据包，多个线程从消息队列中取消息，但是需要保证只有一个线程能够成功取到消息。因此需要设置互斥技术。使用互斥量。

这里需要查看 Linux 线程函数的使用

### 为什么引入线程池

> 有一个循环语句，可以循环回来等待新任务

- 事先创建好线程，避免动态创建线程，提高程序的稳定性。

### 线程的回收

## 数据发送过程

当请求被处理之后，往往就需要往客户端发送数据，那么当 socket 可写的时候，会出发 socket 可写事件，我们得到了这个可写事件就可以发送数据了。

> 什么叫 socket 可写

每一个tcp连接（socket），服务器端都会对应一个接收缓冲区和一个发送缓冲区。发送缓冲区缺省大小一般是十几K，接收缓冲区大概有几十K。`setsocketopt()` 设置大小。

当调用 `send`，`write` 来发送数据，实际上是把数据放到了**发送缓冲区**。内核尝试往客户端发送数据。当客户端 recv 或者 read 收到数据并且告诉服务器收到之后。服务端才会从发送缓冲区干掉这些已经确认的数据。然后服务器可以再次往发送缓冲区里面写。所以客户段需要快速 read 走数据，要是网卡陈旧，接收数据慢，发送端缓冲区满的话，服务器再调用 send ，write 就会返回一个错误：`EAGAIN...` 示意服务器等一会重发。

应对方案：

1）、最普遍的解决方案：需要向socket写数据的时候，再加入写事件到 epoll 对象中。等待可写事件，操作系统会通知，此时可以调用 `write/send发` 送数据，当发送数据完毕后，把 `socket` 的写事件通知从红黑树中移除。缺点在于：即使发送很少的数据，也需要把事件通知加入到红黑树。写完毕后还要干掉。对效率有一定的影响。

2）、改进方案：开始不把写事件通知加入到 `epoll` ，当需要写数据的时候，直接调用 `write` 直接发送，如果返回了 `EAGAIN` ，此时再把写事件通知加入到 `epoll` 。此时就变成了在 `epoll` 驱动下写数据，等全部数据发送完毕之后，再把写事件通知痛 `epoll` 中干掉。

优点：数据不多的时候可以避免 `epoll` 红黑树中写事件的增加或者删除。

### GDB 调试

设置了 socket 写事件放到 epoll 中之后，水平触发模式下，当 socket 可写的时候，会触发 socket 可写事件，意味着只要发送缓冲区未满，问题在于就会不停的触发可写事件。

当不停的触发可写事件的时候，如果客户端再次发送注册事件过来，此时 worker 进程 down 掉了。因为第二次调用事件处理时又加了可写事件进 epoll 对象，这就造成了重复，导致 worker 进程崩溃。怎么调试呢？

gdb 调试，需要编译时需要带个 `-g` 选项编译，尽可能使用 root 权限 su。

当前目录开始执行：`gdb nginx`

gdb 缺省调试主进程，7.0以上版本可以调试子进程。gdb -v 看版本。

为了让 gdb 进行多进程调试，要设置一下 `follow-fork-mode` 选项，这个是调试多进程的开关。

赋值可以是 `parent/child` ，设置成 `child` 调试子进程。

查看 `follow-fork-mode` 当前值：gdb 命令行输入：`show follow-fork-mode`

输入：`set follow-fork-mode child` 来设置  `child`

还有一个 `detach-on-fork` 选项 ,默认是 on，表示只调试父子进程其中的一个，由上一个选项决定调试哪一个进程。如果为 off，那么父子进程都可以调试。调试其中一个，另外一个进程就会被暂停，如果 `follow-fork-mode` 为 `parent` ，那么 `fork` 出来的子进程并不运行，暂停。

```
设断点：b logic/ngx_c_slogic.cpp:198
运行到断点：run
发包，运行到断点停下，
打印变量值：p xxx
继续运行：c
就进入不断的触发可写事件。
再一次发包，worker 进程进入崩溃，gdb 打印段错误信息。就可以定位到段错误的行。
  （this->*(c->rhandler))(c)
```


----

## 服务器安全

### 心跳包概念

心跳包其实就是一个数据包，一般每隔几十秒，由客户端主动发送给服务器，服务器收到之后，一般会给服务器返回一个心跳包。这样反复来回。

tcp 建立好连接之后，如果客户端不给服务端发送心跳包，比如说约定好，30 秒客户端需要给服务器发送一个心跳包，如果不发送，服务器在 30*3 时间之后就会主动关闭 socket 连接。


> 为什么要引入心跳包

- 常规客户端关闭，服务器能够感知到
- 有一种特殊情况， 连接断开 客户端/服务器 都感知不到

心跳包不需要包体，只需要包头，

### 处理不发心跳包的客户端

超过 20 * 3 + 10 秒，仍然没有心跳包，那么服务端就把 tcp 断开。


使用定时器队列，nginx 中使用的是 红黑树，本项目中使用的是 multimap （k-v）来做定时器。
> 查定时器的设置
> [参考](https://blog.csdn.net/haolipengzhanshen/article/details/80502994)


### 控制客户端连入数，黑客攻击防范以及及畸形包应对

使用 epoll 支持高并发，

如果允许客户端无限连入的话，那么服务器肯定会奔溃，如果用户连接数量超过设定的连接数 1024，就拒绝连接。


## 超负荷安全处理，压力测试

- 太多数据包处理不过来，或者积压太多数据包没来得及发出去。

思路：

- 限速

对 epoll 技术进行限速，

### 惊群的解决

一个 master 进程，四个 worker 进程。
