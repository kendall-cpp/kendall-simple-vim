> 参考：https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html

------

## 内存模型

### 堆

寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从`0x1000`到`0x8000`，起始地址是较小的那个地址，结束地址是较大的那个地址。

![](https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012208.png)


程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用`malloc`命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到`10`个字节内存，那么从起始地址`0x1000`开始给他分配，一直分配到地址0x100A，如果再要求得到`22`个字节，那么就分配到`0x1020`。

![](https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png)

这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

### 栈

除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。

![](https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png)

```cpp
int main() {
   int a = 2;
   int b = 3;
}
```

上面代码中，系统开始执行`main`函数时，会为它在内存里面建立一个帧（`frame`），所有main的内部变量（比如 a 和 b ）都保存在这个帧里面。`main`函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。

> 如果函数内部调用了其他函数，会发生什么情况？

```cpp
int main() {
   int a = 2;
   int b = 3;
   return add_a_and_b(a, b);
}
```

上面代码中，`main`函数内部调用了`add_a_and_b`函数。执行到这一行的时候，系统也会为a`dd_a_and_b`新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：`main`和`add_a_and_b`。一般来说，调用栈有多少层，就有多少帧。

![](https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png)

等到 add_a_and_b 运行结束，它的帧就会被回收，系统会回到函数 main 刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。

Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是`0x8000`，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到`0x7FB0`。

![](https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png)

## CPU 指令

```c
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
```

gcc 将这个程序转成汇编语言。

上面的命令执行以后，会生成一个文本文件`example.s`，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。

`example.s`经过简化以后，大概是下面的样子。

```
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
```

可以看到，原程序的两个函数`add_a_and_b`和`main`，对应两个标签`_add_a_and_b`和`_main`。每个标签里面是该函数所转成的 CPU 运行流程。

每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。

```
push   %ebx
```

这一行里面，push 是 CPU 指令，`%ebx`是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。

### push 指令

根据约定，程序从`_main`标签开始执行，这时会在 `Stack` 上为 `main` 建立一个帧，并将 `Stack` 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 `ESP` 寄存器所保存的地址。

然后，开始执行第一行代码。

```c
push   3
```

`push` 指令用于将运算子放入 `Stack` ，这里就是将 3 写入 `main` 这个帧。

虽然看上去很简单，push 指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去 4 个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4 个字节则是因为3的类型是 int，占用 4 个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。

```c
push   2
```

第二行也是一样，push指令将2写入`main`这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）

![](https://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png)

### mov 指令

mov 指令用于将一个值写入某个寄存器

```
mov    %eax, [%esp+8] 
```

这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。

下一行代码也是干同样的事情。

```
mov    %ebx, [%esp+12] 
```

上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。

### add 指令

add 指令用于将两个运算子相加，并将结果写入第一个运算子

```
add    %eax, %ebx
```

上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果 5，再将这个结果写入第一个运算子 EAX 寄存器。

### pop 指令

pop 指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。

```
pop    %ebx
```

上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。

> 注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节

### ret 指令

ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。

```
ret
```

可以看到，该指令没有运算子。

随着`add_a_and_b`函数终止执行，系统就回到刚才`main`函数中断的地方，继续往下执行

```
add    %esp, 8 
```

上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。

```
ret
```

最后，main 函数运行结束，ret 指令退出程序执行







