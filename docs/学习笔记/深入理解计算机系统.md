
- [第三章，程序的机器级表示](#第三章程序的机器级表示)
  - [程序编码](#程序编码)
  - [机器级代码](#机器级代码)
  - [操作数指示符](#操作数指示符)
  - [压入栈和弹出栈数据](#压入栈和弹出栈数据)
  - [加载有效地址](#加载有效地址)

---

## 第三章，程序的机器级表示

首先我们需要预览 C语言、汇编代码以及机器代码之间的关系

通过下面这张图来看看一个源代码生成可执行程序的过程，下面还将会逐一详细解释

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

简单总结如下：

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将目标文件彼此链接起来


**源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件**


### 程序编码

假如说我们有这么两段 C语言代码

- main.c

```c
#include <stdio.h>
void mulstore(long x,long y,long *dest);

int main() {
    long d;
    mulstore(2,3,&d);
    printf("2 * 3 = %ld\n",d);

    return 0;
}
long mult2(long a,long b) {
    long s = a * b;
    return s;   
}
```

- mstore.c

```c
long mult2(long a,long b);

void mulstore(long x,long y,long *dest) {
    long t = mult2(x,y);
    *dest = t;
}
```

然后通过命令行编译这两个代码

```bash
gcc -Og -o prog main.c  mstore.c
```

- 这里的 gcc 命令值得就是 GCC 编译器
- Og 就是告诉编译器会生成符合原始 C 代码整体结构的机器代码
  - 在实际开发中，有时为了获取更高的性能，可以使用 -O1 或者 -O2 甚至更高的编译优化选项，但是使用较高级别的优化产生的代码容易严重变形，导致产生的机器代码和初始原始代码之间的关系非常难理解，所以为了方便理解，我们可以选择 -Og 这个优化选项。

- `-o` 是指定最终生成文件的文件名

现在回忆一下一开始 helloWorld 那张图，为了方便阅读我这里再次粘贴一次

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

> 这张图是以前画的了，但是这里用的是 main.c 和 mstore.c 两个源文件，具体过程是一样的。

- 首先，GCC 预处理器扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏，经过这一步之后会生成后缀名为 `.i` 的文件

> 这里就是我们面试时经常会被问的 #define 和 const 的区别之一         
> `define`定义的常量是在**预处理阶段**进行替换，而`const`在**编译阶段**才确定它的值。

- 接着，编译器会产生源文件的**汇编代码**，文件名以 `.s` 结尾

```
gcc -Og -S mstore.c -o mstore.s
```

生成的汇编代码如下「已经删除以 `.` 开头的伪指令」

```
_mulstore:      
	pushq	%rbx          ;将寄存器 rbx 的值压入程序栈中进行保存
	movq	%rdx, %rbx    ;将寄存器 rbx 的内容复制到寄存器 rdx 中,这里的 q  表示数据的大小，q--> 字（8字节）
	callq	_mult2        ;函数调用，该函数的返回值会保存在 rax 寄存器中
	movq	%rax, (%rbx)  ;* 号用（） 表示，将寄存器 rax 的值送到内存中保存，内存地址是在 rbx 中
	popq	%rbx          ;恢复寄存器rbx的内容，即从战中弹出数据
	ret
```

> 数据格式说明

```
movb     传送字节          1字节
movw     传送字            2字节
movl     传送双字          4字节
movq     传送四字          8字节
```

- 接着编译器又会将汇编代码转化成二进制**目标代码**文件 `.o`，注意目标代码中包含所有指令的二进制表示，但是**还没有填入全局值的地址**

```
gcc -Og -c mstore.c -o mstore.o
```

- 最后，链接器将两个目标代码文件 与 实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 prog

### 机器级代码

计算机系统利用了更加简单的抽象模型来隐藏实现的细节，其中有两种抽象非常重要：

- 指令集体系结构（ISA）：定义了处理器状态，指令的格式，以及每条指令对状态的影响。「注意，指令并不是一条一条执行的，而是并发执行的」

- 机器级程序使用的内存地址是**虚拟地址**：将多个硬件存储器和操作系统软件组合起来

> 程序计数器（PC),「在 x86-64 中用 %rip 表示」代表下一条指令的地址位置


### 操作数指示符

各种操作数可以划分为三种类型：

- 立即数：用来表示常数值，比如：$-577,$0x1F
- 寄存器：它表示某个寄存器的内容，比如：$r_a$ -- 任意寄存器 a；$R[r_a]$ -- 它的值
- 内存引用：它会根据计算出来的地址（有效地址）访问某个内存位置

> mov 指令中源操作数指定的值就是一个立即数，存储在寄存器中或内存中      
> 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址      
> 注意：源操作数和目的操作数不能都为内存地址，如果想要将一个内存地址的值拷贝到另一个内存地址中，需要两条指令来完成
>   - 第一条指令将源资源加载到寄存器中
>   - 第二条指令将该寄存器值谢写入目的位置

### 压入栈和弹出栈数据

注意栈是向低地址增长的，所以压栈是减小栈指针（寄存器%rsp) 的值，并将数据存放到内存中。而出站是从内存中读数据，并增加栈指针的值

### 加载有效地址

```
leap S,D    ;D<-- &S 加载有效地址
```

加载有效地址指令 leap 实际上是 movq 指令的变形，它的指令形式是从 内存数据 到 寄存器，但是实际上它根本就没有引用内存。该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。







