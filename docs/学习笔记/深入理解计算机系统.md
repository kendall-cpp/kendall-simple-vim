
- [第三章，程序的机器级表示](#第三章程序的机器级表示)
  - [程序编码](#程序编码)
  - [机器级代码](#机器级代码)
  - [操作数指示符](#操作数指示符)
  - [压入栈和弹出栈数据](#压入栈和弹出栈数据)
  - [加载有效地址](#加载有效地址)
- [第5章 优化程序性能](#第5章-优化程序性能)
  - [从编译器的角度](#从编译器的角度)
  - [减少函数调用的次数](#减少函数调用的次数)
  - [使用循环展开](#使用循环展开)
- [第10章](#第10章)

---

## 第三章，程序的机器级表示

首先我们需要预览 C语言、汇编代码以及机器代码之间的关系

通过下面这张图来看看一个源代码生成可执行程序的过程，下面还将会逐一详细解释

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

简单总结如下：

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将目标文件彼此链接起来


**源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件**


### 程序编码

假如说我们有这么两段 C语言代码

- main.c

```c
#include <stdio.h>
void mulstore(long x,long y,long *dest);

int main() {
    long d;
    mulstore(2,3,&d);
    printf("2 * 3 = %ld\n",d);

    return 0;
}
long mult2(long a,long b) {
    long s = a * b;
    return s;   
}
```

- mstore.c

```c
long mult2(long a,long b);

void mulstore(long x,long y,long *dest) {
    long t = mult2(x,y);
    *dest = t;
}
```

然后通过命令行编译这两个代码

```bash
gcc -Og -o prog main.c  mstore.c
```

- 这里的 gcc 命令值得就是 GCC 编译器
- Og 就是告诉编译器会生成符合原始 C 代码整体结构的机器代码
  - 在实际开发中，有时为了获取更高的性能，可以使用 -O1 或者 -O2 甚至更高的编译优化选项，但是使用较高级别的优化产生的代码容易严重变形，导致产生的机器代码和初始原始代码之间的关系非常难理解，所以为了方便理解，我们可以选择 -Og 这个优化选项。

- `-o` 是指定最终生成文件的文件名

现在回忆一下一开始 helloWorld 那张图，为了方便阅读我这里再次粘贴一次

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

> 这张图是以前画的了，但是这里用的是 main.c 和 mstore.c 两个源文件，具体过程是一样的。

- 首先，GCC 预处理器扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏，经过这一步之后会生成后缀名为 `.i` 的文件

> 这里就是我们面试时经常会被问的 #define 和 const 的区别之一         
> `define`定义的常量是在**预处理阶段**进行替换，而`const`在**编译阶段**才确定它的值。

- 接着，编译器会产生源文件的**汇编代码**，文件名以 `.s` 结尾

```
gcc -Og -S mstore.c -o mstore.s
```

生成的汇编代码如下「已经删除以 `.` 开头的伪指令」

```
_mulstore:      
	pushq	%rbx          ;将寄存器 rbx 的值压入程序栈中进行保存
	movq	%rdx, %rbx    ;将寄存器 rbx 的内容复制到寄存器 rdx 中,这里的 q  表示数据的大小，q--> 字（8字节）
	callq	_mult2        ;函数调用，该函数的返回值会保存在 rax 寄存器中
	movq	%rax, (%rbx)  ;* 号用（） 表示，将寄存器 rax 的值送到内存中保存，内存地址是在 rbx 中
	popq	%rbx          ;恢复寄存器rbx的内容，即从战中弹出数据
	ret
```

> 数据格式说明

```
movb     传送字节          1字节
movw     传送字            2字节
movl     传送双字          4字节
movq     传送四字          8字节
```

- 接着编译器又会将汇编代码转化成二进制**目标代码**文件 `.o`，注意目标代码中包含所有指令的二进制表示，但是**还没有填入全局值的地址**

```
gcc -Og -c mstore.c -o mstore.o
```

- 最后，链接器将两个目标代码文件 与 实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 prog

### 机器级代码

计算机系统利用了更加简单的抽象模型来隐藏实现的细节，其中有两种抽象非常重要：

- 指令集体系结构（ISA）：定义了处理器状态，指令的格式，以及每条指令对状态的影响。「注意，指令并不是一条一条执行的，而是并发执行的」

- 机器级程序使用的内存地址是**虚拟地址**：将多个硬件存储器和操作系统软件组合起来

> 程序计数器（PC),「在 x86-64 中用 %rip 表示」代表下一条指令的地址位置


### 操作数指示符

各种操作数可以划分为三种类型：

- 立即数：用来表示常数值，比如：$-577,$0x1F
- 寄存器：它表示某个寄存器的内容，比如：$r_a$ -- 任意寄存器 a；$R[r_a]$ -- 它的值
- 内存引用：它会根据计算出来的地址（有效地址）访问某个内存位置

> mov 指令中源操作数指定的值就是一个立即数，存储在寄存器中或内存中      
> 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址      
> 注意：源操作数和目的操作数不能都为内存地址，如果想要将一个内存地址的值拷贝到另一个内存地址中，需要两条指令来完成
>   - 第一条指令将源资源加载到寄存器中
>   - 第二条指令将该寄存器值谢写入目的位置

### 压入栈和弹出栈数据

注意栈是向低地址增长的，所以压栈是减小栈指针（寄存器%rsp) 的值，并将数据存放到内存中。而出站是从内存中读数据，并增加栈指针的值

### 加载有效地址

```
leap S,D    ;D<-- &S 加载有效地址
```

加载有效地址指令 leap 实际上是 movq 指令的变形，它的指令形式是从 内存数据 到 寄存器，但是实际上它根本就没有引用内存。该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

------

## 第5章 优化程序性能

### 从编译器的角度

> 需要考虑各种不安全的情况

```c
void func1(int *ap,int *bp) {
  *ap += *bp;
  *ap += *bp;
}

void func2(int *ap,int *bp) {
  *ap += 2* *bp;
}
```

这两个函数的行为似乎是相同的，都是将 bp 指向位置的值两次加到 ap 指向位置，但是他们的效率是不一样的。

- func2 需要 3 次内存引用「读 *ap，读 *bp,写 *ap」
- func1 需要 6 次内存引用「2 次读 *ap，2 次读 *bp,2 次写 *ap」

所以从这方面来讲 func2 的性能比 func1 更高

> 不过还需要考虑 ap 和 bp 是否指向同一位置，如果是同一位置

> func1 *ap 的值增加 4 倍，而 func2 *ap 的值增加 3 倍

所以不能将 func2 作为 func1 的优化版本

还有一种情况

```c
int func1() {
  return f() + f() + f() +f();
}

int func2() {
  return 4 * f();
}
```

表面看这两个函数是一样的，但是 fun2 只调用了一次 f() ,可不可以把 func2 当做fanc1 的优化版本呢？

显然在一些特殊情况下不能

比如 f() 的实现体为

```c
int count = 0;
int f() {
  return count++;
}
```

这时 

- func1 的结果：0+1+2+3 = 6

- func2 的结果：4*0 = 0

----

### 减少函数调用的次数

减少函数调用的次数可以提高性能

比如用局部变量保存 for 循环中函数调用的值

```c
data_t v;
for(int i=0;i< nums.size();++i) {
  data_t val;
  func(v,i,&val);
}
```

可以优化为下面代码，用数组记录函数的地址

```c
data_t v;
int len = nums.size();
data_t *data = get_func_start(v);  //引入一个新的函数保存 func 的起始地址
*data = IDENT;
for(int i=0;i< len;++i) {
  *data = *data + data[i];
}
```

但是消除函数调用程序性能提高并不明显，很多时候还需要考虑内存的读写次数，[分析汇报代码可以看出」 可以使用临时变量来记录循环的结果，循环结束再一次写入内存

```c
data_t temp = IDENT;
for(int i=0;i< len;++i) {
  temp = *data + data[i];
}
data = acc;
```

### 使用循环展开

- 循环展开可以减少与程序结果无关的操作数目
  - 一次循环两次操作，这样整体循环次数就可以减半

```c
for(int i=0;i<limit;i+=2)  //而不是+1
```



-----

##  第10章

一个Linux文件就是一个m个字节的序列，所有I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有输入和输出都被当作对相应文件的读和写来执行。这中将设备优雅的映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，简称Unix I/O， 这使得所有的输入和输出都能以一种统一且一致的方式来执行：

打开文件。一个应用程序通过要求内核打开相应的文件，来告诉它想要访问的 I/O 设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文间的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需要记住这个描述符。Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。

改变当前的文件位置。对于每个打开文件，内核保持着一个文件位置 k，初始为 0。即从文件开头起始的字节编偏移量。读写文件。一个读操作就是从文件复制 n>0 个字节到内存，从当前文件位置 k 开始，然后将 k 增加到k+n。当超过文件字节大小时，读操作会出发一个 end-of-file 的条件，应用程序能检测到这个条件。同理，写操作就时从内存复制 n 个字节到一个文件中。 关闭文件。当应用完成对文件的访问之后，它就通知内核关闭文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述父回复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放他们的内存资源。

https://m.jb51.cc/bash/389757.html

- RIO 无缓冲输入输出函数

[参考](https://blog.csdn.net/df12138/article/details/122272107)

```c
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
```

rio_readn() 函数尝试从 fd 中读取 n 个字符到 usrbuf 中，与 read() 函数相比，它被信号处理函数中断后会再次尝试读取。因此，除了可读字符数小于 n 情况下，该函数可以保证读取 n 个字节。而若提取遇到 EOF ，就返回一个不足值。而 rio_writen() 绝不会返回不足值，对同一个描述符，交错使用 rio_readn 和 rio_writen 是可以的。











