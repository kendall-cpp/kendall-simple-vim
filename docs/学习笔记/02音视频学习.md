



------


## H264解码器的封装

```c
AVCodec ff_h264_decoder = {
    .name                  = "h264",  //avcodec_find_decoder_by_name():根据解码器名字
    .long_name             = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_H264,  //avcodec_find_decoder() 就是通过 id 进行查找的
    .priv_data_size        = sizeof(H264Context),
    .init                  = h264_decode_init,
    .close                 = h264_decode_end,
    .decode                = h264_decode_frame,
    .capabilities          = /*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/ AV_CODEC_CAP_DR1 |
                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |
                             AV_CODEC_CAP_FRAME_THREADS,
    .hw_configs            = (const AVCodecHWConfigInternal*[]) {...};
```

## FFmpeg解码函数

<img src="D:\cppSumWork\kendall-cpp\docs\学习笔记\img\image-20211008194159467.png" alt="image-20211008194159467" style="zoom: 67%;" />

## FFmpeg内存模型

假如现在需要将一个 `Packet1` 的数据拷贝到一个新的 `Packet2` 里面的，可以有两种方式：



\- （1）两个 `Packet` 的`buf`引用的是同一数据缓存空间。这时需要注意的是数据缓存空间的释放问题，（浅拷贝）



![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型01.fx9uh9zlvgg.png)



\- （2）两个`Packet`的`buf`引用不同的数据缓存空间。每个`Packet`都有数据缓存空间的copy（深拷贝）



![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型02.5bp5sxiy4h40.png)



我们主要是基于第一种方式进行介绍。



对于多个AVPacket共享同一个缓存空间，FFmpeg使用的引用计数的机制来管理

- `AVBuffer`是`FFmpeg`中的缓冲区，一开始时`AVBuffer`的引用计数(`refcount`)初始化为 0

- 当有新的`Packet`引用共享的缓存空间时，就将引用计数再 +1

- 当`Packet`释放掉对`AVBuffer`这块共享缓存空间的引用时,将引用计数 -1

- 只有当`refcount`为 0 的时候，才会释放掉缓存空间`AVBuffer`



> FFmpeg中av_init_packet()和av_packet_alloc()以及av_new_packet()三者的区别以及用法

- av_init_packet：仅仅是把 pkt 的参数设为默认值，要求pkt的内存已经分配好了，如果为 NULL，则此处会崩溃，

- av_packet_alloc：分配一个默认大小的内存

```c
AVPacket *av_packet_alloc(void)
{
    AVPacket *pkt = av_mallocz(sizeof(AVPacket));
    if (!pkt)
        return pkt;

    av_packet_unref(pkt);// 这里会调用 av_init_packet

    return pkt;
}
```

`av_packet_alloc` 返回的是一个AVPacket的一个指针，内部为这个指针分配了内存，也就是说你可以为一个NULL的 AVPacket 指针分配内存

av_packet_unref: 内部还是调用的av_init_packet,相当于先分配内存再设为默认值

- av_new_packet: 为 pkt 分配一个指定大小的内存

```c
int av_new_packet(AVPacket *pkt, int size)
{
    AVBufferRef *buf = NULL;
    int ret = packet_alloc(&buf, size);
    if (ret < 0)
        return ret;

    av_init_packet(pkt);
    pkt->buf      = buf;
    pkt->data     = buf->data;
    pkt->size     = size;

    return 0;
}
```

<img src="https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/av_new_packet.5cs91ucm9fk0.png" style="zoom:67%;" />

