
----

## FFmpeg 学习

### ffmepg 内存模型

av_packet_alloc 和 av_packet_free 需要配对使用，否则会造成内存泄漏

其中 av_packet_alloc 是开辟 AVPacket 内存空间，av_packet_free 是释放空间，具体可以参考源码

- av_packet_alloc

```cpp
AVPacket *av_packet_alloc(void)
{
    AVPacket *pkt = av_mallocz(sizeof(AVPacket));
    if (!pkt)
        return pkt;

    av_packet_unref(pkt);

    return pkt;
}
```

- av_packet_free

```cpp
void av_packet_free(AVPacket **pkt)
{
    if (!pkt || !*pkt)
        return;

    av_packet_unref(*pkt);
    av_freep(pkt);
}
```

代码测试

- **测试1**

```cpp
void av_packet_test1()
{
    AVPacket * pkt = NULL;
    int ret = 0;

    //分配一个AVPacket
    pkt = av_packet_alloc();
    //给AVPacket分配内存，这里引用计数将会+1
//    int av_new_packet(AVPacket *pkt, int size);
    ret = av_new_packet(pkt,MEM_ITEM_SIZE);  //始化字段，还为data分配了存储空间 如果成功就返回0
    /*
         void * memccpy(void *dest, const void * src, int c, size_t n);
        函数说明：memccpy()用来拷贝src 所指的内存内容前n 个字节到dest 所指的地址上。
     * */
    memccpy(pkt->data,(void *)&av_packet_test1,1,MEM_ITEM_SIZE);

    //减少引用计数，只有当引用计数为0时，才调用av_packet_free()时释放data的缓存。
    av_packet_unref(pkt);
    //释放掉packet，如果packet被还引用计数，它将首先被取消引用。
    av_packet_free(&pkt);
}
```

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型05.1k5ofyi9o84g.png)

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型05.1k5ofyi9o84g.png)

通过调试可以发现， 在新建`packet`的时候`buf`是空的，只有当计数器置为`1`的时候才会给`buf`分配内存。当执行`av_packet_unref`后`pkt`的`buf`就会置空，此时计数器 -1.

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型07.2ugh70xlnwm0.png)

此外。通过查看源码可以发现其实` av_packet_free`内部已经调用了`av_packet_unref`，所以程序中第 28 行可以不调用，但是如果重复调用`av_packet_unref`也并不会出问题，`av_packet_unref`内部的`av_buffer_unref`函数中对`buf`进行了判断，如果`buf`已经为空就会直接`return`回去。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型08.7gcm4wbh5o00.png)

- **测试2**

```c
void av_packet_test2() {
    AVPacket pkt = NULL;
    int ret = 0;
    pkt = av_packet_alloc();
    ret = av_new_packet(pkt,MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
//    av_init_packet();  // 如果在 free 前还调用 av_init_packet 会造成释放为空的 buf ，存在累内存安全为题
    av_packet_free();
}
```








