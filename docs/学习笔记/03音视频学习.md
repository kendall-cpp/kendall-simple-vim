
----

https://www.sohu.com/a/305914050_134613

https://zhuanlan.zhihu.com/p/82854047

https://mp.weixin.qq.com/s?__biz=MzI0NTMxMjA1MQ==&mid=2247483684&idx=1&sn=dce8821fbf385a808af96a9bd2f85c45&chksm=e9513e78de26b76e8bb7d310e61a823bb81cd7ca34528780253e6830c80d56963befcdf5324f&scene=21#wechat_redirect

## FFmpeg 学习

### ffmepg 内存模型

av_packet_alloc 和 av_packet_free 需要配对使用，否则会造成内存泄漏

其中 av_packet_alloc 是开辟 AVPacket 内存空间，av_packet_free 是释放空间，具体可以参考源码

- av_packet_alloc

```cpp
AVPacket *av_packet_alloc(void)
{
    AVPacket *pkt = av_mallocz(sizeof(AVPacket));
    if (!pkt)
        return pkt;

    av_packet_unref(pkt);

    return pkt;
}
```

- av_packet_free

```cpp
void av_packet_free(AVPacket **pkt)
{
    if (!pkt || !*pkt)
        return;

    av_packet_unref(*pkt);
    av_freep(pkt);
}
```

代码测试

- **测试1**

```cpp
void av_packet_test1()
{
    AVPacket * pkt = NULL;
    int ret = 0;

    //分配一个AVPacket
    pkt = av_packet_alloc();
    //给AVPacket分配内存，这里引用计数将会+1
//    int av_new_packet(AVPacket *pkt, int size);
    ret = av_new_packet(pkt,MEM_ITEM_SIZE);  //始化字段，还为data分配了存储空间 如果成功就返回0
    /*
         void * memccpy(void *dest, const void * src, int c, size_t n);
        函数说明：memccpy()用来拷贝src 所指的内存内容前n 个字节到dest 所指的地址上。
     * */
    memccpy(pkt->data,(void *)&av_packet_test1,1,MEM_ITEM_SIZE);

    //减少引用计数，只有当引用计数为0时，才调用av_packet_free()时释放data的缓存。
    av_packet_unref(pkt);
    //释放掉packet，如果packet被还引用计数，它将首先被取消引用。
    av_packet_free(&pkt);
}
```

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型05.1k5ofyi9o84g.png)

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型05.1k5ofyi9o84g.png)

通过调试可以发现， 在新建`packet`的时候`buf`是空的，只有当计数器置为`1`的时候才会给`buf`分配内存。当执行`av_packet_unref`后`pkt`的`buf`就会置空，此时计数器 -1.

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型07.2ugh70xlnwm0.png)

此外。通过查看源码可以发现其实` av_packet_free`内部已经调用了`av_packet_unref`，所以程序中第 28 行可以不调用，但是如果重复调用`av_packet_unref`也并不会出问题，`av_packet_unref`内部的`av_buffer_unref`函数中对`buf`进行了判断，如果`buf`已经为空就会直接`return`回去。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg内存模型08.7gcm4wbh5o00.png)

- **测试2**

```c
void av_packet_test2() {
    AVPacket pkt = NULL;
    int ret = 0;
    pkt = av_packet_alloc();
    ret = av_new_packet(pkt,MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
//    av_init_packet();  // 如果在 free 前还调用 av_init_packet 会造成释放为空的 buf ，存在累内存安全问题
    av_packet_free();
}
```


## 开发录音功能

查看音频设备

```
./ffmpeg.exe -f dshow -list_devices true -i dunmy
```

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <cstdio>
#include <QFile>
#include <qdebug.h>

extern "C" {
// 设备相关API
#include <libavdevice/avdevice.h>
// 格式相关API
#include <libavformat/avformat.h>
// 工具相关API（比如错误处理）
#include <libavutil/avutil.h>
// 编码相关API
#include <libavcodec/avcodec.h>
}

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_audioButton_clicked()
{
    // 获取输入格式对象
    const char *fmtName = "dshow";
    AVInputFormat *fmt =  av_find_input_format(fmtName);
    if(!fmt) {
        printf("获取输入格式失败：&s",fmtName);
    }

    //格式上下文 （将来可以利用上下文操作设备
    AVFormatContext *ctx = nullptr;
    const char *devicename = "audio=麦克风阵列 (2- Realtek High Definition Audio)";
//    AVDictionary *options = nullptr;
    //打开设备
    int ret = avformat_open_input(&ctx,devicename,fmt,nullptr);
    if(ret < 0) {
        char errorbuf[1024];
        av_strerror(ret,errorbuf,sizeof(errorbuf));
        printf("打开设备失败:%s\n",errorbuf);
        return;
    }
    printf("%p\n",ctx); //打印上下文地址

       //文件名
    const char *filename = "D:/lingshengYinShiPin/out.pcm";
    QFile file(filename);

     //以只写的方式打开文件，如果文件不存在就创建文件，存在就删除重新创建
    if(!file.open(QIODevice::WriteOnly )) {
        qDebug() << "文件打开失败";
        avformat_close_input(&ctx);
        return;
    }

    //采集传输
    int count = 50;
    
    //数据包
    AVPacket pkt;
    //不断采集数据
    while( count-- >0 && av_read_frame(ctx,&pkt) == 0) {
        file.write((const char*)pkt.data,pkt.size);
    }
    //释放资源
    //关闭文件
    file.close();
    //关闭设备
    avformat_close_input(&ctx);

}
```


## 通过 ffmpeg 实现录音的步骤

![](https://img2020.cnblogs.com/blog/497279/202103/497279-20210319195750551-1109534799.png)


使用 ffplay 播放 pcm

```
ffplay.exe -ar 44100 -ac 2 -f s16le out.pcm
```

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <cstdio>
#include <QFile>
#include <qdebug.h>
#include <QThread>

extern "C" {
// 设备相关API
#include <libavdevice/avdevice.h>
// 格式相关API
#include <libavformat/avformat.h>
// 工具相关API（比如错误处理）
#include <libavutil/avutil.h>
// 编码相关API
#include <libavcodec/avcodec.h>
}

#ifdef Q_OS_WIN
    #define FMT_NAME  "dshow"
    #define DEVICE_NAME  "audio=麦克风阵列 (2- Realtek High Definition Audio)"
    // PCM 文件名
    #define FILENAME "D:/lingshengYinShiPin/out.pcm"
#else
    #define FMT_NAME  "avfoundation"
    #define DEVICE_NAME ":0"
    #define FILENAME "~/out.pcm"
#endif

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    qDebug() << "MainWindow " << QThread::currentThread();

}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_audioButton_clicked()
{
    // 获取输入格式对象
    AVInputFormat *fmt =  av_find_input_format(FMT_NAME);
    if(!fmt) {
        qDebug() << "输入格式失败:" << FMT_NAME;
    }

    //格式上下文 （将来可以利用上下文操作设备
    AVFormatContext *ctx = nullptr;
    const char *devicename = DEVICE_NAME;
//    AVDictionary *options = nullptr;
    //打开设备
    int ret = avformat_open_input(&ctx,devicename,fmt,nullptr);
    if(ret < 0) {
        char errorbuf[1024];
        av_strerror(ret,errorbuf,sizeof(errorbuf));
        qDebug() << "打开设备失败";
        return;
    }
    qDebug() << ctx ;  //打印上下文地址

       //文件名
    const char *filename = FILENAME;
    QFile file(filename);

     //以只写的方式打开文件，如果文件不存在就创建文件，存在就删除重新创建
    if(!file.open(QIODevice::WriteOnly )) {
        qDebug() << "文件打开失败";
        avformat_close_input(&ctx);
        return;
    }

    //采集传输
    int count = 50;

    //数据包
    AVPacket pkt;
    //不断采集数据
    while( count-- >0 && av_read_frame(ctx,&pkt) == 0) {
        file.write((const char*)pkt.data,pkt.size);
    }
    //释放资源
    //关闭文件
    file.close();
    //关闭设备
    avformat_close_input(&ctx);

}
```

main 

```cpp
#include "mainwindow.h"

#include <QApplication>
#include <qdebug.h>
#include <QThread>

extern "C" {
// 设备相关API
#include <libavdevice/avdevice.h>
// 格式相关API
#include <libavformat/avformat.h>
// 工具相关API（比如错误处理）
#include <libavutil/avutil.h>
// 编码相关API
#include <libavcodec/avcodec.h>
}

int main(int argc, char *argv[])
{

    qDebug() << "main:" << QThread::currentThread();

    //注册设备 只候注册一次
    avdevice_register_all();

    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
```

### 多线实现录音

audioThread.cpp

```cpp
#include "audiothread.h"

extern "C" {
// 设备相关API
#include <libavdevice/avdevice.h>
// 格式相关API
#include <libavformat/avformat.h>
// 工具相关API（比如错误处理）
#include <libavutil/avutil.h>
// 编码相关API
#include <libavcodec/avcodec.h>
}

AudioThread::AudioThread(QObject *parent) : QThread(parent)
{

}
// 当线程启动的时候（start），就会自动调用run函数
// run函数中的代码是在子线程中执行的
// 耗时操作应该放在run函数中
void AudioThread::run() {
    qDebug() << "开始执行了......" ;
}
```

mainwindow.cpp

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <cstdio>

#include <audiothread.h>



#ifdef Q_OS_WIN
    #define FMT_NAME  "dshow"
    #define DEVICE_NAME  "audio=麦克风阵列 (2- Realtek High Definition Audio)"
    // PCM 文件名
    #define FILENAME "D:/lingshengYinShiPin/out.pcm"
#else
    #define FMT_NAME  "avfoundation"
    #define DEVICE_NAME ":0"
    #define FILENAME "~/out.pcm"
#endif

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_audioButton_clicked()
{
    //开启子进程
    AudioThread *audioThread = new AudioThread(this);
    audioThread->start();

    // 获取输入格式对象
    AVInputFormat *fmt =  av_find_input_format(FMT_NAME); 
    if(!fmt) {
        qDebug() << "输入格式失败:" << FMT_NAME;
    }

    //格式上下文 （将来可以利用上下文操作设备
    AVFormatContext *ctx = nullptr;
    const char *devicename = DEVICE_NAME;
//    AVDictionary *options = nullptr;
    //打开设备
    int ret = avformat_open_input(&ctx,devicename,fmt,nullptr);
    if(ret < 0) {
        char errorbuf[1024];
        av_strerror(ret,errorbuf,sizeof(errorbuf));
        qDebug() << "打开设备失败";
        return;
    }

       //文件名
    const char *filename = FILENAME;
    QFile file(filename);

     //以只写的方式打开文件，如果文件不存在就创建文件，存在就删除重新创建
    if(!file.open(QIODevice::WriteOnly )) {
        qDebug() << "文件打开失败";
        avformat_close_input(&ctx);
        return;
    }

    //采集传输
    int count = 50;

    //数据包
    AVPacket pkt;
    //不断采集数据
    while( count-- >0 && av_read_frame(ctx,&pkt) == 0) {
        file.write((const char*)pkt.data,pkt.size);
    }
    //释放资源
    //关闭文件
    file.close();
    //关闭设备
    avformat_close_input(&ctx);

}
```

将所有代码放在 run 函数中执行，mainwindow 执行 start 的时候会自动执行 run 函数

```cpp
#include "audiothread.h"
#include <qdebug.h>
#include <QFile>

extern "C" {
// 设备相关API
#include <libavdevice/avdevice.h>
// 格式相关API
#include <libavformat/avformat.h>
// 工具相关API（比如错误处理）
#include <libavutil/avutil.h>
// 编码相关API
#include <libavcodec/avcodec.h>
}

#ifdef Q_OS_WIN
    #define FMT_NAME  "dshow"
    #define DEVICE_NAME  "audio=麦克风阵列 (2- Realtek High Definition Audio)"
    // PCM 文件名
    #define FILENAME "D:/lingshengYinShiPin/out.pcm"
#else
    #define FMT_NAME  "avfoundation"
    #define DEVICE_NAME ":0"
    #define FILENAME "~/out.pcm"
#endif


AudioThread::AudioThread(QObject *parent) : QThread(parent)
{

}
//析构函数
AudioThread::~AudioThread() {
    qDebug() << this << "析构，内存回收";
}

// 当线程启动的时候（start），就会自动调用run函数
// run函数中的代码是在子线程中执行的
// 耗时操作应该放在run函数中
void AudioThread::run() {


    // 获取输入格式对象
    AVInputFormat *fmt =  av_find_input_format(FMT_NAME);
    if(!fmt) {
        qDebug() << "输入格式失败:" << FMT_NAME;
    }

    //格式上下文 （将来可以利用上下文操作设备
    AVFormatContext *ctx = nullptr;
    const char *devicename = DEVICE_NAME;
//    AVDictionary *options = nullptr;
    //打开设备
    int ret = avformat_open_input(&ctx,devicename,fmt,nullptr);
    if(ret < 0) {
        char errorbuf[1024];
        av_strerror(ret,errorbuf,sizeof(errorbuf));
        qDebug() << "打开设备失败";
        return;
    }

       //文件名
    const char *filename = FILENAME;
    QFile file(filename);

     //以只写的方式打开文件，如果文件不存在就创建文件，存在就删除重新创建
    if(!file.open(QIODevice::WriteOnly )) {
        qDebug() << "文件打开失败";
        avformat_close_input(&ctx);
        return;
    }

    //采集传输
    int count = 50;

    //数据包
    AVPacket pkt;
    //不断采集数据
    while( count-- >0 && av_read_frame(ctx,&pkt) == 0) {
        file.write((const char*)pkt.data,pkt.size);
    }
    //释放资源
    //关闭文件
    file.close();
    //关闭设备
    avformat_close_input(&ctx);
}
```

```cpp
void MainWindow::on_audioButton_clicked()
{
    //开启子进程
    AudioThread *audioThread = new AudioThread(this);
    audioThread->start();
}
```

主线程发送一个信号，当子进程监听到结束信号的时候就销毁线程

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <cstdio>

#include <qdebug.h>




MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

}

MainWindow::~MainWindow()
{
    delete ui;
    qDebug() << "窗口线程析构";
}


void MainWindow::on_audioButton_clicked()
{
    if(_audioThread == nullptr) {
        //开启录音线程
        _audioThread = new AudioThread(this);  //这里必须传递 this
        _audioThread->start();
        ;
        //设置按钮文字
        ui->audioButton->setText("结束录音");
    }else {
        //结束录音线程
//        _audioThread->setStop(true);
        //请求结束
        _audioThread->requestInterruption();

        //让线程销毁，而不是仅仅改变状态
        _audioThread = nullptr;

        //设置按钮文字
        ui->audioButton->setText("开始录音");
    }
}
```

```cpp
#include "audiothread.h"
#include <qdebug.h>
#include <QFile>

extern "C" {
// 设备相关API
#include <libavdevice/avdevice.h>
// 格式相关API
#include <libavformat/avformat.h>
// 工具相关API（比如错误处理）
#include <libavutil/avutil.h>
// 编码相关API
#include <libavcodec/avcodec.h>
}

#ifdef Q_OS_WIN
    #define FMT_NAME  "dshow"
    #define DEVICE_NAME  "audio=麦克风阵列 (2- Realtek High Definition Audio)"
    // PCM 文件名
    #define FILENAME "D:/lingshengYinShiPin/out.pcm"
#else
    #define FMT_NAME  "avfoundation"
    #define DEVICE_NAME ":0"
    #define FILENAME "~/out.pcm"
#endif


AudioThread::AudioThread(QObject *parent) : QThread(parent)
{
    //点击录音的时候进入子线程
    qDebug() << "构造函数";
    //当监听到结束信号时（"finished"),就调用 deleteLater 回收
    connect(this,&AudioThread::finished,
            this,&AudioThread::loopLevel);
}
//析构函数
AudioThread::~AudioThread() {
    //结束线程
    requestInterruption();
    quit();
    wait();
    qDebug() << this << "析构，内存回收";
}

// 当线程启动的时候（start），就会自动调用run函数
// run函数中的代码是在子线程中执行的
// 耗时操作应该放在run函数中
void AudioThread::run() {


    // 获取输入格式对象
    AVInputFormat *fmt =  av_find_input_format(FMT_NAME);
    if(!fmt) {
        qDebug() << "输入格式失败:" << FMT_NAME;
    }

    //格式上下文 （将来可以利用上下文操作设备
    AVFormatContext *ctx = nullptr;
    const char *devicename = DEVICE_NAME;
//    AVDictionary *options = nullptr;
    //打开设备
    int ret = avformat_open_input(&ctx,devicename,fmt,nullptr);
    if(ret < 0) {
        char errorbuf[1024];
        av_strerror(ret,errorbuf,sizeof(errorbuf));
        qDebug() << "打开设备失败";
        return;
    }

       //文件名
    const char *filename = FILENAME;
    QFile file(filename);

     //以只写的方式打开文件，如果文件不存在就创建文件，存在就删除重新创建
    if(!file.open(QIODevice::WriteOnly )) {
        qDebug() << "文件打开失败";
        avformat_close_input(&ctx);
        return;
    }

    //采集传输
//    int count = 50;

    //数据包
    AVPacket pkt;
    //不断采集数据
    while( !isInterruptionRequested() && av_read_frame(ctx,&pkt) == 0) {
        file.write((const char*)pkt.data,pkt.size);
    }
//    while( !_stop && av_read_frame(ctx,&pkt) == 0) {
//        file.write((const char*)pkt.data,pkt.size);
//    }

    //关闭文件
    file.close();
    //释放资源
//    av_packet_free(&pkt);
    //关闭设备
    avformat_close_input(&ctx);

    qDebug() << this << "正常结束----------";
}
void AudioThread::setStop(bool stop)
{
    _stop = stop;
}

```
