
---

## ffmpeg 编程入门

​本小结只是对 ffmpeg 编程的一些概念做一个简单的介绍，并不会对某个细节或者过程深入讲解，后期会有单独的篇章详细介绍各个部分，大家先对这些概念有个了解先，有助于后期音视频开发的学习。

### 音视频常见术语

- 容器／文件（Conainer/File）：即特定格式的多媒体文件，比如mp4、flv、mkv等。
- 媒体流（Stream）：表示时间轴上的一段连续数据，如一段声音数据、一段视频数据或一段字幕数据，可以是压缩的，也可以是非压缩的，压缩的数据需要关联特定的编解码器（有些码流音频是纯PCM）。
- 数据帧／数据包（Frame/Packet）：通常，一个媒体流是由大量的数据帧组成的，对于压缩数据，帧对应着编解码器的最小处理单元，分别属于不同媒体流的数据帧交错存储于容器之中。
- 编解码器：编解码器是以帧为单位实现压缩数据和原始数据之间的相互转换的。

### 编解码器

- **视频编解码器**

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/视频编解码器.5m9tmtgam9s0.webp)

- **音频编解码器**

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/音频编解码器.hzm3oi4i3cw.webp)

### ffmpeg 函数简介

- `av_register_all()`：注册所有组件, **4.0 已经弃用**
- `avdevice_register_all()` 对设备进行注册，比如 V4L2 等。
- `avformat_network_init()` 初始化网络库以及网络加密协议相关的库（比如 openssl）
  
#### 封装格式相关函数

|  函数原型   | 介绍 |
|  ----  | ----  |
| `avformat_alloc_context`  | 分配一个`AVFormatContext`,并进行简单初始化 (调用者不一定需非调用) |
| `avformat_free_context`  | 释放掉`AVFormatContext`和其里面的流数据 |
|  `avformat_close_input`   | 关闭解复用器，关闭后就不再需要使用`avformat_free_context `进行释放 |
|  `avformat_open_input`   | 打开输入流 (音视频文件) |
|  `avformat_find_stream_info`   | 读取媒体文件并获取流信息 |
|  `av_read_frame`   | 读取音视频包 (文件中的内容),但不进行验证这些码流哪些帧是有效帧 |
|  `avformat_seek_file`   | 定位文件，比如播放器中的拖动定位播放 |
|  `av_seek_file`   |  寻找关键帧 |

> **下面来看看解复用的流程**

- (1)分配解复用器上下文（AVFormatContext）<非必须>
- (2)打开文件(或者网络流）、获取封装信息上下文`AVFormatContext`
- (3)获取媒体文件音视频信息，这一步会将`AVFormatContext`内部变量填充
- (4)读取码流信息：循环处理
  
  * 4.1 从文件中读取数据包`av_read_frame`
  * 4.2 定位文件 `avformat_seek_file` 或 `av_seek_frame`

- (5)关闭解复用器

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/ffmpeg解封装02.60xe5klq6iw0.png)

##### AVFormatContex

> **先来认识一下 AVFormatContext**		
> 
> `AVFormatContext`主要存储视音频封装格式中包含的信息

因为在使用 ffmpeg 进行开发的时候，时刻都会使用到 AVFormatContext 这个数据结构，因为很多函数的参数都会以它为参数，所以有必要先了解一下这个结构体。

AVFormatContext 描述一个媒体文件或媒体流的构成和基本信息。

源码中的注释非常详细，可以参考源码或者点击 [雷神的博客](https://blog.csdn.net/leixiaohua1020/article/details/14214705)

AVFormatContext 中比较重要的几个字段

```c
struct AVInputFormat *iformat：输入数据的封装格式
AVIOContext *pb：输入数据的缓存
unsigned int nb_streams：  音视频流的个数
AVStream **streams：       视频流
char filename[1024]：    文件名
int64_t duration：   时长（单位：微秒us，转换为秒需要除以1000000）
int bit_rate：       比特率（单位bps，转换为kbps需要除以1000）
AVDictionary *metadata：元数据
```


#### 解码器相关函数

- `avcodec_alloc_context3()`: 分配解码器上下文
- `avcodec_find_decoder()`：根据ID查找解码器
- `avcodec_find_decoder_by_name()`:根据解码器名字查找解码器
- `avcodec_open2()`： 打开编解码器
- `avcodec_decode_video2()`：解码一帧视频数据，新版本已经不建议使用
- `avcodec_decode_audio4()`：解码一帧音频数据，新版本已经不建议使用
- `avcodec_send_packet()`: 发送编码数据包，新版本建议
- `avcodec_receive_frame()`: 接收解码后数据，新版本建议
- `avcodec_free_context()`:释放解码器上下文，包含了 `avcodec_close()`
- `avcodec_close()`:关闭解码器

> 这里说明一点，解码器有很多种，比如对于 H264 来说，不同厂家会提供不同的解码器，但是这些解码器的 ID 必须都一样，名字可以不一样。在 ffmpeg 中可以通过 avcodec_find_decoder 来根据解码器的 ID 获取相应的解码器

下面是 ffmpeg 中 h264 解码器的数据结构

```c
AVCodec ff_h264_decoder = {
    .name                  = "h264",   // 解码器的名字
    .long_name             = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_H264,   //这是解码器的 ID
    .priv_data_size        = sizeof(H264Context),
    .init                  = h264_decode_init,
    .close                 = h264_decode_end,
    .decode                = h264_decode_frame,
    .capabilities          = /*AV_CODEC_CAP_DRAW_HORIZ_BAND |*/ AV_CODEC_CAP_DR1 |
                             AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS |
                             AV_CODEC_CAP_FRAME_THREADS,
    .hw_configs            = (const AVCodecHWConfigInternal*[]) {
```

#### ffmpeg解码流程

- 1.`avcodec_alloc_context3()`: 分配编解码器上下文

函数原型：

```c
AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
```

- 2.`avcodec_parameters_to_context()`: 将码流中的编解码器信息拷贝到 AVCodecContex

函数原型：

```c
int avcodec_parameters_to_context(AVCodecContext *codec,
                                  const AVCodecParameters *par)
```

- 3.根据编解码器信息查找相应的解码器 通过 avcodec_find_decoder 或指定解码器名 avcodec_find_decoder_by_name

```c
AVCodec *avcodec_find_decoder(enum AVCodecID id)

AVCodec *avcodec_find_decoder_by_name(const char *name)
```

- 4.打开编解码器并关联到 AVCodecContex，通过 `avcodec_open2()`

```c
int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
```

各个参数的含义：

avctx：需要初始化的 AVCodecContext（当前 Codec 使用的上下文）。		

codec：输入的 AVCodec (存储编解码器信息的结构体)		

options：一些选项。例如使用libx264编码的时候，“preset”，“tune”等都可以通过该参数设置。

- 5.循环发送数据包
  - 5.1 向解码器发送数据包 avcodec_send_packet
  - 5.2 接收解码后的帧 avcodec_receive_frame

- 6.关闭解码器和释放上下文 avcodec_close 和 avcodec_free_context

```c
av_cold int avcodec_close(AVCodecContext *avctx)

void avcodec_free_context(AVCodecContext **pavctx)
```