
- [第6章](#第6章)
	- [变量是什么](#变量是什么)
	- [扒一扒内存对齐](#扒一扒内存对齐)
	- [指针的内容是啥](#指针的内容是啥)
	- [指针你敢不初始化吗](#指针你敢不初始化吗)
	- [指针的指针](#指针的指针)

---

## 第6章

计算机由几亿万个位(bit)组成，每个字节存储的都是 0，1 二进制.一般 8 个位组成一个字节（byte)，当然不同机器不一样。

每个字节类似一个存储单元，但是这样的一个存储单元有点小，所以有些机器把多个字节连接在一起，组成一个更大的内存单位，称为为【字】。一个字一般由 2 个 或者 4 个字节组成。所以呢，每个字包含了更多的位，每个字可以容纳的无符号整数范围是 `0 ~ 4294967295` (2<sup>32</sup>-1),可以容纳的有符号整数范围是 `-2147483648` (-2<sup>31</sup>) ~ `2147483647` (2<sup>31</sup>-1)。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/字和直接01.2nxcg451ni40.png)

### 变量是什么

每个字都有属于自己的一个地址，但是这地址太难记了，所以就用一个名字和这个内存地址位置关联起来，这就是【变量】。但是**变量是由编译器为我们实现的，硬件仍然通过地址访问内存位置**。看看下面这张图就可以很清楚的知道啦。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/变量.2s24hubb6ts0.png)

> 这里是否有同学会问，那么一个字里面只存储一个字符，也需要 4 个字节，这样是不是浪费呢？	
> 
> 回答这个问题，就要引出大名鼎鼎的“字节对齐”啦！

### 扒一扒内存对齐

**内存对齐是一种用空间换时间以提高效率的方式**。

> **为什么会有内存对齐**？

主要是两个原因

- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。

- 硬件原因：经过内存对齐后，`CPU`访问内存的速度大大提升。

可以看一下这段 C 代码输出的各个数据类型大小是多少？

```cpp
#include <stdio.h>

struct node
{
	int num;
	char ch;
}st;

int main() {
	int a[100];
	char b[100];
	printf("sizeof(int):\t %zu\n",sizeof(int));
	printf("sizeof(char):\t %d\n",(int)sizeof(char));
	printf("sizeof(a):\t %d\n",(int)sizeof(a));
	printf("sizeof(b):\t %d\n",(int)sizeof(b));
	printf("sizeof(st):\t %d\n",(int)sizeof(st));
	return 0;
}

```

看一下和自己想的结果一样么， 我们来逐一分析一下。

其输出的结果依次为：

```
sizeof(int):     4
sizeof(char):    1
sizeof(a):       400
sizeof(b):       100
sizeof(st):      8
```

此时会发现，和单纯计算字节数的话是有一些误差的。这就是因为内存对齐的原因。

> **来看一下内存对齐和非内存对齐产生的效果区别**。

`CPU`读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是`2，4，8，16`个字节，具体取多少个字节取决于硬件。

假设`CPU`把内存划分为`4`字节大小的块，要读取一个`4`字节大小的`int`型数据，来看一下这两种情况下`CPU`的工作量：

- 第一种就是内存对齐的情况，如图

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐01.png)

一字节的 `char` 占用了四个字节，空了三个字节的内存地址，`int` 数据从地址`4`开始。此时，直接将地址 `4，5，6，7` 处的四个字节数据读取到即可。

- 第二种是没有内存对齐的情况如图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐02.png)

`char` 型的数据和`int`型的数据挨在一起，这个 `int` 数据从地址 `1` 开始，那么 `CPU` 想要读这个数据的话,来看看需要几步操作：

因为 `CPU` 是四个字节四个字节来寻址，

首先 `CPU` 读取 `0，1，2，3` 处的四个字节数据

然后 `CPU` 读取 `4，5，6，7` 处的四个字节数据

最后还要合并地址 `1，2，3，4` 处四个字节的数据才是本次操作需要的 `int` 数据。此时**一共需要两次寻址，一次合并的操作**。

> 大家可能会发现内存对齐岂不是浪费的内存资源么？

是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。

### 指针的内容是啥

先来看下面代码中定义的几个变量

```c
int a = 122,b = -11;
float c = 3.14;

//定义指针
int *p1 = &a;
float *p2 = &c;
```

通过结合下面的图和上面的代码可以看出，p1 的内容与 a 的地址是一样的，p2 的内容和 c 的地址是一样的。但是注意，d 和 e 被定义为指针并不会改变这些表达式的求值方式，一个变量的值就是分配给这个变量的内存位置所存储的值。所以说不能简单地认为 p1 存储的是地址 100 的值，p2 存储的是地址 108 的值。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/指针的内容.25mx0e8cmc2o.png)

> 所以说，上面 p1 的值是什么？千万别说是 112，这是不对的，正确答案是 a 的地址。

### 指针你敢不初始化吗

我们先来看看下面代码

```c
int *a;
*a = 10;
printf("%d,\n",*a);
```

上面代码的打印结果是什么？ 是 10 吗？其实不是，报内存错误 `Segmentation fault (core dumped)`。因为指针没有被初始化，我们不能够预测这个 10 存在哪个地方，所以，我们必须将**指针初始化**。如果你实在不知道怎么怎么初始化它，可以将它指向 NULL ，即 NULL 指针，但是又有新的问题，一个 NULL 指针是不能够进行解引用的，也就是不能直接通过 `*a` 取值。

### 指针的指针

```c
int a = 10;
int *b = &a;

printf("a = %d\n",a);
printf("*b = %d\n", *b);

a = 12;
printf("a = %d\n",a);
printf("*b = %d\n", *b);

int ** c = &b;  //指针的指针
printf("**c = %d\n", **c);

**c = 13;
printf("a = %d\n",a);
printf("*b = %d\n", *b);
printf("**c = %d\n", **c);
```

上面代码的运行结果为；

```
a = 10
*b = 10
a = 12
*b = 12
**c = 12
a = 13
*b = 13
**c = 13
```

通过上述结果可以发现，当我们修改了变量 a 的值，b 的值也相应发生了改变，修改了 c ，a，和 b 也随着发生了改变。这是怎么回事呢？看下面这张内存图，相信你就能知道答案。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/指针的指针.5ze21a497cs0.png)

指针 b 指向 a 的地址，然后指针 c 指向 b，所以 c 就是指向指针的指针，也就是还说通过 c 一次解引用能得到 b 的值，因为 b 还是个指针，所以在此解引用能得到 a 的值。所以 `**c` 的值就是 a 的值，对 `**c` 修改其实相当于修改了 a 的值，所以就有了上述的运行结果。




