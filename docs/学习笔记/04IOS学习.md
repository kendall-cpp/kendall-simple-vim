

------

## IOS 多线程

IOS 是使用 GCD 实现多线程的，GCD 类似一个线程池，在这个线程池的基础上执行并发任务。

### 使用 GCD 的好处

- GCD 可用于多核的并行运算；
- GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）
- 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。

###  GCD 任务和队列

在 GCD 中是放在 block 中的。执行任务有两种方式：『同步执行』 和 『异步执行』。

两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。

#### 同步执行（sync）

- 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
- 只能在当前线程中执行任务，不具备开启新线程的能力。

#### 异步执行（async）

- 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
- 可以在新的线程中执行任务，具备开启新线程的能力。


在 GCD 中有两种队列：『串行队列』 和 『并发队列』。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。

#### 串行队列（Serial Dispatch Queue）

- 每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）

#### 并发队列（Concurrent Dispatch Queue）：

- 可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）

> 注意：并发队列 的并发功能只有在异步（dispatch_async）方法下才有效。

### GCD 的使用步骤

- 创建一个队列（串行队列或并发队列）；
    - 可以使用 `dispatch_queue_create` 方法来创建队列。
    - 第一个参数表示队列的唯一标识符，用于 DEBUG
    - 第二个参数用来识别是串行队列还是并发队列

- 将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。

```cpp
// 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT);
```

### 任务的创建方法

GCD 提供了同步执行任务的创建方法 `dispatch_sync` 和异步执行任务创建方法 `dispatch_async。`

```cpp
// 同步执行任务创建方法
dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});
// 异步执行任务创建方法
dispatch_async(queue, ^{
    // 这里放异步执行任务代码
});
```

### GCD 线程间的通信

在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。

### GCD 的其他方法

#### GCD 栅栏方法：dispatch_barrier_async

我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async 方法在两个操作组间形成栅栏。

`dispatch_barrier_async` 方法会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 `dispatch_barrier_async` 方法追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：

![](https://upload-images.jianshu.io/upload_images/1877784-4d6d77fafd3ad007.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



