
- [操作系统真象还原](#操作系统真象还原)
  - [第 1 章](#第-1-章)
  - [安装 Bochs](#安装-bochs)
  - [第 2 章](#第-2-章)
    - [BIOS](#bios)
    - [按下开机之后电脑发生了什么](#按下开机之后电脑发生了什么)
    - [启动 MAR](#启动-mar)
  - [第 3 章](#第-3-章)
    - [什么是地址](#什么是地址)

----------------

# 操作系统真象还原

## 第 1 章


## 安装 Bochs

参考：https://blog.csdn.net/weixin_37477009/article/details/112910317

下载 bochs-2.6.2.tar.gz

[下载地址](https://sourceforge.net/projects/bochs/files/bochs/2.6.2/bochs-2.6.2.tar.gz/)


下载完解压之后，cd 到 bochs-2.6.2 

- 通过 configure，make，make install 进行安装。

> 第二行更改成自己的目录，注意 `\` 前面有一个空格，`\`后面不能有空格

```
./configure \
--prefix=/home/book/bochsken \
--enable-debugger \
--enable-disasm \
--enable-iodebug \
--enable-x86-debugger \
--with-x \
--with-x11
```

- make

> make 报错

具体错误如下：

```
cd gui && \
make  libgui.a
make[1]: Entering directory '/home/book/bochsken/bochs-2.6.2/gui'
g++ -c  -I.. -I./.. -I../iodev -I./../iodev -I../instrument/stubs -I./../instrument/stubs -g -O2 -D_FILE_OFFSET_BITS=64 -D_LARGE_FILES     gtk_enh_dbg_osdep.cc -o gtk_enh_dbg_osdep.o
gtk_enh_dbg_osdep.cc:20:10: fatal error: gtk/gtk.h: No such file or directory
 #include <gtk/gtk.h>
          ^~~~~~~~~~~
compilation terminated.
Makefile:104: recipe for target 'gtk_enh_dbg_osdep.o' failed
make[1]: *** [gtk_enh_dbg_osdep.o] Error 1
make[1]: Leaving directory '/home/book/bochsken/bochs-2.6.2/gui'
Makefile:323: recipe for target 'gui/libgui.a' failed
make: *** [gui/libgui.a] Error 2
```

解决办法

```bash
sudo apt-get install xorg-dev
# 这里如果报：E: Unmet dependencies. Try 'apt --fix-broken install' with no packages (or specify a solution).
# 就参考这个链接：https://blog.csdn.net/jinguangliu/article/details/78145423


```


```
/usr/bin/ld: gui/libgui.a(gtk_enh_dbg_osdep.o): undefined reference to symbol 'pthread_create@@GLIBC_2.2.5'
/usr/bin/ld: /lib/x86_64-linux-gnu/libpthread.so.0: error adding symbols: DSO missing from command line
collect2: error: ld returned 1 exit status
make: *** [Makefile:179: bochs] Error 1
```

解决

> 参考：https://blog.csdn.net/xiaoqin515515/article/details/19009653

打开 Makefile，在92行左右找到 `LIBS ＝ 。。。`一行，在这一行最后面添加 `-lpthread`

```
 LIBS =  -lm -lpthread
```

- 重新 make

`make install`

`bochsrc.disk`(进入bochs, 新建 `bochsrc.disk`)

```
# 设置 Bochs 在运行过程中能够使用的内存，本例为 32MB
megs: 32

# 设置对应真实机器的 BIOS 和 VGA BIOS
romimage: file=/home/kendall/bochsken/share/boch/BIOS-bochs-latest
vgaromimage: file=/home/kendall/bochsken/share/boch/VGABIOS-lgpl-latest

# 设置 Bochs 使用的磁盘
# floppya: 1_44=a.img, status=inserted

# 选择启动盘符
boot: disk # 从硬盘启动

# 设置日志文件输出
log: bochs.out

# 关闭鼠标，打开键盘
mouse: enabled=0
#keyboard: enabled=1,
keyboard:keymap=/home/kendall/bochsken/share/bochs/keymaps/x11-pc-us.map

# 硬盘设置
ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14

# 增加 Bochs 对 GDB 的支持，GDB 远程连接到此机器的 1234 端口便可调试
#gdbstub: enabled=1, port=1234, test_base=0, data_base=0, bss_base=0
```

`bin/bochs -f bochsrc.disk`

> PS: 如果出现黑框就输入 c
```
(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmp far f000:e05b         ; ea5be000f0
<bochs:1> c
```

------

## 第 2 章

### BIOS

BIOS 的工作是检测、初始化硬件，还有建立向量表，这样就可以通过“int中断号”来实现相关的硬件调用。

> BIOS 建立的这些功能代码就是对硬件的 IO 操作

> 为什么插入主板的内存不是实际的全部内存

因为在计算机中，并不是只有插主板上的内存条需要通过地址总线，(地址总线的宽度决定可以访问的内存空间大小) 还有其他外设也是沟通过地址总线来访问内存的，所以地址总线需要预留出一些内存给外设（比如显存，硬盘控制器等），剩下的可用内存再指向 DRAM（动态随记访问内存）。这就是为什么安装了 4GB 的内存，而电脑中只显示 3.8GB 的原因

BIOS 是计算机上的第一个运行的软件，它是由硬件加载的，BIOS 的代码是写在 ROM [只读存储器] 上的 BIOS，因为 BIOS 代码所做的工作室一成不变的，不需要更改。 BIOS 执行的入口地址是 0xFFFF0。


### 按下开机之后电脑发生了什么

PC 机上电后的第一条指令就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处执行指令，在我们这里的情况下就是 GRUB 引导程序。



### 启动 MAR

创建一个文件 mbr.S

```
; mbr.S

; 主引导程序
; --------------------------------------------------
SECTION MBR vstart=0x7c00 ; 把起始地址编译为 0x7c00
    mov ax, cs     ; cs 代码段寄存器
    mov ds, ax     ; dx 数据段寄存器
    mov es, ax     ; es 附加段寄存器
    mov ss, ax     ; ss 堆栈段寄存器
    mov fs, ax     ; fs 80386 后添加的寄存器，无全称
    mov sp, 0x7c00 ; sp 堆栈指针寄存器

; 清屏
; --------------------------------------------------
; INT 0x10    功能号: 0x06    功能描述：上卷窗口
; --------------------------------------------------
; 输入：
; AH 功能号 = 0x06
; AL = 上卷的行数(如果为0，表示全部)
; BH = 上卷行属性
; (CL, CH) = 窗口左上角的 (X, Y) 位置
; (DL, DH) = 窗口右下角的 (X, Y) 位置
; 无返回值:
    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0
    mov dx, 0x184f ; 右下角: (80, 25)
                   ; VGA 文本模式种，一行只能容纳 80 个字符，共 25 行
                   ; 下标从 0 开始，所以 0x18=24, 0x4f=79
        
    int 0x10       ; int 0x10

; .get_cursor 获取当前光标位置，在光标处打印字符
    mov ah, 3      ; 3 号子功能
    mov bh, 0      ; 待获取光标的页号

    int 0x10       ; 输出：
                   ; ch = 光标开始行，cl = 光标结束行
                   ; dh = 光标所在行号，dl = 光标所在列号

; 打印字符串
    mov ax, message
    mov bp, ax     ; es:bp 为串首地址
    
    mov cx, 5      ; cx 为串长度，不包括结束符 '\0'
    mov ax, 0x1301 ; 13 号子功能
                   ; ah = 13
                   ; al = 01: 写字符方式，显式字符串，光标跟随移动
    mov bx, 0x2    ; bh = 0，要显示的页号
                   ; bl = 02，字符属性，黑底绿字
    
    int 0x10

    jmp $          ; 程序悬停在此

    message db "1 MBR"    ; db 字节型
                          ; dw 字类型
                          ; dd 双字型
                          ; dq 四字型
                          ; dt 十字节型 
    times 510-($-$$) db 0 ; 填充文件末尾的魔数 0xaa55 和当前位置之间的空间
                          ; 保证编译后生成的文件大小为 512 字节（硬盘一个扇区的大小）
    db 0x55, 0xaa

```

然后编译 

nasm -o mbr.bin mbr.S

将编译后的 bin 文件写入扇区

```
kendall@kendall-virtual-machine:~/bochsken$ dd if=boot/mbr.bin of=hd60M.img bs=512 count=1 

conv=notrunc
1+0 records in
1+0 records out
512 bytes copied, 0.000185153 s, 2.8 MB/s
```

接下来通过 bochs 测试

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/bochs-01.382j6t1cdm00.png)

------

## 第 3 章

### 什么是地址


