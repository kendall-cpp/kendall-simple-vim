
- [操作系统真象还原](#操作系统真象还原)
  - [第 2 章](#第-2-章)
    - [计算机是怎么启动的](#计算机是怎么启动的)
    - [按下开机之后电脑发生了什么](#按下开机之后电脑发生了什么)
    - [启动 MAR](#启动-mar)
  - [第 2 章](#第-2-章-1)
    - [实模式下1M内存](#实模式下1m内存)
    - [BIOS 是怎么启动的](#bios-是怎么启动的)
    - [总结](#总结)

----------------

# 操作系统真象还原


## 第 2 章

### 计算机是怎么启动的

如果你亲自动手重载过系统你就听过 BIOS 这个名词。BIOS 全称叫 Base Input & Output System ,也就是基本输入输出系统。**它的主要作用就是检测、初始化硬件**（硬件自己本身就提供一些初始化的功能调用，BIOS 直接调用就可以了），当然还有非常重要的 **建立中断表**，接着通过 `Int` 中断来实现相关的硬件调用。其实这些操作对于硬件来说就是 IO 操作，但是由于空间只有 64kb 的局限，且受到 [实模式] 的局限，所以只需要保证硬件能运行基本的 IO 操作就行了。

> 接下来看看实模式下 1MB 内存的布局

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/实模式内存布局.3fmzdzgtgye0.webp)


对于上表

- 0xffff0 为 BIOS 的入口地址，这里 16 字节的内容是跳转指令 jmp_f000: e05b
- 0xb8000 - 0xbffff 用于文本模式的显示适配器  
......


> 为什么插入主板的内存不是实际的全部内存

因为在计算机中，并不是只有插主板上的内存条需要通过地址总线，(地址总线的宽度决定可以访问的内存空间大小) 还有其他外设也是沟通过地址总线来访问内存的，所以地址总线需要预留出一些内存给外设（比如显存，硬盘控制器等），剩下的可用内存再指向 DRAM（动态随记访问内存）。这就是为什么安装了 4GB 的内存，而电脑中只显示 3.8GB 的原因

BIOS 是计算机上的第一个运行的软件，它是由硬件加载的，BIOS 的代码是写在 ROM [只读存储器] 上的 BIOS，因为 BIOS 代码所做的工作室一成不变的，不需要更改。 BIOS 执行的入口地址是 0xFFFF0。


### 按下开机之后电脑发生了什么

PC 机上电后的第一条指令就是 BIOS 固件中的，它负责检测和初始化 CPU、内存及主板平台，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到 0x7c00 地址开始的内存空间，再接着跳转到 0x7c00 处执行指令，在我们这里的情况下就是 GRUB 引导程序。



### 启动 MAR

创建一个文件 mbr.S ,将下面代码复制进去。

```
; mbr.S

; 主引导程序
; --------------------------------------------------
SECTION MBR vstart=0x7c00 ; 把起始地址编译为 0x7c00
    mov ax, cs     ; cs 代码段寄存器
    mov ds, ax     ; dx 数据段寄存器
    mov es, ax     ; es 附加段寄存器
    mov ss, ax     ; ss 堆栈段寄存器
    mov fs, ax     ; fs 80386 后添加的寄存器，无全称
    mov sp, 0x7c00 ; sp 堆栈指针寄存器

; 清屏
; --------------------------------------------------
; INT 0x10    功能号: 0x06    功能描述：上卷窗口
; --------------------------------------------------
; 输入：
; AH 功能号 = 0x06
; AL = 上卷的行数(如果为0，表示全部)
; BH = 上卷行属性
; (CL, CH) = 窗口左上角的 (X, Y) 位置
; (DL, DH) = 窗口右下角的 (X, Y) 位置
; 无返回值:
    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0
    mov dx, 0x184f ; 右下角: (80, 25)
                   ; VGA 文本模式种，一行只能容纳 80 个字符，共 25 行
                   ; 下标从 0 开始，所以 0x18=24, 0x4f=79
        
    int 0x10       ; int 0x10

; .get_cursor 获取当前光标位置，在光标处打印字符
    mov ah, 3      ; 3 号子功能
    mov bh, 0      ; 待获取光标的页号

    int 0x10       ; 输出：
                   ; ch = 光标开始行，cl = 光标结束行
                   ; dh = 光标所在行号，dl = 光标所在列号

; 打印字符串
    mov ax, message
    mov bp, ax     ; es:bp 为串首地址
    
    mov cx, 5      ; cx 为串长度，不包括结束符 '\0'
    mov ax, 0x1301 ; 13 号子功能
                   ; ah = 13
                   ; al = 01: 写字符方式，显式字符串，光标跟随移动
    mov bx, 0x2    ; bh = 0，要显示的页号
                   ; bl = 02，字符属性，黑底绿字
    
    int 0x10

    jmp $          ; 程序悬停在此

    message db "1 MBR"    ; db 字节型
                          ; dw 字类型
                          ; dd 双字型
                          ; dq 四字型
                          ; dt 十字节型 
    times 510-($-$$) db 0 ; 填充文件末尾的魔数 0xaa55 和当前位置之间的空间
                          ; 保证编译后生成的文件大小为 512 字节（硬盘一个扇区的大小）
    db 0x55, 0xaa

```

然后编译 

nasm -o mbr.bin mbr.S

将编译后的 bin 文件写入扇区

```
kendall@kendall-virtual-machine:~/bochsken$ dd if=boot/mbr.bin of=hd60M.img bs=512 count=1 

conv=notrunc
1+0 records in
1+0 records out
512 bytes copied, 0.000185153 s, 2.8 MB/s
```

接下来通过 bochs 测试

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/bochs-01.382j6t1cdm00.png)

------

## 第 2 章

> 谁告诉你电脑内存条内存越大约好的？

如果你亲自动手重载过系统你就听过 BIOS 这个名词。BIOS 全称叫 Base Input & Output System ,也就是基本输入输出系统。

> 下面我们从实模式下的内存布局来回答上面提出的问题.

### 实模式下1M内存

在很久以前，Intel 8086 有 20 条地址线，因为 2<sup>20</sup>=1048576=1MB，所以，这 20 条地址线可以访问 1MB 的内存。如果用 16 进制来表示就是 `0x00000 ~ 0xFFFFF`。

这里先大概预览一下实模式下的内存布局表

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/实模式内存布局.3fmzdzgtgye0.webp)


> 其中 64 千字节(KB) = 1024字节(B)

内存地址 0 ~ 0x9FFFF 的空间范围是 640KB，这个范围的地址对应到 DRAM（动态随记访问内存，断电即丢失），也就是我们插在**主板的内存条**，但是，内存条的内存不是全部的物理内存。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/BIOS内存布局01.7899d1nvvjw0.webp)

上表中的 `0xF0000 ~ 0xFFFF`，这 64KB 内存就是 ROM (只读存储)，这里存放的是 BIOS 的代码，（其实这里存储的只是跳转指令）

我们先来看下面这张图，`0xF0000 ~ 0xFFFF` 这段地址可以分为 `0xF0000 ~ 0xFFFEF` + `0xFFFF0 ~ 0xFFFFF`，其中 `0xFFFF0 ~ 0xFFFFF` 这段 16 字节，是 BIOS 的入口地址，此处的内容是 跳转指令 `jmp f000: e05b` 。其中 BIOS 的作用是 **检测、初始化硬件 和 建立中断向量表**，这里的建立操作对硬件来说就是 IO 操作。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/BIOS内存布局02.78ufh211ww80.webp)

从可以清除看出 ROM 只有 64KB，所以可能实现所有的 IO 操作非常有限，这也正是在实模式下为什么计算机只能运行硬件 IO 的基本操作。这应该也是 BIOS 为什么叫基本输入输出系统的原因吧。

> 回到一开始的问题，为什么在 CPU 眼里主板插上的内存条的内存不是“全部内存”呢？

**好了，我们现在来回答这个问题**

这其实是由[地址总线]的宽度决定的，因为地址总线的宽度决定了可以访问的内存空间大小，就比如我们以前用的 32 位的电脑，其它的地址范围就是 4GB，所以你电脑如果还是 32位 的，那就算买的内存条大于 4GB 也不会有什么本质的作用。

注意，我们刚刚说的是寻址范围为 4GB，但是并没有说它一定会寻址到哪里，所以**寻址范围不一定是物理地址**。这是怎么回事呢？因为在计算机中，除了主板上的内存条外，还有其他设备也需要通过地址总线来访问，就比如显存，硬盘控制器等。试想，如果把所有的地址总线都拿来给主板上的内存条用，那么其他设备怎么办呢？是吧。所以说，地址总线需要将一部分内存预留出来，剩下的内存才是指向 DRAM（物理内存）。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/地址总线.3m54p2okl0a0.webp)

> **所以不要还以为电脑中内存条越大越好，还得看你电脑中地址总线的宽度，如果你电脑的地址总线的寻址范围只有8G，那你买个16G的内存条有什么用呢？**

> 解决了上述问题之后，我们再继续深入理解下 BIOS 到底怎么工作的。

### BIOS 是怎么启动的

BIOS 是计算机上第一个运行的软件，那么既然是第一个软件，那它肯定不能自己加载自己了，所以 BIOS 是由硬件加载的。这个硬件也就是我们前面提到的 **只读存储器 ROM**。因为是只读的，所以里面的内容是不可以更改的，也可以说 BIOS 的工作时一成不变的。当然你如果要刷机情况除外。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/BIOS启动01.5omw9bdift00.webp)

从上图可以很清楚看出 BIOS 写在 ROM，然后因为 ROM 被映射到整个 1M (实模式)的顶部，也就是起那么说的 64KB 那里。然后 **BIOS 的入口地址是 0xFFFF0**。

> **好了，现在找到 BIOS 的入口了，那么 CPU 如果是执行它呢？也就是说 CPU 的 cs：ip寄存器怎么将一串数字组织成 0xFFFF0 呢？**

> 这里先注释一点，CPU 给一串字符串给地址总线，地址总线将这字符串映射成地址，CPU 才能访问该地址。

CPU 的访问内存需要涉及到内存分段机制，这个后面学到内存管理的时候再详细介绍，现在只需要简单理解为 CPU 需要用 **段基地址 + 偏移地址** 才能找到物理地址。这里注意，在实模式下，段地址需要乘于 16，也就是向左移 4 位才能与偏移地址相加。

计算机在开机之后，CPU 的cs: ip寄存器被强制初始化为 0xF000: 0xFFF0，也就是 cs 寄存器的值是 0xF000，ip 寄存器的值是 0xFFF0，也就是段基地址是 0xF000，段内偏移地址是 0xFFF0，这个地址组合出来就是 0xFFFF0。

> 这里简单介绍写上面是怎么计算出来的。0xF000 转成二进制是 1111 0000 0000 0000 ，然后左移 4 位之后变成 1111 0000 0000 0000 0000 0000 ，再加上 0xFFF0（1111 1111 1111 0000） 等于 1111 1111 1111 1111 0000（FFFF0）。

0xF000 处存储的还是跳转指令 `jmp f000: e05b`，也就是下一条要执行的指令。也就是说跳转到下一条要执行的指令。这就是 BIOS 代码开始的地方。接下来 BIOS 就可以开始工作了。

----

### 总结

- 主板内存条的内存不一定是实际的物理内存，这和地址总线的宽度有关，因为地址总线的宽度决定寻址的范围。而且不仅仅是主板上的内存条需要访问地址总线，其他设备也需要访问，所以地址总线需要预留出一部分地址空间出来给其他设备访问。因此我们买的 4GB 的内存条，在电脑看到的可能只有 3.8GB。


- BIOS 的起始地址是 0xFFFFo,CPU 通过地址总线映射到这个地址，然后 CPU 访问该地址并执行它，这个访问过程需要用到内存分段机制，即 段基地址+偏移地址=物理地址。

---

> 计算机通电后，BIOS 处理程序开始自检，随后，调用 BIOS 中断 0x91h，