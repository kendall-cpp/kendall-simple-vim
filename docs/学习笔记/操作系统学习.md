
- [操作系统真象还原](#操作系统真象还原)
  - [第 2 章](#第-2-章)
    - [实模式下1M内存](#实模式下1m内存)
    - [BIOS 是怎么启动的](#bios-是怎么启动的)
    - [总结](#总结)
    - [主引导记录起始地址 0x7c00](#主引导记录起始地址-0x7c00)
    - [安装NASM工具](#安装nasm工具)
    - [关于寄存器的简单介绍](#关于寄存器的简单介绍)
    - [写一个主引导记录MBR](#写一个主引导记录mbr)
  - [第三章](#第三章)
    - [为什么数组的起始下标是 0 而不是 1](#为什么数组的起始下标是-0-而不是-1)
    - [CPU的工作原理](#cpu的工作原理)
    - [让 MBR 直接操作显卡](#让-mbr-直接操作显卡)
    - [MBR使用磁盘](#mbr使用磁盘)
  - [第4章](#第4章)

----------------

# 操作系统真象还原

## 第 2 章

> 谁告诉你电脑内存条内存越大约好的？

如果你亲自动手重载过系统你就听过 BIOS 这个名词。BIOS 全称叫 Base Input & Output System ,也就是基本输入输出系统。


### 实模式下1M内存

在很久以前，Intel 8086 有 20 条地址线，因为 2<sup>20</sup>=1048576=1MB，所以，这 20 条地址线可以访问 1MB 的内存。如果用 16 进制来表示就是 `0x00000 ~ 0xFFFFF`。

这里先大概预览一下实模式下的内存布局表

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/实模式内存布局.3fmzdzgtgye0.webp)


> 其中 1 千字节(KB) = 1024字节(B)

内存地址 0 ~ 0x9FFFF 的空间范围是 640KB，这个范围的地址对应到 DRAM（动态随机访问内存，断电即丢失），也就是我们插在**主板的内存条**，但是，内存条的内存不等于全部的物理内存。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/BIOS内存布局01.7899d1nvvjw0.webp)

上表中的 `0xF0000 ~ 0xFFFF`，这 64KB 内存就是 ROM (只读存储)，这里存放的是 BIOS 的代码，（其实这里存储的只是跳转指令）

我们先来看下面这张图，`0xF0000 ~ 0xFFFF` 这段地址可以分为 `0xF0000 ~ 0xFFFEF` + `0xFFFF0 ~ 0xFFFFF`，其中 `0xFFFF0 ~ 0xFFFFF` 这段 16 字节，是 BIOS 的入口地址，此处的内容是 跳转指令 `jmp f000: e05b` 。其中 BIOS 的作用是 **检测、初始化硬件 和 建立中断向量表**，这里的建立操作对硬件来说就是 IO 操作。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/BIOS内存布局02.6jv259c6x6s0.webp)

从可以清楚看出 ROM 只有 64KB，所以可能实现所有的 IO 操作非常有限，这也正是在实模式下为什么计算机只能运行硬件 IO 的基本操作。这应该也是 BIOS 为什么叫基本输入输出系统的原因吧。

> 回到一开始的问题，为什么在 CPU 眼里主板插上的内存条的内存不是“全部内存”呢？

**好了，我们现在来回答这个问题**

这其实是由[地址总线]的宽度决定的，因为地址总线的宽度决定了可以访问的内存空间大小，就比如我们以前用的 32 位的电脑，其它的地址范围就是 4GB，所以你电脑如果还是 32位 的，那就算买的内存条大于 4GB 也不会有什么本质的作用。

注意，我们刚刚说的是寻址范围为 4GB，但是并没有说它一定会寻址到哪里，所以**寻址范围不一定是物理地址**。这是怎么回事呢？因为在计算机中，除了主板上的内存条外，还有其他设备也需要通过地址总线来访问，就比如显存，硬盘控制器等。试想，如果把所有的地址总线都拿来给主板上的内存条用，那么其他设备怎么办呢？是吧。所以说，地址总线需要将一部分内存预留出来，剩下的内存才是指向 DRAM（物理内存）。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/地址总线.3m54p2okl0a0.webp)

> **所以不要还以为电脑中内存条越大越好，还得看你电脑中地址总线的宽度，如果你电脑的地址总线的寻址范围只有 8G，那你买个 16G 的内存条有什么用呢？**

> 解决了上述问题之后，我们再继续深入理解下 BIOS 到底怎么工作的。

### BIOS 是怎么启动的

BIOS 是计算机上第一个运行的软件，那么既然是第一个软件，那它肯定不能自己加载自己了，所以 BIOS 是由硬件加载的。这个硬件也就是我们前面提到的 **只读存储器 ROM**。因为是只读的，所以里面的内容是不可以更改的，也可以说 BIOS 的工作是一成不变的。当然你如果要刷机情况除外。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/BIOS启动01.3cei06j67y20.webp)

从上图可以很清楚看出 BIOS 写在 ROM，然后因为 ROM 被映射到整个 1M (实模式)的顶部，也就是之前说的 64KB 那里。然后 **BIOS 的入口地址是 0xFFFF0**。

> **好了，现在找到 BIOS 的入口了，那么 CPU 如何执行它呢？也就是说 CPU 的 cs：ip寄存器怎么将一串数字组织成 0xFFFF0 呢？**

> 这里先注释一点，CPU 给一串字符串给地址总线，地址总线将这字符串映射成地址，CPU 才能访问该地址。

CPU 的访问内存需要涉及到内存分段机制，这个后面学到内存管理的时候再详细介绍，现在只需要简单理解为 CPU 需要用 **段基地址 + 偏移地址** 才能找到物理地址。这里注意，在实模式下，段地址需要乘于 16，也就是向左移 4 位才能与偏移地址相加。

计算机在开机之后，CPU 的cs: ip寄存器被强制初始化为 0xF000: 0xFFF0，也就是 cs 寄存器的值是 0xF000，ip 寄存器的值是 0xFFF0，也就是段基地址是 0xF000，段内偏移地址是 0xFFF0，这个地址组合出来就是 0xFFFF0。

> 这里简单介绍下上面是怎么计算出来的。0xF000 转成二进制是 1111 0000 0000 0000 ，然后左移 4 位之后变成 1111 0000 0000 0000 0000 0000 ，再加上 0xFFF0（1111 1111 1111 0000） 等于 1111 1111 1111 1111 0000（FFFF0）。

0xF000 处存储的还是跳转指令 `jmp f000: e05b`，也就是下一条要执行的指令。也就是说跳转到下一条要执行的指令。这就是 BIOS 代码开始的地方。接下来 BIOS 就可以开始工作了。

----

### 总结

- 主板内存条的内存不一定是实际的物理内存，这和地址总线的宽度有关，因为地址总线的宽度决定寻址的范围。而且不仅仅是主板上的内存条需要访问地址总线，其他设备也需要访问，所以地址总线需要预留出一部分地址空间出来给其他设备访问。因此我们买的 4GB 的内存条，在电脑看到的可能只有 3.8GB。


- BIOS 的起始地址是 0xFFFF0,CPU 通过地址总线映射到这个地址，然后 CPU 访问该地址并执行它，这个访问过程需要用到内存分段机制，即 段基地址+偏移地址=物理地址。
  
---

### 主引导记录起始地址 0x7c00

计算机通电后，BIOS 处理程序开始自检，随后，调用 BIOS 中断 0x91h，也就是 `call int 19h`。BIOS 会通过这个函数检测这台计算机有多少硬盘或者软盘，如果检测到了有可用的磁盘，那么 BIOS 就把它的第一个扇区加载到 0x7c00。  

> 主引导记录会存入内存地址 0x7C00, 为什么是 0x7c00，详细可以参考[这篇文章](https://www.glamenv-septzen.net/en/view/6)

主引导记录（Master boot record，缩写为 MBR ）是什么，后面学到《计算机是如何启动的？》会详细介绍，关注并留意 微信公众号【零K同学】

先简单说一下计算机启动是这样一个过程

- 通电
- 读取 ROM 里面的 BIOS，用来检查硬件
- 硬件检查通过
- BIOS 根据指定的顺序，检查引导设备的第一个扇区（即**主引导记录**），加载在内存地址 0x7C00
- 主引导记录把操作权交给操作系统

所以，主引导记录就是引导"操作系统"进入内存的一段小程序，大小不超过 1 个扇区（ 512 字节）。

0x7C00 这个地址来自 Intel 的第一代个人电脑芯片 8088，以后的 CPU 为了保持兼容，一直使用这个地址。

### 安装NASM工具

后面在实际的代码实践中需要用到 NASM 工具，这里先介绍一下这个工具在 Ubuntu 的安装和简单实用。

- 执行下面命令下载安装

```sh
sudo apt-get install nasm
```

- 通过查看版本查看 nasm 是否安装成功

```
$ nasm -version
NASM version 2.13.02
```

- 简单学一下使用 nasm 的使用

1.创建一个 `test.asm` 文件

```sh
touch test.asm
vim test.asm
```

vim 打开该文件并输入下面代码，vim 的具体用法自己通过网络搜索学习。

```x86asm
section .data
  hello:     db 'Hello world!',10    ; 'Hello world!' plus a linefeed character
  helloLen:  equ $-hello             ; Length of the 'Hello world!' string
                                     ; (I'll explain soon)
 
section .text
  global _start
 
_start:
  mov eax,4            ; The system call for write (sys_write)
  mov ebx,1            ; File descriptor 1 - standard output
  mov ecx,hello        ; Put the offset of hello in ecx
  mov edx,helloLen     ; helloLen is a constant, so we don't need to say
                       ;  mov edx,[helloLen] to get it's actual value
  int 80h              ; Call the kernel
 
  mov eax,1            ; The system call for exit (sys_exit)
  mov ebx,0            ; Exit with return code of 0 (no error)
  int 80h
```

2.编译，这时候会产生 `.o` 文件

```
nasm -f elf64 test.asm
```

3.链接

```
 ld -s test.o -o test
```

4.执行

```
$ ./test
Hello world!
```

### 关于寄存器的简单介绍

因为后面的汇编代码中涉及到很多寄存器，所以这里先简单总结一下

- CS 寄存器 和 IP 寄存器

这一组寄存器非常重要，一般写为：`cs: ip`

CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 **CS 为代码段寄存器**，而 **IP 为指令指针寄存器**(相当于偏移地址）。CPU 执行指令时，通过代码寄存器 CS 和指令指针寄存器 IP 来确定要执行的下一条指令的内存地址。

修改 CS、IP 的指令不同于修改通用的寄存器值的指令，修改通用寄存器的值可以用 mov 指令（`mav ax,123`），mov 指令被称为传送指令。而修改 CS、IP 的指令是 jmp 指令。jmp 指令被称为跳转指令，我们在[上一节](https://mp.weixin.qq.com/s?__biz=MzkwMjIzNjc4NA==&mid=2247484002&idx=1&sn=04c70a83762942802860ff7c30e9a2e3&chksm=c0a9dd7df7de546b6fcc55c2314c781d3cc5d5863e5b8401344fa7331b86a04aab9c29582b5b#rd)也说过了。

- `AX,BX,CX,DX` 寄存器

这四个寄存器也被称为**通用寄存器**.一般**用来存放数据**,一个寄存器可以存放 16bit ,也就是 2bytes. 所以也被称为 16 位寄存器。

这四个寄存器可以被分为两个 8 位寄存器，比如

```
AX = AH + AL， BX = BH+BL, CX = CH + CL,  DX = DH+DL
```

- DS 寄存器和 ES 寄存器

  - DS 数据段寄存器
  - ES 附加段寄存器

它们属于**段寄存器**，不能直接保存数据，只能通过其他的通用寄存器转存数据。它们俩没有明显的区别，但是 DS 是其他指针寄存器的默认段寄存器

- SS：堆栈段寄存器，存放堆栈的底部地址，

- ES: 扩展段寄存器，前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段；

- FS: 标志段寄存器，80386 起增加的两个辅助段寄存器之一，在这之前只有 es 寄存器；

- SP: 堆栈指针寄存器， SP(stack pointer) 存放栈的偏移地址;

- GS: 全局段寄存器

> `ds, es, fs, gs` 这类寄存器属于 sreg（状态寄存器），CPU 不能直接给它们赋值，只能通过其他寄存器来传入，比如可以使用 ax 寄存器来中转。所以不能写成 `mov ds: 0x7c00`，*0x7c00 是主引导记录起始地址*


### 写一个主引导记录MBR

我们需要先制作一个 img 镜像文件，直接使用 bximage 制作即可。具体步骤参考下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/制作img镜像.4k5q6jyxvs80.webp)


接着可以写汇编代码啦，下面的代码主要实现的功能是在屏幕上打印字符串 “1 ken" 其中背景是黑色，前景为绿色。

```x86asm
; 主引导程序
; --------------------------------------------------

SECTION MBR vstart=0x7c00  ; 在程序编译时，把起始地址编译为 0x7coo
; A处：利用 cs 寄存器的值去初始化其他寄存器
	mov ax, cs  ; cs 代码段寄存器
	mov ds, ax	; ax 是通用寄存器，一般用来存放数据，因为 ds,es,ss,fs 这些段寄存器不能直接保存数据
	mov es, ax	
	mov ss, ax  
	mov fs, ax  
	mov sp, 0x7c00  ; 初始化栈指针


; B处：这部分代码是实现 清屏 ，利用 0x06 号功能，上卷全部窗口，就可以清屏。
; --------------------------------------------------
; INT 0x10    功能号: 0x06    功能描述：上卷窗口
; --------------------------------------------------
; 输入：
; AH 功能号 = 0x06
; AL = 上卷的行数(如果为0，表示全部)
; BH = 上卷行属性
; (CL, CH) = 窗口左上角的 (X, Y) 位置
; (DL, DH) = 窗口右下角的 (X, Y) 位置
; 无返回值:
	mov ax, 0x600
	mov bx, 0x700
	mov cx, 0   ;左上角：（0,0)
	mov dx, 0x184f  ;右下角: (80, 25)
                   ; VGA 文本模式中，一行只能容纳 80 个字符，共 25 行
                   ; 下标从 0 开始，所以 0x18=24, 0x4f=79
	int 0x10	;中断
; --------------------------------------------------
; C处，获取光标位置
	; .get_cursor 获取当前光标位置，在光标处打印字符
	mov ah, 3	; 输入3号子功能是获取光标位置，需要存入 ah 寄存器中，ah 是 ax 的膏8位
	mov bh, 0   ; bh 寄存器存储的是待获取光标的页号

	int 0x10	; 输出：ch = 光标开始行，cl = 光标结束行
				; dh = 光标所在行号，dl = 光标所在列号

; D处：打印字符串
	mov ax, message
	mov bp, ax		;es:bp 为字符串首地址，es 这时候同 cs 一致
	; 光标位置要用到dx寄存器中内容，cs中的光标位置可以忽略
	mov cx, 5		; cx 为串长度，不包括结束符 '\0'
	mov ax, 0x1301	; 13号子功能，显示字符以及属性，需要存取 ah 寄存器
					; al = 01: 写字符方式，显式字符串，光标跟随移动
	mov bx, 0x2		; bh = 0,要显示的页号，此处是第0页
					; bl = 02，字符属性，黑底绿字
		
	int 0x10

; E处
	jmp $		; 程序悬停在这里

  ; 其定义了一个名为 message 的数组，数组元素的类型为 db （字节型）
	message db "1 ken"          
                                  ; db 字节型
                                  ; dw 字类型
                                  ; dd 双字型
                                  ; dq 四字型
                                  ; dt 十字节型 
    times 510-($-$$) db 0 ; 填充文件末尾的魔数 0xaa55 和当前位置之间的空间
                          ; 保证编译后生成的文件大小为 512 字节（硬盘一个扇区的大小）
    db 0x55, 0xaa
```

上述汇编代码中，

- A处的主要功能是初始化，用 cs 寄存器的值去初始化其他寄存器，因为 BIOS 是通过跳转指令 jmp 0: 0x7c00 跳转的，所以这时候 cs 的值为 0。

- B处是清屏操作，因为 BIOS 在工作中，会有一些日志输出，把它们清理掉方便观看我们自己输出的字符串

- C处是打印操作，为了避免打印字符混乱，或者覆盖其他输出，需要获取光标的位置。

- D处是往光标处打印字符
  - `mov ax, 0x1301` 13对应的是 ah 寄存器，这是调用 0x13 号子功能，01 对应的是 al 寄存器，表示写字符的方式。

- 代码中多处用到第 0x10 号中断，其调用方法是把功能号送入 ah 寄存器

> 上述代码更详细介绍可以参考《操作系统真象还原》第 62 页

然后编译 

```bash
nasm -o a.bin mbr.S
```

将编译后的 bin 文件写入扇区。

```bash
book@100ask:~/bochsken$ dd if=~/bochsken/boot/a.bin of=hd60M.img  seek=0 count=1 conv=notrunc

# 这里的 if=[输入]  of=[输出] 
# seek 跳过输出的几个单元开始写，一个单元512个字节
# count 是写的单元数
# notrunc 的意思就是不要截断
```

然后修改 `.disk` 配置文件，指定 `.img` 路径。通过 `vim bochsrc.disk` 插入下列代码：

```
ata0-master: type=disk, path="hd60M.img", mode=flat,cylinders=2,heads=16,spt=63
```

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/修改disk配置文件.2yxgsiyytsm0.webp)

接下来通过 bochs 测试，`bin/bochs -f bochsrc.disk`，如下图所示。如果想退出就在控制台按 `ctrl+C` 然后输入 `quit`

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/第二章结果.65acf1bf3u80.png)

> **好啦。大功告成！！！**


> 《[阮一峰的理解计算机](http://www.ruanyifeng.com/blog/2015/09/0x7c00.html)》学习笔记
> 
> 《操作系统真象还原》读书笔记

## 第三章

----

本文分成四部分

- 第一部分，数组的起始下表为什么是 0 而不是 1
- 用两张图来介绍 CPU 的工作原理
- 实现 MBR 操作显示器
- MBR 操作磁盘

### 为什么数组的起始下标是 0 而不是 1 

在编译器中，占据第一位的数据的地址就是其实地址，然后它后面的其他数据一次排开就行。就比如第 n 个位置的地址是 (n-1) + 数据(n-1)的内存空间 ,由于程序的第 1 个数据的地址（偏移量）是 0 ，所以数组中第 1 个元素的下标也是 0.

> 所以每个变量的地址就是前一个变量的地址 + 前一个变量的内存空间大小

回到开始的问题，为什么数组的起始下标是0而不是 1 ？？

- 数组（Array）一种线性表数据结构，用一组连续的内存空间，存储一组相同类型的数据

连续的内存空间和相同的数据结构，使其可以“随机访问”，弊端也很明显，某些操作十分低效。在数组中删除或插入数据时，要做大量的数据搬移工作。

从数组中存储的数据模型来看，下标最精确的意思是“偏移量”，`a[0]` 的偏移量是 0，即为首地址。`a[i]` 的偏移量是 i，寻址公式就是 `a[i]_address = base_address + i*data_type_size`。

如果下标从 1 开始，那对应的寻址公式 `a[i]_address = base_address + （i-1）*data_type_size`。对 CPU 来说，每次随机访问，就多了一次运算，多发一条指令。

简单来说，就是假如数组的首地址是 base_address，如果索引从 1 开始计，元素 a[1] 是第一个元素，它的地址就是 base_address，当我们要获取第 8 个元素 a[8] 的数据时，计算机就要找到元素 a[8] 所在的地址，计算公式就是`base_address+(8-1)*type_size` 。

如果索引从 0 开始计，元素 a[0] 是第一个元素，它的地址就是 base_address，当我们要获取第 8 个元素 a[7] 的数据时，计算机就要找到元素 a[7] 所在的地址，计算公式就是 `base_address+7*type_size` 。

我们发现，索引从 0 开始，寻址时会**少做一次减法**，这就是一个优化，别小看这种优化，计算的数量一旦上去，比如上亿次计算，那积累起来的优势是相当可观的。

其实，各种算法的优化，本质都是一样的，让计算机做更少的计算，只有做的事情少了，效率才会提高。


### CPU的工作原理

我们应该都知道，**CPU 的唯一任务就是执行指令**，也就是一串串 010101.....。CPU从逻辑上可以划分成3个模块，分别是**控制单元**、**运算单元**和**存储单元**，这三部分由CPU内部总线连接起来。如下所示：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/CPU的组成.6n3qmc9vhq00.png)


- 控制单元是整个 CPU 的指挥控制中心，由程序计数器 PC（Program Counter）, 指令寄存器 IR (Instruction Register)、指令译码器 ID (Instruction Decoder)和 操作控制器 OC (Operation Controller)等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器 IR 中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器 OC，按确定的时序，向相应的部件发出微操作控制信号。

- 运算单元：是运算器的核心。可以执行算术运算(包括加减乘数等基本运算及其附加运算)和逻辑运算(包括移位、逻辑测试或两个值比较)。，运算器接受控制单元的命令而进行动作，

- 存储单元：包括 CPU 片内缓存和寄存器组，是 CPU 中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据。CPU 访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。但因为受到芯片面积和集成度所限，寄存器组的容量不可能很大。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/CPU工作原理.2s7fwqxli5s0.png)

现在结合上图简单说下 CPU 的工作过程

控制单元要取出下一条运行的指令，这个指令在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs: ip（在之前[这篇文章](https://mp.weixin.qq.com/s?__biz=MzkwMjIzNjc4NA==&mid=2247484002&idx=1&sn=04c70a83762942802860ff7c30e9a2e3&chksm=c0a9dd7df7de546b6fcc55c2314c781d3cc5d5863e5b8401344fa7331b86a04aab9c29582b5b&token=1518323587&lang=zh_CN#rd)中说过其实就是 cs 寄存器和 ip 寄存器），所以读取 ip 寄存器后，将这个地址送到 【地址总线】。

这个时候 CPU 就可以根据这个地址得到了【指令】，然后将这个指令存入指令寄存器 IR 中。

接着由控制单元当中的指令译码器 ID 来分析这个指令是什么操作，然后确定操作码，然后 ID 还要去检查操作数的类型，如果操作数在内存中就直接将操作数放到自己的存储单元中，如果在寄存器中就将这个操作数和操作码一并传递给【运算单元】，由运算单元执行指令。

接着控制单元又取下一条指令，就这样循环下去一直到 CPU 断电。

> 上面讲了很多枯燥的理论，理论的分析先告一段落，还是写写代码跑跑比较有激情点。

### 让 MBR 直接操作显卡

```
; 主引导程序
; --------------------------------------------------

SECTION MBR vstart=0x7c00  ; 在程序编译时，把起始地址编译为 0x7coo
; A处：利用 cs 寄存器的值去初始化其他寄存器
	mov ax, cs  ; cs 代码段寄存器
	mov ds, ax	; ax 是通用寄存器，一般用来存放数据，因为 ds,es,ss,fs 这些段寄存器不能直接保存数据
	mov es, ax	
	mov ss, ax  
	mov fs, ax  
	mov sp, 0x7c00  ; 初始化栈指针
	mov ax, 0xb800	;文本模式中，其内存的起始地址是 0xb800
	mov gs, ax  	; 往 gs 寄存器中存入段基地址


; --------------------------------------------------
; INT 0x10    功能号: 0x06    功能描述：上卷窗口
; --------------------------------------------------
; 输入：
; AH 功能号 = 0x06
; AL = 上卷的行数(如果为0，表示全部)
; BH = 上卷行属性
; (CL, CH) = 窗口左上角的 (X, Y) 位置
; (DL, DH) = 窗口右下角的 (X, Y) 位置
; 无返回值:
	mov ax, 0x600
	mov bx, 0x700
	mov cx, 0   ;左上角：（0,0)
	mov dx, 0x184f  ;右下角: (80, 25)
                   ; VGA 文本模式中，一行只能容纳 80 个字符，共 25 行
                   ; 下标从 0 开始，所以 0x18=24, 0x4f=79
	int 10h	;中断
; --------------------------------------------------
	; A处：输出背景颜色为绿色，前景颜色为红色，并且设置跳动的字符串“1 Ken"
   mov byte [gs:0x00],'1'
   mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色

   mov byte [gs:0x02],' '
   mov byte [gs:0x03],0xA4

   mov byte [gs:0x04],'K'
   mov byte [gs:0x05],0xA4   

   mov byte [gs:0x06],'e'
   mov byte [gs:0x07],0xA4

   mov byte [gs:0x08],'n'
   mov byte [gs:0x09],0xA4

  ; 其定义了一个名为 message 的数组，数组元素的类型为 db （字节型）
	message db "1 ken"          
                                  ; db 字节型
                                  ; dw 字类型
                                  ; dd 双字型
                                  ; dq 四字型
                                  ; dt 十字节型 
    times 510-($-$$) db 0 ; 填充文件末尾的魔数 0xaa55 和当前位置之间的空间
                          ; 保证编译后生成的文件大小为 512 字节（硬盘一个扇区的大小）
    db 0x55, 0xa
```

在上面代码的 A 处，`mov byte [gs:0x00],'1'` 这句代码的意思是 gs 为数据段基址，以 0 为偏移地址的内存中写入字符 1。这里的 byte 关键字是用来指定操作数的占用空间。

现在开始编译查看效果

```bash
$ nasm mbr.S -o b.bin
$ dd if=b.bin of=../hd60M.img bs=512 count=1 conv=notrunc
1+0 records in
1+0 records out
512 bytes copied, 0.000286874 s, 1.8 MB/s
```

然后启动 boch 执行 c 命令，在屏幕上出现 绿色和红色 跳动的字符。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/显示闪烁.115y0updrnn4.png)

> 还有 bochs 调试部分没有总结出来，我觉得这部分的命令需要多练习才会记得住，全部列出来感觉用处不大，感兴趣的朋友可以参考原书《操作系统真象还原》115-122 页。

------

### MBR使用磁盘

为了能让 MBR 使用磁盘。我们对之前的 mbr.S 进行改造，当然还是要受限于 512 字节大小的限制，因为只有 512 字节的空间，没办法加载各种内核环境并运行，所以需要借助另一个程序来完成这部分工作，就是加载器，loader。简单地说就是把硬盘中的 loader 加载到内存，然后将加载内核环境的这些任务交给 loader。

MBR 在第 0 扇区，第 1 扇区是空闲的，加载的 loader 在第 2 扇区，其中 loader 要定义一些数据结构（如 GDT 全局描述表），本实验中参考原书的方式，将 loader 加载存放数据的地址设置为 0x900。


首先我们需要在原来代码文件夹下新建一个 include 文件夹，放 boot.inc 文件

```
book@100ask:~/bochsken/boot/include$ vim boot.inc

; 添加如下代码
;-------------	 loader和kernel   ----------
LOADER_BASE_ADDR equ 0x900 
LOADER_START_SECTOR equ 0x2
```

然后开始写代码，更详细的介绍看代码注释和原书第 133-135页。

- **mbr.S**

```
; 主引导程序
; --------------------------------------------------
; 下面这一行代码是 nasm 编译器中的预处理指令，
; 目的是让编译器在编译之间把 boot.inc 文件包含进来
%include "boot.inc"

SECTION MBR vstart=0x7c00         
   mov ax,cs      
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00
   mov ax,0xb800
   mov gs,ax

; 清屏
   mov     ax, 0600h
   mov     bx, 0700h
   mov     cx, 0                   ; 左上角: (0, 0)
   mov     dx, 184fh		   ; 右下角: (80,25),
				   ; 因为VGA文本模式中，一行只能容纳80个字符,共25行。
				   ; 下标从0开始，所以0x18=24,0x4f=79
   int     10h                     ; int 10h

   ; 输出字符串:MBR
   mov byte [gs:0x00],'1'
   mov byte [gs:0x01],0xA4

   mov byte [gs:0x02],' '
   mov byte [gs:0x03],0xA4

   mov byte [gs:0x04],'K'
   mov byte [gs:0x05],0xA4	   ;A表示绿色背景闪烁，4表示前景色为红色

   mov byte [gs:0x06],'e'
   mov byte [gs:0x07],0xA4

   mov byte [gs:0x08],'n'
   mov byte [gs:0x09],0xA4
	 
   mov eax,LOADER_START_SECTOR	 ; 起始扇区lba地址，它等于 0x2，也就是前面说的吧 loader 放到第 2 扇区
   ;数据从硬盘中读进来后存放的位置，由寄存器 bx 指定
   mov bx,LOADER_BASE_ADDR       ; 写入的地址，MBR 要把 loader 从硬盘中读入后放到这里，也就是 0x900
   mov cx,1			 ; 待读入的扇区数，这个由文件大小来定读几个扇区
   call rd_disk_m_16		 ; 以下读取程序的起始部分（一个扇区）
  
   jmp LOADER_BASE_ADDR
       
;-----------------------------------------------------------------
;功能:读取硬盘n个扇区
; 因为汇编可以直接操作寄存器，所以在汇编中定义函数传递参数可以用 【寄存器】,也可以用【栈】
rd_disk_m_16:	      ; 在 16 位模式下读硬盘
;-----------------------------------------------------------------
				       ; eax=LBA扇区号
				       ; ebx=将数据写入的内存地址
				       ; ecx=读入的扇区数
      mov esi,eax	  ;把 eax 中的值备份到 esi 中，因为 al 在 out 指令中会被用到，这会影响到 eax 的低 8 位
      mov di,cx		  ;备份cx，备份数据的扇区到 di 寄存器。di 寄存器是 16 位。
;读写硬盘:
;第1步：设置要读取的扇区数
      mov dx,0x1f2
      mov al,cl
      out dx,al            ;读取的扇区数

      mov eax,esi	   ;恢复ax

;第2步：将LBA地址存入0x1f3 ~ 0x1f6

      ;LBA地址7~0位写入端口0x1f3
      mov dx,0x1f3                       
      out dx,al                          

      ;LBA地址15~8位写入端口0x1f4
      mov cl,8
      shr eax,cl
      mov dx,0x1f4
      out dx,al

      ;LBA地址23~16位写入端口0x1f5
      shr eax,cl
      mov dx,0x1f5
      out dx,al

      shr eax,cl
      and al,0x0f	   ;lba第24~27位
      or al,0xe0	   ; 设置7～4位为1110,表示lba模式
      mov dx,0x1f6
      out dx,al

;第3步：向0x1f7端口写入读命令，0x20 
      mov dx,0x1f7
      mov al,0x20                        
      out dx,al

;第4步：检测硬盘状态
  .not_ready:
      ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
      nop
      in al,dx
      and al,0x88	   ;第4位为1表示硬盘控制器已准备好数据传输，第7位为1表示硬盘忙
      cmp al,0x08
      jnz .not_ready	   ;若未准备好，继续等。

;第5步：从0x1f0端口读数据
      mov ax, di
      mov dx, 256
      mul dx
      mov cx, ax	   ; di为要读取的扇区数，一个扇区有512字节，每次读入一个字，
			   ; 共需di*512/2次，所以di*256
      mov dx, 0x1f0
  .go_on_read:
      in ax,dx
      mov [bx],ax
      add bx,2		  
      loop .go_on_read
      ret

   times 510-($-$$) db 0
   db 0x55,0xaa

```

- **loader.S**

```
%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR

; 输出背景色绿色，前景色红色，并且跳动的字符串"1 MBR"
mov byte [gs:0x00],'2'
mov byte [gs:0x01],0xA4     ; A表示绿色背景闪烁，4表示前景色为红色

mov byte [gs:0x02],' '
mov byte [gs:0x03],0xA4

mov byte [gs:0x04],'L'
mov byte [gs:0x05],0xA4   

mov byte [gs:0x06],'O'
mov byte [gs:0x07],0xA4

mov byte [gs:0x08],'A'
mov byte [gs:0x09],0xA4

mov byte [gs:0x0a],'D'
mov byte [gs:0x0b],0xA4

mov byte [gs:0x0c],'E'
mov byte [gs:0x0d],0xA4

mov byte [gs:0x0e],'R'
mov byte [gs:0x0f],0xA4

jmp $		       ; 通过死循环使程序悬停在此
```

然后编译，需要编译两个 `.S` 文件

```
$ nasm -I include/ mbr.S -o mbr.bin
$ dd if=mbr.bin if=../hd60M.img bs=512 count=1 seek=0 conv=notrunc

$ nasm -I include/ loader.S -o loader.bin
$ dd if=./loader.bin of=../hd60M.img bs=512 count=1 seek=2 conv=notrunc
```

编译后所有的文件如下

```
book@100ask:~/bochsken/boot$ tree
.
├── include
│   └── boot.inc
├── loader.bin
├── loader.S
├── mbr.bin
└── mbr.S
```

启动 bochs 查看结果


![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/读取磁盘结果.6yguv6spfds0.png)

> 学习这些内容对汇编的功底要求比较高，推荐想全面学习汇编的同学可以去看王爽的《汇编语言》那本书，之后计划在公众号中也会出一篇关于这本书的读书笔记。

-------

## 第4章

- 进入保护模式

```
$ nasm -I include/ mbr.S -o mbr.bin
$ dd if=./mbr.bin of=hd60M.img bs=512 count=1 conv=notrunc

$ nasm -I include/ loader.S -o loader.bin
$ dd if=./loader.bin of=hd60M.img bs=512 count=4 seek=2 conv=notrunc
```


[参考]https://blog.csdn.net/orange1710/article/details/121347225?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&utm_relevant_index=1