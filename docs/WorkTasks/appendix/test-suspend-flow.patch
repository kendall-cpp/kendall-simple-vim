From f182038fdb703a123d7d4f20101532d5d1297f70 Mon Sep 17 00:00:00 2001
From: "shengken.lin" <shengken.lin@amlogic.com>
Date: Mon, 6 Feb 2023 16:18:42 +0800
Subject: [PATCH] [Sonos][Dont't Merge] test suspend flow for kernel-linux
 riscv-rots hifi5dsp-rtos

Signed-off-by: shengken.lin <shengken.lin@amlogic.com>
---
 drivers/base/power/main.c |  2 +-
 kernel/power/main.c       |  7 +++++--
 kernel/power/suspend.c    | 18 +++++++++---------
 3 files changed, 15 insertions(+), 12 deletions(-)

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 0c309fa1e9d5..1678da08fe9c 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -2068,7 +2068,7 @@ int dpm_suspend_start(pm_message_t state)
 		suspend_stats.failed_prepare++;
 		dpm_save_failed_step(SUSPEND_PREPARE);
 	} else
-		error = dpm_suspend(state);
+		error = dpm_suspend(state); // 准备好之后，执行所有设备的 suspend 回调函数
 	dpm_show_time(starttime, state, error, "start");
 	return error;
 }
diff --git a/kernel/power/main.c b/kernel/power/main.c
index 718884857830..d8935e1745fa 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -614,12 +614,15 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 		goto out;
 	}
 
-	state = decode_state(buf, n);
+	/* 
+	 * 解析当前传入的state。如果state小于PM_SUSPEND_MAX就走suspend流程，等于PM_SUSPEND_MAX就走hibernate(和sleep 类似)流程。加入我们传入的是mem, 则就会走suspend流程。
+	 * */
+	state = decode_state(buf, n);  // 根据写入的字符串，转换得到状态； echo "mem" > /sys/power/state
 	if (state < PM_SUSPEND_MAX) {
 		if (state == PM_SUSPEND_MEM)
 			state = mem_sleep_current;
 
-		error = pm_suspend(state);
+		error = pm_suspend(state); // 跳到 power/suspend.c 
 	} else if (state == PM_SUSPEND_MAX) {
 		error = hibernate();
 	} else {
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 1c8b584889b2..7f70d8aeb7d4 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -513,9 +513,9 @@ int suspend_devices_and_enter(suspend_state_t state)
 	if (error)
 		goto Close;
 
-	suspend_console();
+	suspend_console(); //关闭控制台， suspend console 子系统，printk 不能再打印
 	suspend_test_start();
-	error = dpm_suspend_start(PMSG_SUSPEND);
+	error = dpm_suspend_start(PMSG_SUSPEND); //Suspend所有非系统设备，即调用所有注册设备的suspend回调函数
 	if (error) {
 		pr_err("Some devices failed to suspend, or early wake event detected\n");
 		log_suspend_abort_reason(
@@ -569,7 +569,7 @@ static void suspend_finish(void)
  * Fail if that's not the case.  Otherwise, prepare for system suspend, make the
  * system enter the given sleep state and clean up after wakeup.
  */
-static int enter_state(suspend_state_t state)
+static int enter_state(suspend_state_t state)  // state = PM_SUSPEND_MEM
 {
 	int error;
 
@@ -596,9 +596,9 @@ static int enter_state(suspend_state_t state)
 		trace_suspend_resume(TPS("sync_filesystems"), 0, false);
 	}
 
-	pm_pr_dbg("Preparing system for sleep (%s)\n", mem_sleep_labels[state]);
+	pm_pr_dbg("Preparing system for sleep (%s)\n", mem_sleep_labels[state]);  //休眠准备完毕， done
 	pm_suspend_clear_flags();
-	error = suspend_prepare(state);
+	error = suspend_prepare(state); //进入suspend的准备，包含选择控制台和进程冻结，如果失败，则终止suspend
 	if (error)
 		goto Unlock;
 
@@ -608,13 +608,13 @@ static int enter_state(suspend_state_t state)
 	trace_suspend_resume(TPS("suspend_enter"), state, false);
 	pm_pr_dbg("Suspending system (%s)\n", mem_sleep_labels[state]);
 	pm_restrict_gfp_mask();
-	error = suspend_devices_and_enter(state);
+	error = suspend_devices_and_enter(state); // suspend 的主要操作
 	pm_restore_gfp_mask();
 
  Finish:
 	events_check_enabled = false;
 	pm_pr_dbg("Finishing wakeup.\n");
-	suspend_finish();
+	suspend_finish(); // 结束suspend , 系统被唤醒
  Unlock:
 	mutex_unlock(&system_transition_mutex);
 	return error;
@@ -627,7 +627,7 @@ static int enter_state(suspend_state_t state)
  * Check if the value of @state represents one of the supported states,
  * execute enter_state() and update system suspend statistics.
  */
-int pm_suspend(suspend_state_t state)
+int pm_suspend(suspend_state_t state) // state = PM_SUSPEND_MEM
 {
 	int error;
 
@@ -635,7 +635,7 @@ int pm_suspend(suspend_state_t state)
 		return -EINVAL;
 
 	pr_info("suspend entry (%s)\n", mem_sleep_labels[state]);
-	error = enter_state(state);
+	error = enter_state(state); // suspend的入口点，是进入系统睡眠所需的公共准备工作
 	if (error) {
 		suspend_stats.fail++;
 		dpm_save_failed_errno(error);
-- 
2.25.1

