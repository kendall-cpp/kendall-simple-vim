
- [环境准备](#环境准备)
- [安装 Bochs](#安装-bochs)
- [汇编语言](#汇编语言)
	- [写一个 BIOS 引导程序](#写一个-bios-引导程序)
	- [创建虚拟软盘镜像](#创建虚拟软盘镜像)

## 环境准备

首先需要准备一个虚拟机软件（VMWare 或者 VirtualBox），然后就是 linux 操作系统，具体的安装教程可以自行网上搜索。

我这里选择的开发环境是 VMWare + Ubuntu 18.4 + Bochs

> **接下来开始环境搭建**

## 安装 Bochs

- 下载 bochs-2.6.8.tar.gz

下载地址：(可能会失效，失效了到 bochs  官网下载)

```
https://udomain.dl.sourceforge.net/project/bochs/bochs/2.6.8/bochs-2.6.8.tar.gz
```

解压之后进入到 bochs-2.6.8 目录

- 通过 configure，make，make install 进行安装。

```
cd bochs-2.6.8/

./configure --with-x11 --with-wx --enable-debugger --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo

```

make 

sudo make install

## 汇编语言

本系统中的 BootLoader 部分采用的是 Intel 汇编语言进行编写，使用 nasm 编译器进行编译，操作系统的内核与应用程序采用 AT&T 格式的汇编语言编写，使用 GNU 的 GAS 编译器进行编译。

>- 注意 Intel 汇编语言的赋值方向是从右到左，而 AT&T 汇编语言是从左到右。		
> - AT&T 汇编语言使用【寄存器】必须在前面添加前缀 % ，使用【立即数】必须在前面添加前缀 $，比如：mov $12,%cx

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/两种汇编的区别.28waarmj82sk.png)

反汇编

```
$ gcc test.c -o test
$ objdump -d test
```


过滤掉多余的代码，剩下 test 和 main 部分

```X86asm
00000000000005fa <test>:
 5fa:   55                      push   %rbp
 5fb:   48 89 e5                mov    %rsp,%rbp   ; rsp 表示64位寄存器，是32位寄存器esp的扩展
 5fe:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
 605:   83 45 fc 02             addl   $0x2,-0x4(%rbp)
 609:   8b 45 fc                mov    -0x4(%rbp),%eax
 60c:   5d                      pop    %rbp
 60d:   c3                      retq   

000000000000060e <main>:    ; 函数的起始地址，每个数字占4位，共16位数字，也就说明该地址运行在 4x16=64 为地址宽度下
 60e:   55                      push   %rbp
 60f:   48 89 e5                mov    %rsp,%rbp   ; AT&T汇编语言寄存器前面加%，立即数前面加$
 612:   b8 00 00 00 00          mov    $0x0,%eax
 617:   e8 de ff ff ff          callq  5fa <test>   ; q 表示操作数的位宽是64位(四字)  ; 跳转到 test函数
 61c:   b8 00 00 00 00          mov    $0x0,%eax
 621:   5d                      pop    %rbp
 622:   c3                      retq   
 623:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
 62a:   00 00 00 
 62d:   0f 1f 00                nopl   (%rax)   ; l 表示操作数的位宽是32位(双字)
```


call 指令和 jmp 指令的区别：call 指令会把其后的哪天指令的地址压入栈中，作为调用的返回地址，也就是 000000000000061c 地址处，随后跳到 test
函数执行，但是 jmp 指令不会把返回地址 000000000000061c 压入栈中，一旦 test 函数执行完毕，蝙蝠执行 retq 把栈中的返回地址弹出 RIP 寄存器中。进而返回到 main 函数继续执行。

我们也可以使用下面方式代替 call 功能，就是先主动把 000000000000061c 地址压入栈中。

```x86asm
pushq 000000000000061c
jmp  5fa <test>
```

### 写一个 BIOS 引导程序

boot.asm

```

```

### 创建虚拟软盘镜像

字节输入 bximage

选择 fd

```
nasm boot.asm -o boot.bin
dd if=boot.bin of=../bochs-2.6.8/boot.img bs=512 count=1 conv=notrunc

bochs -f .bochsrc
```

报错

```
$ bochs -f .bochsrc
========================================================================
                        Bochs x86 Emulator 2.6
            Built from SVN snapshot on September 2nd, 2012
========================================================================
00000000000i[     ] LTDL_LIBRARY_PATH not set. using compile time default '/usr/lib/bochs/plugins'
00000000000i[     ] BXSHARE not set. using compile time default '/usr/share/bochs'
00000000000i[     ] lt_dlhandle is 0x55eedbb5cda0
00000000000i[PLGIN] loaded plugin libbx_unmapped.so
00000000000i[     ] lt_dlhandle is 0x55eedbb5e410
00000000000i[PLGIN] loaded plugin libbx_biosdev.so
00000000000i[     ] lt_dlhandle is 0x55eedbb5fd80
00000000000i[PLGIN] loaded plugin libbx_speaker.so
00000000000i[     ] lt_dlhandle is 0x55eedbb605a0
00000000000i[PLGIN] loaded plugin libbx_extfpuirq.so
00000000000i[     ] lt_dlhandle is 0x55eedbb60d80
00000000000i[PLGIN] loaded plugin libbx_parallel.so
00000000000i[     ] lt_dlhandle is 0x55eedbb629c0
00000000000i[PLGIN] loaded plugin libbx_serial.so
00000000000i[     ] lt_dlhandle is 0x55eedbb66770
00000000000i[PLGIN] loaded plugin libbx_gameport.so
00000000000i[     ] lt_dlhandle is 0x55eedbb67030
00000000000i[PLGIN] loaded plugin libbx_iodebug.so
00000000000i[     ] reading configuration from .bochsrc
00000000000p[     ] >>PANIC<< .bochsrc:14: ataX-master/slave: unknown type 'none'
00000000000e[CTRL ] notify called, but no bxevent_callback function is registered
00000000000i[CPU0 ] CPU is in real mode (active)
00000000000i[CPU0 ] CS.mode = 16 bit
00000000000i[CPU0 ] SS.mode = 16 bit
00000000000i[CPU0 ] EFER   = 0x00000000
00000000000i[CPU0 ] | EAX=00000000  EBX=00000000  ECX=00000000  EDX=00000000
00000000000i[CPU0 ] | ESP=00000000  EBP=00000000  ESI=00000000  EDI=00000000
00000000000i[CPU0 ] | IOPL=0 id vip vif ac vm rf nt of df if tf sf ZF af PF cf
00000000000i[CPU0 ] | SEG sltr(index|ti|rpl)     base    limit G D
00000000000i[CPU0 ] |  CS:0000( 0000| 0|  0) 00000000 00000000 0 0
00000000000i[CPU0 ] |  DS:0000( 0000| 0|  0) 00000000 00000000 0 0
00000000000i[CPU0 ] |  SS:0000( 0000| 0|  0) 00000000 00000000 0 0
00000000000i[CPU0 ] |  ES:0000( 0000| 0|  0) 00000000 00000000 0 0
00000000000i[CPU0 ] |  FS:0000( 0000| 0|  0) 00000000 00000000 0 0
00000000000i[CPU0 ] |  GS:0000( 0000| 0|  0) 00000000 00000000 0 0
00000000000i[CPU0 ] | EIP=00000000 (00000000)
00000000000i[CPU0 ] | CR0=0x00000000 CR2=0x00000000
00000000000i[CPU0 ] | CR3=0x00000000 CR4=0x00000000
bx_dbg_read_linear: physical memory read error (phy=0x0000000000000000, lin=0x0000000000000000)
00000000000i[CTRL ] quit_sim called with exit code 1
```

