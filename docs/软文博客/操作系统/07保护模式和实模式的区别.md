
> 最近把大部分精力分摊到论文去了，导致这方面的学习懈怠了许多 ~~~

说到操作系统，基本上都会涉及到实模式和保护模式，在前面的笔记推文中都是基于实模式进行的。今天来学习一下保护模式吧。

> 你知道你家电脑为什么会蓝屏吗？想知道那就往下看吧。

## 回顾一下实模式

首先来回顾一下什么是实模式？

在计算机里面，实模式的存在时间非常短，短到我们一般都感觉不到它的存在，CPU 以实模式进行工作时，不能实现权限分级，也不能访问20位以上的地址线，也就是只能访问1M内存。之后一般就加载操作系统模块，进入保护模式。

前面说过，8086 CPU 有 20 根地址线，可以寻址 1MB 内存，但是，它内部的寄存器是 16 位的，无法在程序中访问整个 1MB 内存，所以，就有了分段机制，这部分可以参考[这篇推文笔记中【那CPU咋寻址的呢】部分](https://mp.weixin.qq.com/s?__biz=MzkwMjIzNjc4NA==&mid=2247484159&idx=1&sn=46f653ea6298fa1bcc2bc584f9eeeb0f&chksm=c0a9dde0f7de54f6d81afed9bbf914041a1b3253f8436e71c9abe526f42b655503b9ca2e5acf&token=1333820132&lang=zh_CN#rd)。

但是随着计算机技术的发展，16 CPU 已经不够用了，所以在 8086 CPU 的对推动下，Intel 不断研发更新处理器，所以有了 32 位 CPU。32 为 CPU 有着自己的 32 位工作模式，保护模式就是 32 位模式，在这种模式下，可以完全，充分发挥 CPU 的性能，同时，在这种模式下，CPU 可以使用它全部的 32 根 地址线，能够访问 4GB 内存。

**简单总结：**

实模式存在的缺陷

- 应用程序应用的地址就是真实的物理地址，也就是逻辑地址等于物理地址
- 访问超过 64KB 的内存就要切换段地址，麻烦
- 一次只能运行一个程序，不能充分利用计算机资源
- 总共 20 条地址线，最大可用内存为 1MB
  
## 你知道你家电脑为什么会蓝屏吗

在 windows 的版本中（旧版本比较多），我们时不时就死机或者蓝屏，其实发生这些问题大部分就是由于内存被破坏引起的。因为在实模式中，将整个物理内存看成分段的区域，程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向"实在"的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，那么对于这个被修改的系统程序或用户程序，容易造成软件甚至系统崩溃。

但是在保护模式下，32 条地址线全部有效，可寻址的范围达到 4GB 的内存空间，这样的话就可以支持多任务，并且能够进行任务切换。此外，保护模式有特权等级检查机制，既能实现资源共享又能保证代码和数据的安全和保密及任务的隔离，支持虚拟 8086 方式，便于执行 8086 程序。

## 保护模式的寻址方式

我们应该还记得，在实模式下，内存寻址方式是：段地址 x 16 + 偏移地址，段地址之所以要乘以 16，那是因为一个 16 位的寄存器无法访问全部的 1MB 空间，受限于当时 CPU 的局限，只能通过打补丁的方式解决。在保护模式中，寻址方式和实模式还是一样的，都是：**段 + 偏移**，但对于 32 位 CPU，寄存器也应该改造成 32 位，才能保证寻址空间达到 4GB。不过段寄存器仍保留为原来的 16 位，只是保护模式下的段寄存器存储的是不是段基地址了，而是“**段选择子**”，也就是全局描述符表（GDT）的索引。

GDT 的作用是用来提供段式存储机制，我们把这些关于内存段的信息放在一个叫做全局描述符表( GDT )的结构里。全局描述符表中含有一个个表项，每一个表项称为 **段描述符**。而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性(比如是数据段还是代码段,注意一个段描述符只能用来定义一个内存段)等许多属性,具体信息见下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/段描述符格式.abtdx7x0qog.png)

关于分段机制这里推荐一篇非常精致的文章[**分段机制与GDT|LDT**](https://www.cnblogs.com/chenwb89/p/operating_system_003.html#commentform)，大家可以通过这里深入学习。

> 好了，今天的笔记就分享到这里吧 ~~~
