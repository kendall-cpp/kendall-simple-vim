## 索引的概念
索引能快速找出在某一列中有一特定值的行。不使用索引，mysql必须从第一条记录开始查找，直到找到相关的行。如果表中查询的列有一个索引，mysql能快速到达某个位置去搜索数据文件，而不必查看所有数据。索引是对数据库中一列或多列的值进行排序的一种结构。

## 索引的创建和删除

### 索引的类型

- unique：唯一索引，不允许出现相同的值，允许为 NULL
- index：普通索引，允许出现相同值
- primary key：主键索引，不允许出现相同值
- fulltext index：全文索引，可针对值中的某个单词建立索引，但效率很低
- 组合索引：又称复合索引，将多个字段建立到一个索引里，列值的组合必须唯一

> 《阿里巴巴 Java 开发手册》中的 SQL 规范约定，唯一索引建议命名为 uk_字段名，普通索引命名为 idx_字段名

### 创建索引
- 使用alter table语句在存在的表上创建和删除索引
```
// 创建索引
alter table table_name add index(column_name);
// 删除索引
alter table table_name drop index index_name;
```
创建索引示例：
```
// 普通索引
ALTER TABLE users ADD INDEX idx_name (name);
// 唯一索引
ALTER TABLE users ADD UNIQUE uk_name (name);
// 主键索引
ALTER TABLE users ADD PRIMARY KEY (name);
```
- 使用create index语句在已存在的表上创建和删除索引
```
// 创建索引
create index index_name on table_name(column_name);
// 删除索引
drop index index_name on table_name;(内部被映射成alter table语句)
```

## 索引的一些基础知识
（1）索引可以加快数据库的检索速度。     
（2）索引会降低插入，删除，修改的速度。     
（3）索引需要占用物理和数据空间。       
（4）索引的最左匹配原则。       
（5）索引的分类：聚集索引和非聚集索引。     
（6）MySQL支持Hash索引和B+树索引。      

## 索引的原理

### 聚集索引

一般的数据库都是把**平衡树**当做数据表默认的索引数据结构，也就是`b tree`或者 `b+ tree`。重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构。
在我们建表的时候通常会为表加上主键，在一些关系型数据库中，如果不加主键会拒绝建表语句的执行，如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 整个表变成了一个索引，也就是所谓的 **聚集索引**。 这就是为什么一个表只能有一个主键， 一个表只能有一个**聚集索引**，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。

![](./img/索引01.jpg)

上图就是带有主键的表（聚集索引）的结构图,其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：
```
select * from table where id = 1256;
```

首先根据索引定位到1256这个值所在的叶子结点，然后再通过叶子结点取到id等于1256的数据行。 *这里不讲解平衡树的运行细节*， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图

![](./img/索引02.jpg)

假如一张表有一亿条数据 ，需要查找其中某一条数据，按照常规逻辑， 一条一条的去匹配的话， 最坏的情况下需要匹配一亿次才能得到结果，用大O标记法就是O(n)最坏时间复杂度，这是无法接受的，而且这一亿条数据显然不能一次性读入内存供程序使用， 因此， 这一亿次匹配在不经缓存优化的情况下就是一亿次IO开销，以现在磁盘的IO能力和CPU的运算能力， 有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有10层，那么只需要10次IO开销就能查找到所需要的数据， 速度以指数级别提升，用大O标记法就是`O(log n)`，n是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数，用公式来表示就是：

![](./img/索引03.png)

用程序来表示就是`Math.Log(100000000,10)`，`100000000`是记录数，`10`是树的分叉数（真实环境下分叉数远不止10）， 结果就是查找次数，这里的结果从亿降到了个位数。因此，利用索引会使数据库查询有惊人的性能提升。

虽然索引能让数据库查询速度上升，但是会使写入的速度下降，因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，还会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。

### 非聚集索引

非聚集索引， 也就是我们平时经常提起和使用的常规索引

非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 如下图：

![](./img/索引04.jpg)

每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。

非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，如下图

![](./img/索引05.jpg)

不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。

然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。

先看下面这个SQL语句
```
//建立索引

create index index_birthday on user_info(birthday);

//查询生日在1991年11月1日出生用户的用户名

select user_name from user_info where birthday = '1991-11-1'

这句SQL语句的执行过程如下

首先，通过非聚集索引index_birthday查找birthday等于1991-11-1的所有记录的主键ID值

然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置

最后， 从得到的真实数据中取得user_name字段的值返回， 也就是取得最终的结果

我们把birthday字段上的索引改成双字段的覆盖索引

create index index_birthday_and_user_name on user_info(birthday, user_name);
```
这句SQL语句的执行过程就会变为

通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能，如下图
![](./img/索引06.jpg)

数据库索引的大致工作原理就是像文中所述， 然而细节方面可能会略有偏差，这但并不会对概念阐述的结果产生影响 。

### 总结
**简单概括**

- 聚集索引就是以主键创建的索引。
- 非聚集索引就是以非主键创建的索引。

**区别**

- 聚集索引在叶子节点存放的表中的数据。
- 非聚集索引在叶子节点中存放的是主键和索引列。
- 使用非聚集索引查询数据时，拿到叶子上的主键再去查找相应的数据（回表）。

## Hash索引
除了B+树之外，还有一种常见的是哈希索引。

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

本质上就是把键值换算成新的哈希值，根据这个哈希值来定位。

![](./img/索引07.jpeg)

看起来Hash索引挺快的，但其实它有一些局限性

- 无法利用索引完成排序。
- 不支持最左匹配原则
- 在有大量重复键值情况下，哈希索引的效率也是很低的----->哈希碰撞。
- 不支持范围查询。

> **InnoDB支持Hash索引吗？**       
> 主流的还是使用B+树索引比较多，对于哈希索引，InnoDB是自适应哈希索引的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！

> [参考](https://zhuanlan.zhihu.com/p/23624390)



