

- [项目介绍](#项目介绍)
- [设置进程名称](#设置进程名称)
  - [怎么修改进程名称](#怎么修改进程名称)
- [日志打印实现](#日志打印实现)
  - [printf 的实现](#printf-的实现)
  - [日志等级划分](#日志等级划分)
  - [日志输出时遇到了问题](#日志输出时遇到了问题)

-------

## 项目介绍

本科时候发了一篇 《即时通信设计与实现》论文，但是当时完成这篇论文发现项目服务器方面有很多问题没有解决，于是在读研阶段就本着完善的目的做了这个**网络通信服务器项目**，这个项目大部分是参考 Nginx 的思想来实现的。期间也是边学边实现吧，看了很多服务器相关的书和博客。

首先是项目的目录结构模块这些设计，因为考虑到一个完整的项目必须得有一个合适的组织结构吗，当时也没有这方面经验，然后就模仿着 Nginx 的组织结构设计了。

比如在实现日志模块的日志的等级划分，当时实现日志输出的时候有个印象非常深刻的问题，就是没事输出时就总是 等待了好几秒，发现屏幕上迟迟没有日志输出的结果，然后突然之间，在屏幕上出现一大堆输出结果。后来花了不少时间才解决了这个问题。

接着服务器到了设计并发模块，这部分是当时本来想通过阅读 epoll 源码再去是实现，但是水平有限好多看不懂，无意间在 github 看到一位大神 王博靖 自己写的 epoll，毕竟是中国人写的，读起来轻松一些。

后来在当时准备实习面试的时候，学到了 TCP 粘包的知识吧，然后就去找相关资料在项目中加入对这部分的思考。

前段时间在面试 好未来 的时候，面试官问了我很多关于 SYN 攻击的，当时对这方面并没有深入去研究过，后来就自己去查了 linux 少部分的源码，然后通过模拟 TCP 半连接溢出，制造 SYN 攻击，然后对这些攻击问题也尝试了一些解决方法。

就是在做这个项目过程中还是挺有意思的，因为会不停的遇到很多问题又想着可以继续完善，挺有成就感的。


------

## 设置进程名称

> [进程名称 参数被覆盖问题](/Cpp项目/通讯实战项目/note?id=设置进程名称)

进程名称实际上是保存在 `argc[0]` 所指向的内存中。CMD 会把 argv 所指向的命令参数全部显示出来，因为 `./nginx`是保存在 `argv[0]`中，所以 `argv[0]`改变，进程名也就改变了。

> 在这里遇到了个问题，一旦设置的进程名称的长度大于字符串 `./nginx`的长度，就可能导致设置的进程名称覆盖其他参数。

由于环境变量信息也是保存在内存中的，并且**保存的位置紧紧邻 argv 所指向的内存**。所以若果设置的进程名称太长，不但会覆盖掉命令行参数，而且很可能覆盖掉环境变量所指向的内容。

为此，借助了 nginx 的源码，想到了一个解决方案，就是将环境变量搬家，大致思路是：

- **重新分配一块内存**：足够容纳新的 environ 所指向的内容，把 environ 内容搬到这块内存中来。

- 将以往 `argv[0]` 指向的内容替换成实际要修改的新进程名称

### 怎么修改进程名称

大致逻辑：

- 计算进程名称的长度

- 计算命令行参数所占内存与环境变量所占内存的总和

- 设置新的进程名称

------

## 日志打印实现

> [日志打印实现](/Cpp项目/通讯实战项目/note?id=日志打印实现)

打印输出相关函数借鉴了 nginx 的实现，并做一些改动，这部分主要是 学习 printf,vprintf 这类函数的内部实现。

### printf 的实现

C 语言中`printf`函数的**参数是可变**的，是通过**栈**实现参数的传递。`printf`至少有一个参数，就是字符串指针，如果还有其他参数，比如

`printf("a=%d b=%d",i,j); `会**从右往左**依次把参数压入栈内，先压`j`然后压`i`，然后压这个串`"a=%d b=%d"`的首地址也压入栈。在进行解析的时候是后入先出，按照`%d`去寻找后面的参数。这样其实`printf`并不知道一共有几个参数,完全按照`%d`或者其他格式的类型去处理。这就有个问题就是要特别注意变量定义的类型一定要与格式控制符表示的格式一致,不一致会出现读取错误.当然`printf`**在转换参数时，对栈只读不写**，不会造成栈错误。

### 日志等级划分

参考 nginx 的日志等级划分，nginx 日志分成 8 个等级，级别从高到低，数字最小的级别最高，数字最大的级别最低，nginx 中有专门的日志处理模块处理日志(*很复杂，没看*)

```
#define NGX_LOG_STDERR            0    //控制台错误【stderr】：最高级别日志，日志的内容不再写入log参数指定的文件，而是会直接将日志输出到标准错误设备比如控制台屏幕
#define NGX_LOG_EMERG             1    //紧急 【emerg】
#define NGX_LOG_ALERT             2    //警戒 【alert】
#define NGX_LOG_CRIT              3    //严重 【crit】
#define NGX_LOG_ERR               4    //错误 【error】：属于常用级别
#define NGX_LOG_WARN              5    //警告 【warn】：属于常用级别
#define NGX_LOG_NOTICE            6    //注意 【notice】
#define NGX_LOG_INFO              7    //信息 【info】
#define NGX_LOG_DEBUG             8    //调试 【debug】：最低级别
```

### 日志输出时遇到了问题

`printf` 函数不加“`\n`”无法及时输出，就是说，我们在实现`ngx_vslprintf`函数 [打印日志] 测试的时候，等待了好几秒，发现屏幕上迟迟没有日志输出的结果，然后突然之间，在屏幕上出现一大堆输出结果。

后来查了 `printf()`底层实现后发现，这是 **行缓存（输出缓冲区)的问题**，标准输入输出函数都是带有缓存的，一般是行缓存（还发现 window 系统上没有这个问题，但是 Unix 系统就有），就是把需要输出的数据先缓存到某个地方，等待 **行刷新标志** 或者 **缓存已满** 的情况下，才会把缓存的数据显示出来。

“`\n`” 可以认为是刷新标志，也可以通过调用 `fflush(stdout)` 函数刷新缓冲区，将结果显示出来。

- [守护进程以及信号处理](/Cpp项目/通讯实战项目/note?id=守护进程以及信号处理)

- [SYN 攻击](/Cpp项目/通讯实战项目/note?id=syn-攻击)

- [Epoll 技术](/Cpp项目/通讯实战项目/note?id=epoll技术简介)
  - [IO多路复](/寻offer总结/计算机网络/网络编程相关?id=io-多路复用技术)

- [TCP 粘包和缺包](/Cpp项目/通讯实战项目/note?id=tcp-粘包和缺包)

- [多线程 线程池](/Cpp项目/通讯实战项目/note?id=使用多线程解析和处理数据包)

- [回收连接池资源](/Cpp项目/通讯实战项目/note?id=连接池中连接资源的回收)

- [不停触发 socket 可写事件问题](/Cpp项目/通讯实战项目/note?id=腾讯面试题)