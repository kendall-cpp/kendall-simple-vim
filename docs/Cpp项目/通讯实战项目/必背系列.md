

- [项目介绍](#项目介绍)
- [设置进程名称](#设置进程名称)
  - [怎么修改进程名称](#怎么修改进程名称)
- [日志打印实现](#日志打印实现)
  - [printf 的实现](#printf-的实现)
  - [日志等级划分](#日志等级划分)
  - [日志输出时遇到了问题 (行缓存造成日志输出混乱问题)](#日志输出时遇到了问题-行缓存造成日志输出混乱问题)
  - [日志写入混乱问题 和 掉电导致数据丢失问题](#日志写入混乱问题-和-掉电导致数据丢失问题)
  - [怎么解决](#怎么解决)

-------

## 项目介绍

本科时候发了一篇 《即时通信设计与实现》论文，但是当时完成这篇论文发现项目服务器方面有很多问题没有解决，然后我目前的课题是左环境监控这一块的项目嘛，所以需要一个支持tcp长连接的服务器，于是在读研阶段就本着完善的目的做了这个**网络通信服务器项目**，这个项目大部分是参考 Nginx 的思想来实现的。期间也是边学边实现吧，看了很多服务器相关的书和博客。

首先是项目的目录结构模块这些设计，因为考虑到一个完整的项目必须得有一个合适的组织结构嘛，当时也没有这方面经验，然后就模仿着 Nginx 的组织结构设计了。

比如在实现日志模块的日志的等级划分，当时实现日志输出的时候有个印象非常深刻的问题，就是日志输出时就总是 等待了好几秒，发现屏幕上迟迟没有日志输出的结果，然后突然之间，在屏幕上出现一大堆输出结果。后来花了不少时间才解决了这个问题。

接着服务器到了设计并发模块，这部分是当时本来想通过阅读 epoll 源码再去是实现，但是水平有限好多看不懂，无意间在 github 看到一位大神 王博靖 自己写的 epoll，毕竟是中国人写的，读起来轻松一些。

后来在当时准备实习面试的时候，学到了 TCP 粘包的知识吧，然后就去找相关资料在项目中加入对这部分的思考。

前段时间在面试 好未来 的时候，面试官问了我很多关于 SYN 攻击的，当时对这方面并没有深入去研究过，后来就自己去查了 linux 少部分的源码，然后通过模拟 TCP 半连接溢出，制造 SYN 攻击，然后对这些攻击问题也尝试了一些解决方法。

就是在做这个项目过程中还是挺有意思的，因为会不停的遇到很多问题又想着可以继续完善，挺有成就感的。


------

## 设置进程名称

> [进程名称 参数被覆盖问题](/Cpp项目/通讯实战项目/note?id=设置进程名称)

进程名称实际上是保存在 `argc[0]` 所指向的内存中。CMD 会把 argv 所指向的命令参数全部显示出来，因为我们设置的进程名称是 `./nginx` 是保存在 `argv[0]`中，所以 `argv[0]`改变，进程名也就改变了。

> 在这里遇到了个问题，一旦设置的进程名称的长度大于字符串 `./nginx`的长度，就可能导致设置的进程名称覆盖其他参数。

由于环境变量信息也是保存在内存中的，并且**保存的位置紧紧邻 argv 所指向的内存**。所以若果设置的进程名称太长，不但会覆盖掉命令行参数，而且很可能覆盖掉环境变量所指向的内容。

为此，借助了 nginx 的源码，想到了一个解决方案，就是将环境变量搬家，大致思路是：

- **重新分配一块内存**：足够容纳新的 environ 所指向的内容，把 environ 内容搬到这块内存中来。

- 将以往 `argv[0]` 指向的内容替换成实际要修改的新进程名称

### 怎么修改进程名称

大致逻辑：

- 计算进程名称的长度

- 计算命令行参数所占内存与环境变量所占内存的总和

- 设置新的进程名称

------

## 日志打印实现

> [日志打印实现](/Cpp项目/通讯实战项目/note?id=日志打印实现)

打印输出相关函数借鉴了 nginx 的实现，并做一些改动，这部分主要是 学习 printf,vprintf 这类函数的内部实现。

### printf 的实现

C 语言中`printf`函数的**参数是可变**的，是通过**栈**实现参数的传递。`printf`至少有一个参数，就是字符串指针，如果还有其他参数，比如

`printf("a=%d b=%d",i,j); `会**从右往左**依次把参数压入栈内，先压`j`然后压`i`，然后压这个串`"a=%d b=%d"`的首地址也压入栈。在进行解析的时候是后入先出，按照`%d`去寻找后面的参数。这样其实`printf`并不知道一共有几个参数,完全按照`%d`或者其他格式的类型去处理。这就有个问题就是要特别注意变量定义的类型一定要与格式控制符表示的格式一致,不一致会出现读取错误.当然`printf`**在转换参数时，对栈只读不写**，不会造成栈错误。

### 日志等级划分

参考 nginx 的日志等级划分，nginx 日志分成 8 个等级，级别从高到低，数字最小的级别最高，数字最大的级别最低，nginx 中有专门的日志处理模块处理日志(*很复杂，没看*)

```
#define NGX_LOG_STDERR            0    //控制台错误【stderr】：最高级别日志，日志的内容不再写入log参数指定的文件，而是会直接将日志输出到标准错误设备比如控制台屏幕
#define NGX_LOG_EMERG             1    //紧急 【emerg】
#define NGX_LOG_ALERT             2    //警戒 【alert】
#define NGX_LOG_CRIT              3    //严重 【crit】
#define NGX_LOG_ERR               4    //错误 【error】：属于常用级别
#define NGX_LOG_WARN              5    //警告 【warn】：属于常用级别
#define NGX_LOG_NOTICE            6    //注意 【notice】
#define NGX_LOG_INFO              7    //信息 【info】
#define NGX_LOG_DEBUG             8    //调试 【debug】：最低级别
```

### 日志输出时遇到了问题 (行缓存造成日志输出混乱问题)

`printf` 函数不加“`\n`”无法及时输出，就是说，我们在实现`ngx_vslprintf`函数 [打印日志] 测试的时候，等待了好几秒，发现屏幕上迟迟没有日志输出的结果，然后突然之间，在屏幕上出现一大堆输出结果。

后来查了 `printf()`底层实现后发现，这是 **行缓存（输出缓冲区)的问题**，标准输入输出函数都是带有缓存的，一般是行缓存（还发现 window 系统上没有这个问题，但是 Unix 系统就有），就是把需要输出的数据先缓存到某个地方，等待 **行刷新标志** 或者 **缓存已满** 的情况下，才会把缓存的数据显示出来。

“`\n`” 可以认为是刷新标志，也可以通过调用 `fflush(stdout)` 函数刷新缓冲区，将结果显示出来。

### 日志写入混乱问题 和 掉电导致数据丢失问题

本项目是 1 个 master 进程， 4 个 worker 进程，假如 5 个进程跟同时不停地调用，同时向日志文件中写日志，就会造成日志文件混乱问题

首先先在 master 进程和 worker 进程的功能函数中添加一条日志输出，返发现并没有出现混乱现象，所以初步确定 写日志代码在应对多个进程向同一个日志文件中写日志的时候是没有问题的。

当时还专门去研究了 write 函数内部是怎么解决这个问题的？然后参考这个方案在项目中实现。

> **write 内部是如何解决多进程同时写一个文件不出现混乱问题的呢**？

- 在日志初始化函数中调用了 open 函数，open 函数中的 O_APPEND 标志可以保证多个进程操作同一个文件的时候不会相互覆盖，如果不加这个标记，某些情况下就会出现数据彼此覆盖的问题。

- write 函数在写入文件的时候是原子操作，2 个进程同时写入是竞争关系，最终只会由某个进程写入数据。

- 父进程 fork 出子进程，在父进程都会执行的公共代码就已经调用了 open 函数打开了日志文件，然后才通过 fork 创建出子进程，这种父子进程之间会共享文件表项，文件表项里有当前文件偏移量，子进程用 write 原子操作写了一个日志，文件偏移量会移动到文件末尾，父进程的当前文件偏移量也会移动到文件末尾，因为是共享文件表项，所以父进程 write 是接着子进程写的内容末尾开始写，因此不会混乱。

> 所以本项目中利用这种机制解决了写日志时日志混乱的问题

### 怎么解决掉电导致数据丢失问题

> 这里就需要涉及到 write 内部的写数据过程

调用 write 函数之后，把应用程序缓冲区中的内容写到了内核缓冲区，这比从内核缓冲区向磁盘写快很多，所以 write 函数调用返回的速度是很快的。




- [守护进程以及信号处理](/Cpp项目/通讯实战项目/note?id=守护进程以及信号处理)

- [SYN 攻击](/Cpp项目/通讯实战项目/note?id=syn-攻击)

- [Epoll 技术](/Cpp项目/通讯实战项目/note?id=epoll技术简介)
  - [IO多路复](/寻offer总结/计算机网络/网络编程相关?id=io-多路复用技术)

- [TCP 粘包和缺包](/Cpp项目/通讯实战项目/note?id=tcp-粘包和缺包)

- [多线程 线程池](/Cpp项目/通讯实战项目/note?id=使用多线程解析和处理数据包)

- [回收连接池资源](/Cpp项目/通讯实战项目/note?id=连接池中连接资源的回收)

- [不停触发 socket 可写事件问题](/Cpp项目/通讯实战项目/note?id=腾讯面试题)