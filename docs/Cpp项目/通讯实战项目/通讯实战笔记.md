

<!-- TOC -->

- [Nginx的整体结构](#nginx的整体结构)
- [Nginx源码解读](#nginx源码解读)
- [进程与bash代码](#进程与bash代码)
- [信号相关代码](#信号相关代码)
- [fork相关代码](#fork相关代码)



-------

## Nginx的整体结构 

Nginx启动后，一个是 master 进程，一个是 worker 进程，master 进程是一个监控进程，不处理具体的业务，专门用来管理和监控 worker  进程。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/nginx进程.4bsq0g8wmk80.png)

## Nginx源码解读

首先编写自己的 `nginx.c`

```c
#include <stdio.h>
#include <unistd.h>

int main() {

	printf("this is 通讯架构实战C++\n");
	for(;;){
		printf("休息一秒\n");
		sleep(1);
	}

	printf("程序退出了，再见\n");
	return 0;
}
```

## 进程与bash代码

在一个终端运行自己写的`nginx.c`,然后在另一个终端执行下面命令

```bash
kendall@ubuntu:~$ ps -eo pid,ppid,sid,tty,pgrp,comm | grep -E 'bash|PID|nginx'
   PID   PPID    SID TT         PGRP COMMAND
  1221   1218   1221 pts/0      1221 bash
  1515      1   1515 ?          1515 nginx
  1550   1515   1515 ?          1515 nginx
  1552   1515   1515 ?          1515 nginx
  1553   1515   1515 ?          1515 nginx
  1575   1515   1515 ?          1515 nginx
  1618   1617   1618 ?          1618 bash
  1620   1618   1618 ?          1618 bash
  1845   1764   1845 pts/3      1845 bash
  2225   2223   2225 pts/4      2225 bash
  2246   1845   1845 pts/3      2246 nginx
```

使用 strace 调试分析工具，可用于跟踪程序执行时进程的系统调用（`system call`)
```bash
 sudo strace -e trace=signal -p 2246
 ```

 如果运行nginx 的终端退出了，就会输出：

 ```
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=1845, si_uid=1000} ---
+++ killed by SIGHUP +++
 ```


```c
#include <stdio.h>
#include <unistd.h>
 #include <signal.h>

int main() {

	printf("this is 通讯架构实战C++\n");

	//忽略信号
	signal(SIGHUP,SIG_IGN);
	//SIG_IGN 代表我要求忽略该信号，请求操作系统不要执行默认的该信号处理动作（就是不要把进程杀死）
	
	setsid();  //该函数用于建立一个新会话  //但是组长调用setsid()是无效的

	for(;;){
		printf("休息一秒\n");
		sleep(1);
	}

	printf("程序退出了，再见\n");
	return 0;
}
```

```c
#include <stdio.h>
#include <unistd.h>
 #include <signal.h>

int main() {


	pid_t pid;

	printf("this is 通讯架构实战C++\n");


	pid = fork();
	if(pid < 0) {
		printf("fork进程出错\n");
	}
	else if(pid == 0) {
		printf("这是子进程在运行\n");

		//在子进程里面创建新的 zsession 会话
		setsid();
		for(;;) {
			sleep(1);
			printf("子进程休息 1 秒\n");
		}
		return 0;
	}
	else {
		printf("这是父进程子啊运行\n");
		for(;;){
			sleep(1);
			printf("父进程休息 1 秒\n");
		}
		printf("父进程结束，再见！\n");
	}

	//忽略信号
	// signal(SIGHUP,SIG_IGN);
	//SIG_IGN 代表我要求忽略该信号，请求操作系统不要执行默认的该信号处理动作（就是不要把进程杀死）

	
;
	return 0;
}
```

## 信号相关代码

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int g_mysign  = 0;
//改变全局变量
void muNEfunc(int value) {

	//改变全局变量
	g_mysign = value;
}

//信号处理函数
void sig_usr(int signo) {

	muNEfunc(20);

	if(signo == SIGUSR1) {
		printf("收到了 SIGUSR1 信号\n");
	}
	else if(signo == SIGUSR2) {
		printf("收到了 SIGUSR2 信号\n");
	}
	else {
		printf("收到了未捕捉的信号 %d !\n",signo);
	}
}


int main() {

	//针对该信号的捕捉处理函数
	if( signal(SIGUSR1,sig_usr) == SIG_ERR ) 
	{
		printf("无法捕捉 SIGUSR1 信号\n");
	}
	if( signal(SIGUSR2,sig_usr) == SIG_ERR ) {
		printf("无法捕捉 SIGUSR2 信号\n");
	}
	for(;;)
	{
		sleep(1);
		printf("休息1秒\n");

		muNEfunc(15);
		printf("g_mysign = %d\n",g_mysign);
	}

	return 0;
}
```


- nginx_3_2.c

```c
#include <stdio.h>
#include <stdlib.h>  //malloc
#include <unistd.h>
#include <signal.h>

//信号处理函数
void sig_quit(int signo)
{   
    printf("收到了SIGQUIT信号!\n");
    if(signal(SIGQUIT,SIG_DFL) == SIG_ERR)
    {
        printf("无法为SIGQUIT信号设置缺省处理(终止进程)!\n");
        exit(1);
    }
}

int main(int argc, char *const *argv)
{
    sigset_t newmask,oldmask; //信号集，新的信号集，原有的信号集，挂起的信号集
    if(signal(SIGQUIT,sig_quit) == SIG_ERR)  //注册信号对应的信号处理函数,"ctrl+\" 
    {        
        printf("无法捕捉SIGQUIT信号!\n");
        exit(1);   //退出程序，参数是错误代码，0表示正常退出，非0表示错误，但具体什么错误，没有特别规定，这个错误代码一般也用不到，先不管他；
    }

    sigemptyset(&newmask); //newmask信号集中所有信号都清0（表示这些信号都没有来）；
    sigaddset(&newmask,SIGQUIT); //设置newmask信号集中的SIGQUIT信号位为1，说白了，再来SIGQUIT信号时，进程就收不到，设置为1就是该信号被阻塞掉呗

    //sigprocmask()：设置该进程所对应的信号集
    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask) < 0)  //第一个参数用了SIG_BLOCK表明设置 进程 新的信号屏蔽字 为 “当前信号屏蔽字 和 第二个参数指向的信号集的并集
    {                                                 //一个 ”进程“ 的当前信号屏蔽字，刚开始全部都是0的；所以相当于把当前 "进程"的信号屏蔽字设置成 newmask（屏蔽了SIGQUIT)；
                                                      //第三个参数不为空，则进程老的(调用本sigprocmask()之前的)信号集会保存到第三个参数里，用于后续，这样后续可以恢复老的信号集给线程
        printf("sigprocmask(SIG_BLOCK)失败!\n");
        exit(1);
    }
    printf("我要开始休息10秒了--------begin--，此时我无法接收SIGQUIT信号!\n");
    sleep(10);   //这个期间无法收到SIGQUIT信号的；
    printf("我已经休息了10秒了--------end----!\n");
    if(sigismember(&newmask,SIGQUIT))  //测试一个指定的信号位是否被置位(为1)，测试的是newmask
    {
        printf("SIGQUIT信号被屏蔽了!\n");
    }
    else
    {
        printf("SIGQUIT信号没有被屏蔽!!!!!!\n");
    }
    if(sigismember(&newmask,SIGHUP))  //测试另外一个指定的信号位是否被置位,测试的是newmask
    {
        printf("SIGHUP信号被屏蔽了!\n");
    }
    else
    {
        printf("SIGHUP信号没有被屏蔽!!!!!!\n");
    }

    //现在我要取消对SIGQUIT信号的屏蔽(阻塞)--把信号集还原回去
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL) < 0) //第一个参数用了SIGSETMASK表明设置 进程  新的信号屏蔽字为 第二个参数 指向的信号集，第三个参数没用
    {
        printf("sigprocmask(SIG_SETMASK)失败!\n");
        exit(1);
    }

    printf("sigprocmask(SIG_SETMASK)成功!\n");
    
    if(sigismember(&oldmask,SIGQUIT))  //测试一个指定的信号位是否被置位,这里测试的当然是oldmask
    {
        printf("SIGQUIT信号被屏蔽了!\n");
    }
    else
    {
        printf("SIGQUIT信号没有被屏蔽，您可以发送SIGQUIT信号了，我要sleep(10)秒钟!!!!!!\n");
        int mysl = sleep(10);
        if(mysl > 0)
        {
            printf("sleep还没睡够，剩余%d秒\n",mysl);
        }
    }
    printf("再见了!\n");
    return 0;
}
```

## fork相关代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void sig_usr(int signo)
{
	printf("收到了 SIGUSR1 信号, 进程 ID = %d \n",getpid());
}

int main() {

	pid_t pid;

	printf("进程开始执行\n");

	if(signal( SIGUSR1,sig_usr ) == SIG_ERR) {
		printf("无法捕捉 SIGUSR1 信号\n");
		exit(1);
	}

	//创建子进程
	pid = fork();
	if(pid < 0) {
		printf("创建子进程失败\n");
		exit(1);
	}
	// 现在子进程和父进程同步运行
	for(int i=0; i< 10000; ++i)
	{
		sleep(1);
		printf("休息了1s，进程 ID = %d\n",getpid());
	}
	printf("再见了 \n");
	return 0;
}
```

