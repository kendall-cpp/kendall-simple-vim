## 设计处理流程

用文件系统做数据库，可以用Hadoop

也叫数据的持久化



1.得到爬取种子（URL）

2.根据种子下载资源

3.提取页面，提取跟多的url

4.对页面做持久化操作

5.根据提取的url再进行下载操作

6.重复第二步到第五步

## 系统设计

![](./img/系统结果图.png)

## 控制器

输入配置文件，输出控制指令，控制其他模块的指令

控制模块由三部分组成

- 配置文件处理模块，从配置文件中读取配置项，提供配置项的提取接口，
- URL维护模块，负责维护URL库，提供如下功能：
  - 输入新的url
  - 输出一个未被抓取的url
  - 负责维护url的抓取状态
- 任务调度模块，多任务执行
  - 负责协调控制器的流程
  - 负责调用其他系统模块完成工作
- url列表
![](./img/系统结果图01.png)

## 下载器设计

输入待抓取得url，输出抓取得页面

![](./img/系统结果图02.png)

## 解析器

把页面的url解析出来，

只有一个HTML解析模块
![](./img/系统结果图04.png)

### 持久化器

把数据持久化保存的文件系统上

页面保存模块

图片保存模块

视频流模块

音乐流模块

![](./img/系统结果图03.png)


## 控制器

- 配置文件解析模块

## 概要设计

### 配置文件解析模块

配置文件是以文件形式保存程序运行时必要的参数，减少输入时的繁琐过程，文件类型是文本文件，内容一般以键值对形式出现。

配置文件规则

`key=value`

配置项设置

![](./img/系统结果图05.png)

#### 模块详细设计

操作：

1.操作配置文件

2.得到配置文件选项的值（键值）

3.初始化

![](./img/系统结果图06.png)



配置文件类

- confparser.h

为了让每个模块都能访问，设置成单例


> 接下来是实现...


技术点：

1.按行读取fgets

2.分割字符串

3.消除注释,遇到”#“就去掉

4.消除空格

### URL 维护模块

> 实际上内存的的小数据库，维护一个队列

url格式：http://www.baidu.com/code/index.html

结构：域名IP地址，路径，文件名


![](./img/系统结果图07.png)

![](./img/http请求过程.png)

处理流程回顾：（结合上面的图）

一开始有一个url种子，然后控制器读取出来，

读取之后到控制器模块内部，

从配置文件里得到种子，先给URL维护模块，放到URL列表中去，第二步再把URL传给下载模块，当下载模块把这个页面抓取之后，会给控制器模块一个状态，这个状态会会写到URL列表中对应的数据。然后记录当前资源是否下载成功，可以和修改状态合并为当前URL处理状态state：0代表为抓取，1代表抓取成功，-1代表抓取失败

![](./img/系统结果图08.png)

> 对URL维护模块细化

![](./img/URL模块细节.png)

下面是数据结构内部设计

**对这个数据结构进行优化**

需要一个URL库保存所有的URL，不管是否被抓取，

设计一个URL队列，保存指向URL列表中具体URL的指针，当一个新的URL来的时候，先放到URL库中，然后用一个指针执行这个位置并把指针保存到URL处理队列，当我们想要抓取URL的时候从URL处理队列的队首拿出一个来，然后我们对这个指针进行操作即可，处理完之后就让其出队。

![](./img/URL模块数据结构优化.png)

接下来设计URL维护模块算法

![](./img/URL维护模块设计.png)

第一个类

![](./img/URL维护模块设计01.png)

第二个类，URL管理器

![](./img/URL维护模块设计02.png)

通过URL去查找url库里面是不是存在了，这时候我们需要设置一个url 哈希值转换，为了提高查找的效率，添加一个map

![](./img/URL维护模块设计03.png)

![](./img/URL维护模块设计04.png)

### 任务调度模块

> 程序的入口

在任务调度模块里面需要一个日志工具

![](./img/日志工具01.png)

![](./img/日志工具02.png)


任务调度模块，程序主流程

![](./img/任务调度模块01.png)

![](./img/任务调度模块02.png)

继续分解复杂步骤

对页面进行处理。

![](./img/任务调度模块03.png)

启动处理任务

![](./img/任务调度模块04.png)

其他辅助功能，

1.输出帮助信息，

### epoll

#### 多路复用框架

- 为什么使用epoll而不是用select

![](./img/epoll01.png)

![](./img/epoll02.png)

![](./img/epoll03.png)

![](./img/epoll04.png)

![](./img/epoll05.png)

![](./img/epoll06.png)

![](./img/epoll07.png)

![](./img/epoll08.png)

例如：



\1. 我们已经把一个用来从管道中读取数据的文件句柄添加到`epoll`描述符

\2. 这个时候从管道的另一端被写入了`2KB`的数据

\3. 调用`epoll_wait(2)`，并且它会返回文件句柄，说明它已经准备好读取操作。

\-4 然后我们读取了`1KB`的数据

\-5 调用`epoll_wait(2)`



![](./img/epoll15.png)

默认模式

![](./img/epoll09.png)

高速模式

![](./img/epoll10.png)

![](./img/epoll12.png)

![](./img/epoll11.png)

![](./img/epoll13.png)

select的问题：
* 文件句柄数量受限制，最大才2028个

### 在这个系统中使用 epoll

关于页面的下载，是直接在socket上封装的，在抓取任务的时候，先调用build_connect连接server，之后返回的句柄会注册到epoll中去，

对页面的解析过程一样占用CPU资源，所以也需要epoll参与，

![](./img/epoll14.png)


## 插件框架设计

## 下载器设计

分成两部分

- socket功能框架

- http协议处理模块


功能：想远端服务器发起请求，把页面抓取下来

HTTP主要操作：操作get指令



页面解析处理流程
1. 得到下载的页面
2. 得到页面对应的url结构体(用于当前页面的深度，是否已经达到最大深度)
3. 使用正则表达式提取页面中所有的url列表
4. 处理url中的相对路径
5. 一个细节：把当前页面深度加一，生成并填充url结构体，
6. 把得到的url列表会写到管理器中，（生成列表数据，以返回值形式上层代码）


## 持久化器
![](./img/持久器设计01.png)

处理流程

- 得到页面的数据流或在内存缓冲区中的数据
- 得到当前页面的URL描述结构体
- 生辰保存目录（目录已存在和未存在的处理情况）
- 把文件按照指定模式写入磁盘系统
- 向主处理流程发送一个反馈，表示当前页面处理进度

![](./img/核心代码.png)

后续工作：单元测试用cunit工具

把软件做成系统服务，需要shell脚本

继承测试

## 项目实施


## 项目简历

![](./img/项目简历01.png)

![](./img/项目简历02.png)


url 是怎么管理的


关于主控模块

工作流程，epoll，多线程是怎么实现的，kselect这个库，有没有用到线程同步的技术，怎么得到url（dns解析）

现阶段不要求

![](./img/类关系01.png)


下载模块，socket，socket工作细节，tcp，udp，用哪种方式实现的，用tcp，

HTTP，对HTTP头进行分析，用字符串解析出来，按行读取，找头的属性值，找到http头的每个属性，然后从后边把这个值提取出来，用到了哪个值，用到了文件的类型（Accept：text/html)，状态码，判断页面是否下载成功。其他的说忘了。


#### 关于页面解析

就是一行正则表达式做匹配，（网上查的）

#### 持久化模块

按照网站目录结构在本地存储，

看你会问这个地方会引发出的问题，文件是怎么存储的，（标准库还是系统调用）

标准库是有缓冲的，（可以说用的是Hadoop，但是要会说）

什么是守护进程，设置守护继承的步骤。分别用什么函数，第一步创建子进程，然后脱离父子关系，然后杀死父进程，然后变成孤儿进程之后会怎样，再归为一号进程，用了哪些函数，

Linux动态库做什么，实现了一种简单的插件模式，因为我想以后想支持更多的文件，每一种文件格式都有一种处理方式，为了更快扩展，用了这个插件，程序里面自动做了自动匹配，遇到哪种文件，我就自动去调用哪个模块。

那么实现机制是什么？

![](.img/../img/插件模式01.png)

一个功能一个模块，方便扩展，

怎么去实现的呢？

用一个结构体来描述，而且结构体有函数指针

那这些模块怎么去管理

有一个模块管理器，维护这些模块的结构体。主要指导这个模块的编号就能找到这个模块。

项目中用到的开源库：

libevent，

----- 
## 实习介绍

在`2019`年的时候在广州一家公司实习了半年，公司的主营业务店铺选址信息服务。以线上的方式帮助雇主更好的将自己的店铺出租出去，同时也为商家提供个性化的选址服务。我在实习期间主要负责一个爬虫系统的设计与开发。

大致流程就是：
- 从互联网中得到爬取种子，也就是`URL`
- 根据种子下载资源
- 提取页面，从页面提取更多的`url`
- 并对页面做持久化操作
- 根据提取的`url`再进行下载操作

在整个实习期间参与了这个爬虫项目整个流程的开发，从中学到了许多`Linux`系统开发技能。比如`Linux`多路复用技术，`socket`编程，多线程，守护进程和`Linux`动态库等。

并且在项目导师的指导下按时完成了实习任务。

## 项目介绍

这个项目由我和部门另一位同事也就是实习导师共同完成，本项目分成四个模块，分别是**主控模块**，**下载器模块**，**解析器模块（URL提取模块）**和**持久化模块**。


通过下载器下载页面，下载页面之后交给解析器，解析器从这个页面中把这些`URL`全都提取出来，然后通过持久化模块保存到文件系统。控制器是对这些模块进行管理控制。

### 控制器

整个系统的核心部分就是控制器模块

控制器就是输入配置文件，输出控制指令，也就是控制其他模块的指令。控制器分成三部分组成

- **配置文件处理模块**
- **`URL` 维护模块**
- **任务调度模块**


### 下载器

下载器主要是输入抓取的`url`,输出取得的页面。

分为`HTTP`协议处理模块和`socket`功能框架两部分

### 解析器（URL提取模块）

解析器就是负责把页面的 `url` 解析出来，这部分只有一个`HTML`解析模块

### 持久化器

就是把数据持久化保存到文件系统上



## 主控模块的工作流程

其中控制器就是输入配置文件，输出控制指令，也就是控制其他模块的指令。控制器分成三部分组成
- **配置文件处理模块**，从配置文件中读取配置项，提供配置项的提取接口
- **`URL` 维护模块**，负责维护`URL`库，提供如下功能：
  - 输入新的`url`
  - 输出一个未被抓取的`url`
  - 负责维护`url`的抓取转态
- **任务调度模块**，
  - 负责协调控制器的流程
  - 负责调用其他系统模块完成工作


![](./img/projectDoc/控制器01.png)

**技术代码流程**：

1. 按行读取`fgets`

2. 分割字符串

3. 消除注释,遇到”#“就去掉

4. 消除空格

### `URL` 维护模块具体实现流程

实际上是内存的小数据库，维护一个队列

**处理流程**：

一开始有一个`url`种子，然后控制器读取出来，

读取之后到控制器模块内部，

从配置文件里得到种子，先给`URL`维护模块，放到`URL`列表中去，第二步再把`URL`传给下载模块，当下载模块把这个页面抓取之后，会返回给控制器模块一个状态，这个状态会写到`URL`列表中对应的数据。然后记录当前资源是否下载成功，可以和修改状态合并为当前`URL`。

处理状态`state`：`0`代表为抓取，`1`代表抓取成功，`-1`代表抓取失败。

> 然后我们还对`URL`处理队列这个数据结构做了优化设计,因为需要一个`URL`库保存所有的`URL`，不管是否被抓取，

### `URL`处理队列数据结构内部设计

设计一个`URL`队列，保存指向`URL`列表中具体`URL`的指针，当一个新的`URL`来的时候，先放到`URL`库中，然后用一个指针指向这个位置并把指针保存到`URL`处理队列，当我们想要抓取`URL`的时候从`URL`处理队列的队首拿出一个来，然后我们对这个指针进行操作即可，处理完之后就让其出队。

![](./img/projectDoc/URL处理模块01.png)

为了确定当前`URL`在`url`库里面是不是存在了，这时候我们还需要设置一个`url`哈希值转换，为了提高查找的效率，所以在`URL`处理的数据结构中添加了一个`map`

![](./img/projectDoc/URL处理模块02.png)


### 说一下任务调度模块

> 任务调度模块也就是程序的入口    
> 提供一个运行框架，支持多任务管理执行    
> 可以控制程序是按照普通模式运行还是按照守护进程模式运行

这个主程序框架的流程是：
- 程序运行时先处理命令行参数，根据参数跳转到相应的分支或者调用对应的函数
- 检测是否按照守护进程模式运行（控制项从命令行参数中得到）
- 初始化环境，
  - 读取配置文件，提取配置文件中的参数
  - 根据守护进程的标记将当前进程转变为守护进程
  - 然后载入程序模块的动态库
- 开始程序的主处理流程
  - a.检测种子是否存在，把种子交给`URL`管理器
  - b.分析种子，通过`DNS`解析得到种子`url`的`IP`地址
  - c.根据种子`URL`种子得到第一个页面
  - d.对页面进行处理
  - e.从`URL`管理器中提取一个`url`
  - f.启动一个处理服务（这里需要先检测是否达到最大任务数量，这个功能封装到一个独立的函数中）
  - g.监控任务处理数量，如果任务维护池中有空闲任务，那么重复 `e` 操作
  - 最后回收资源，准备结束程序或者当前任务

### 怎么提取`URL`的

> 见上面，分析`URL`种子,通过`DNS`解析得到种子`url`的`IP`地址，然后可以得到一个页面。



## 项目中怎么使用`epoll`和多线程



比如，我们解析页面的过程：
- 连接远程服务器
- 从远程服务器中得到数据
- 处理得到的数据，比如说数据包
- 然后对数据进行业务处理
- 向远程服务器发送反馈
- 最后关闭套接字

使用`Epoll`只能关于与`IO`相关的操作，每一个操作都必须注册给`Epoll`。

这里的第三步和第四步：处理得到的数据 和 对数据进行业务处理，不是与`IO`相关的。所以需要多线程来管理（使用`thread`这个库）

> [使用C++ 标准库 thread类 实现多线程并行处理
](https://blog.csdn.net/weixin_44010117/article/details/107522672)

### 介绍`Epoll`

#### 为什么使用`epoll`而不是`select`

相比于`select`，`epoll`最大的好处就是它不会随着监听的`fd`数目的增长而降低效率。因为在内核的`select`实现中，它是采用轮询来处理的，轮询的`fd`数目越多，自然耗时就越大，并且，在`linux/posix_types.h`头文件中声明了
```
#define __FD_SETSIZE  1024
```
表示`select`最多同时监听`1024`个`fd`，当然，可以通过修改头文件再重新编译内核来扩大这个数目，但是这样似乎并不能彻底解决问题。




## 下载模块

分成两部分

- `socket`功能框架

- `http`协议处理模块

功能：想远端服务器发起请求，把页面抓取下来

### 怎么处理`http`

对`HTTP`头进行分析，用字符串解析出来，按行读取，找头的属性值，找到`http`头的每个属性，然后从后边把这个值提取出来，用到了哪个值，用到了文件的类型（`Accept：text/html`)，状态码，判断页面是否下载成功。其他的说忘了。

### 关于页面解析

就是一行正则表达式做匹配，（网上查的）

## 持久化模块

处理流程

- 得到页面的数据流或在内存缓冲区中的数据
- 得到当前页面的`URL`描述结构体
- 生成保存目录（也就是目录已存在和未存在的处理情况）
- 把文件按照指定写入磁盘系统
- 向主处理流程发送一个反馈，表示当前页面处理进度

## `linux`动态库做什么

实现了一种简单的插件模式，因为我想以后想支持更多的文件，每一种文件格式都有一种处理方式，为了更快扩展，用了这个插件，程序里面自动做了自动匹配，遇到哪种文件，我就自动去调用哪个模块。

一个功能一个模块，方便扩展，

#### 怎么去实现的呢？

用一个结构体来描述，而且结构体有函数指针

#### 那这些模块怎么去管理

有一个模块管理器，维护这些模块的结构体。主要指导这个模块的编号就能找到这个模块。

----

