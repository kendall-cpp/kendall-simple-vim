## 1.C++的内存管理
### 内存四区
在操作系统中，不同应用程序之间的内存时相互独立的，一般不能互相进行访问。

一个引用程序的内存一般分成四个区：
- 栈区：栈区存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
- 堆区：堆区是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
- 数据区：数据区主要存放的是全局变量、常量和静态变量。数据区又可以分为全局区和静态区(常量区)
- 代码区：代码区存储的就是可执行的代码，这个区域的属性是只读的。

![](./img/C++内存管理.png)

编写一段代码来了解内存四区的底层结构

```cpp
#include<stdio.h>
int main()
{
 int a = 0;
 int b = 0;
 char c='0';
 printf("变量int a的地址是：%d\n变量int b的地址是：%d\n变量char c的地址是：%d\n", &a, &b, &c);
}
```
运行结果
```
变量int a的地址是：-332826852
变量int b的地址是：-332826856
变量char c的地址是：-332826857
```

可以发现`a b c` 的地址是连续的，由于`int`是4个字节，所以`a`和`b`之间间隔为4，`char`是一个字节，所以`b`与`c`间隔为1。此外，它们的地址是从`a`到`c`减少的，这是因为栈的存储结构是**先进后出**。

![](./img/C++内存管理01.png)

然后我们加上静态变量`d`和全局变量`e`。

```cpp
#include<stdio.h>
int e = 0;
int main()
{
    int a = 0;
    int b = 0;
    char c='0';
    static int d = 0;
    printf("变量int a的地址是：%d\n变量int b的地址是：%d\n变量char c的地址是：%d\n", &a, &b, &c);
    printf("静态变量static int d的地址是：%d\n" ,&d);
    printf("全局变量int e的地址是：%d\n", &e);
    return 0;
}
```
运行结果：

```
变量int a的地址是：-481331432
变量int b的地址是：-481331436
变量char c的地址是：-481331437
静态变量static int d的地址是：208703516
全局变量int e的地址是：208703512
```
变量 `d` 为静态变量，运行代码后从结果上得知，静态变量 `d`的地址与一般变量 `a`、`b`、`c` 的地址并不存在连续，他们两个的内存地址是分开的。那接下来在此建一个全局变量，通过上述内容得知，全局变量与静态变量都应该存储在静态区.

而且可知**栈区、数据区都是使用栈结构对数据进行存储**。

堆并没有和栈一样的结构，也没有栈一样的先进后出，需要人为的对的内存进行分配使用。
```cpp
#include<stdio.h>
#include<string.h>
#include <malloc.h>
int main()
{
 char *p1 = (char *)malloc(1024*1000000);
 strcpy(p1, "这里是堆区");
 printf("%s\n", p1);
}
```
上面的代码使用了`malloc`开辟了一块大小为`1024*1000000`的空间，这个大小如果在栈区就会出现栈溢出的现象，而堆没有，因为堆本身就是大容量。

然后注意`p1`存储的是开辟的内存空间的地址。

### `malloc` 和 `free`

在`C`语言中,分别使用`malloc` 和 `free`进行分配和释放内存。

`malloc`函数的原型为

```cpp
void *malloc(size_t size);//size 是表示需要申请的内存空间大小
```

这里注意的是返回值时`void *`,表示类型不确定。

`free`函数的原型为：

```cpp
void free(void *ptr);
```
这个函数没有返回值。

### 内存泄露

内存泄露是指在动态分配内存的过程中，忘记释放掉分配的内存或者因为某些原因导致内存无法释放。如果严重的话会导致系统崩溃发生。

比如在一个函数中使用`malloc`函数开辟了100个单位的内存空间，并没有释放，如果这个函数频繁地被调用，久而久之就会出现严重的后果，所以在使用完之后应该加上`free`进行释放。

如果使用`fopen`打开一个文件，使用完之后没有使用`fclose`进行关闭也会导致内存泄漏。

还有没有被初始化的指针也会造成内存泄漏，因为指针未初始化的话它的执行是不可控的。包括错误的释放。比如
```cpp
int *p;  //指针未初始化

int pp = p;
free(pp); //错误释放，这里导致指针p出现指针悬挂现象
```

### `new` 和 `delete`

在C++中分别使用`new` 和 `delete`来分配和释放内存。这里需要注意，`new` 和 `delete`**是运算符，不是函数**。

`new/delete`相对于`malloc/free`除了分配和释放内存之外还做了其他很多事情。

`new` 相对于 `malloc` 会额外的做一些初始化工作，`delete` 相对于 `free` 多做一些清理工作。

```cpp
class A
{
 public:
     A()
     {
        cont<<"A()构造函数被调用"<<endl;
     }
     ~A()
     {
        cont<<"~A()构造函数被调用"<<endl;
     }
}

//在 main 主函数中，加入如下代码

A* pa = new A();  //类 A 的构造函数被调用
delete pa;        //类 A 的析构函数被调用
```

比如说使用`new`生成一个对象时，系统会调用这个类的构造函数，使用`delete`删除一个对象时，系统会调用这个类的析构函数。

### `delete` 与 `delete[]` 的区别

简单的说就是
* `delete`只会调用一次析构函数，而`delete[]`会调用每个成员的析构函数

* 用`new`分配的内存用`delete`释放，用`new[]`分配的内存用`delete[]`释放

假如说使用`new int[10]`来开辟一个内存空间，针对这种简单类型，使用`new`分配后不管是数组还是非数组形式释放都是可以的。他们的效果是一样的，**因为分配简单类型内存的时候，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统不会调用析构函数**。它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间。

```cpp
int *a = new int[10];
delete a;        //方式1
delete[] a;     //方式2

int *a = new int[10];
delete a;
delete[] a;
```

但是如果针对类`class`，两种方式就出现差异了。

```cpp
class A
{
private:
    char *m_cBuffer;
    int m_nLen;

public:
    A(){ m_cBuffer = new char[m_nLen]; }
    ~A() { delete [] m_cBuffer; }
};

A *a = new A[10];
delete a;         
//仅释放了a指针指向的(首地址)全部内存空间 
//但是只调用了a[0]对象的析构函数 
//剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏
delete[] a;      
//调用使用类对象的析构函数释放用户自己分配内存空间并且释放了a指针指向的全部内存空间
```

所以在用这些类生成对象数组的时候，建议用 `delete[]` 来释放。



