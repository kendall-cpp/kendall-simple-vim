> 这部分为引导式面试方式整理      
> 建议通过浏览器上面的`<-  ->`两个按钮控制各个关联的跳转

- [`C`和`C++`的区别](#c和c的区别)
- [介绍面向对象的三大特性，并且举例说明每一个](#介绍面向对象的三大特性并且举例说明每一个)
  - [多态的实现](#多态的实现)
  - [C++虚函数相关，虚函数的实现原理](#c虚函数相关虚函数的实现原理)
  - [虚函数表是如何实现动态绑定的](#虚函数表是如何实现动态绑定的)
  - [实现编译器处理虚函数表应该如何处理](#实现编译器处理虚函数表应该如何处理)
  - [基类的析构函数为什么一般写成虚函数](#基类的析构函数为什么一般写成虚函数)
  - [构造函数为什么一般不定义为虚函数](#构造函数为什么一般不定义为虚函数)
    - [构造函数或者析构函数中调用虚函数会怎样](#构造函数或者析构函数中调用虚函数会怎样)
  - [静态绑定和动态绑定的介绍](#静态绑定和动态绑定的介绍)
  - [纯虚函数](#纯虚函数)
  - [虚函数和纯虚函数区别](#虚函数和纯虚函数区别)
  - [析构函数的作用，如何起作用](#析构函数的作用如何起作用)
  - [构造函数、析构函数的执行顺序](#构造函数析构函数的执行顺序)
  - [类什么时候会析构？](#类什么时候会析构)
  - [哪些函数不能是虚函数？把你知道的都说一说](#哪些函数不能是虚函数把你知道的都说一说)
  - [静态函数能定义为虚函数吗，说说你的理解](#静态函数能定义为虚函数吗说说你的理解)
- [有没有了解过(复制)拷贝构造函数](#有没有了解过复制拷贝构造函数)
- [说一下深拷贝和浅拷贝](#说一下深拷贝和浅拷贝)
- [C ++内存管理(内存分区)](#c-内存管理内存分区)
  - [内存泄漏的定义，什么时候会造成内存泄漏](#内存泄漏的定义什么时候会造成内存泄漏)
  - [内存泄漏避免方法](#内存泄漏避免方法)
  - [`new/delete` 与 `malloc/free` 的异同](#newdelete-与-mallocfree-的异同)
  - [new和delete是如何实现的](#new和delete是如何实现的)
  - [`delete`和`delete[]`的区别](#delete和delete的区别)
  - [malloc申请的存储空间能用delete释放吗](#malloc申请的存储空间能用delete释放吗)
- [结构体的内存对齐](#结构体的内存对齐)
- [说一下`C++`里的智能指针](#说一下c里的智能指针)
  - [智能指针出现循环引用怎么解决？](#智能指针出现循环引用怎么解决)
  - [使用智能指针管理内存资源，RAII是怎么回事](#使用智能指针管理内存资源raii是怎么回事)
- [C++中struct和class的区别](#c中struct和class的区别)
  - [C++和C的struct区别](#c和c的struct区别)
- [指针和引用的区别](#指针和引用的区别)
- [内连接与外连接](#内连接与外连接)
- [main函数执行之前和执行之后有什么区别](#main函数执行之前和执行之后有什么区别)
- [一个函数或者可执行文件的生成过程或者编译过程是怎样的](#一个函数或者可执行文件的生成过程或者编译过程是怎样的)
- [在C++中const的用法（定义，用途）](#在c中const的用法定义用途)
  - [define和const的联系与区别](#define和const的联系与区别)
  - [define与inline的区别](#define与inline的区别)
  - [`typdef`和`define`区别](#typdef和define区别)

## `C`和`C++`的区别

包括但不限于：

* `C`是面向过程的语言，`C++`是面向对象的语言，所以`C++`也就具有面向对象的三大特性。分别是“**封装，继承和多态**”  ==> [介绍面向对象的三大特性，并且举例说明每一个](#介绍面向对象的三大特性并且举例说明每一个)

* `C`和`C++`内存管理的方法不同。`C`使用`malloc/free`，`C++`除此之外还用`new/delete`。==> [malloc/free和new/delete的区别](#newdelete-与-mallocfree-的异同)

* `C`中的结构体`struct`和`C++`的类的也是有区别的。==> [C++中struct和class的区别](#c和c的struct区别)

* `C++`支持函数重载，`C`不支持函数重载。而且`C++`中允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而`C`语言中，必须要在函数开头部分。而且`C++`允许重复定义变量，`C`语言也是做不到这一点的。


* `C++`中有引用和指针，而`C`有指针，但是没有引用。==> [引用和指针是有区别的](#指针和引用的区别)

* 内外链接区别，`C++`全部变量的默认链接属性是外链接，而`C`是内连接。[内连接和外链接区别](#内连接与外连接)

* `C`语言和`C++`的一些关键字也不同。如`const`，`C`语言中的`const`：被修饰后不能做左值，一开始初始化后只有就不能再修改了。定义的时候必须初始化，可以用作数组的下标。`const`在`C++`中的编译规则是替换（和宏`#define`很像）；==> [可能会被问define和const的联系与区别](#define和const的联系与区别)

* 还有其他的不同，比如输入输入输出，`C`语言没有`string`字符串类型等等吧。

## 介绍面向对象的三大特性，并且举例说明每一个

面向对象的三大特性是：封装，继承和多态。

* **封装**：隐藏了类的实现细节和成员数据，实现了代码模块化，并且类可以把自己的数据和方法只让可信的类或者对象操作，例如：将公共的数据或方法使用`public`修饰，而不希望被访问的数据或方法采用`private`修饰。 `[ˈpraɪvət]`

* **继承**：让子类可以继承父类的成员和方法，实现了代码重用；
  * 常见的继承有三种方式：

  1. 实现继承：指使用基类的属性和方法，子类不需要额外实现
  2. 接口继承：指仅仅使用属性和方法的名称、但是子类必须提供实现的能力
  3. 可视继承：（C++里好像不怎么用，没深入去研究）


* **多态**：是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用。如父类的指针指向子类的对象。**多态的实现机制是虚函数+**==>[多态的实现](#多态的实现) ==>[C++虚函数相关](#Cpp知识点02?id=c虚函数相关，虚函数的实现原理（重要）)

### 多态的实现

C++多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。

**C++是依靠虚函数来实现动态多态的**

### C++虚函数相关，虚函数的实现原理

虚函数：在基类的函数前加上`virtual`关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.

**`C++`的虚函数是实现多态的机制**。它是通过虚函数表和虚表指针实现的，虚表是一个指针数组，它存放着指向虚函数的指针，类的实例在调用虚函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。[也就是 ==> 实现编译器处理虚函数表应该如何处理](#实现编译器处理虚函数表应该如何处理)

### 虚函数表是如何实现动态绑定的

>  虚函数的动态绑定是利用虚表和虚表指针类实现的

假如有一个类 B 继承另一个类 A ，如果基类 A 中有包含了虚函数，那么继承类 B 就可以调用基类 A 的虚函数，也就是说一个类继承了包含虚函数的基类，那么这个类就应有自己的虚表。

我们来看以下的代码。类 A 包含虚函数`vfunc1`，`vfunc2`，由于类 A 包含虚函数，故类 A 拥有一个虚表。

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

![虚函数表01](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表01.png)

**虚表是一个指针数组，它存放着指向虚函数的指针**，普通函数也就非虚函数，它的调用不需要经过虚表，所以虚表中并没有存放指向非虚函数的指针。

为了指定对象的虚表，对象中包含一个指向虚表的指针，指向自己的虚表，为了让每个包含虚表的类的对象都用一个虚表指针，编译器在类中添加一个指针`*__vptr`，每个类创建的对象的时候这个指针默认指向类的虚表。

![虚函数表02](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表02.png)

一个继承类的基类如果包含虚函数，那这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。

**那么C++ 是如何利用虚表和虚表指针来实现动态绑定的呢**？

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类 A 是基类，类 B 继承类 A，类 C 又继承类 B。类 A，类 B，类 C，其对象模型如下图所示。

![虚函数表03](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表03.png)

由于这三个类都有虚函数，所以编译器为每个类都创建了一个虚表，即类 A 的虚表（`A vtbl`），类 B 的虚表（`B vtbl`），类 C 的虚表（`C vtbl`）。类 A，类 B，类 C 的对象都拥有一个虚表指针，`*__vptr`，用来指向自己所属类的虚表。

类 A 包括两个虚函数，故 `A vtbl` 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 `B vtbl` 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 `C vtbl` 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。

综上所诉，对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向它继承的最近的一个类的虚函数。

非虚函数的调用不用经过虚表，所以不需要虚表中的指针指向这些函数


参考：[C++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)

>如果多重继承和多继承的话，子类的虚函数表长什么样子？   
>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：https://blog.csdn.net/qq_36359022/article/details/81870219


### 实现编译器处理虚函数表应该如何处理

编译器处理虚函数的方法是：

如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。
为每个类的实例添加一个虚表指针（`vptr`），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。

参考这上面的[虚函数表是如何实现动态绑定的](#虚函数表是如何实现动态绑定的)

### 基类的析构函数为什么一般写成虚函数

首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。

> 直接的讲，C++中基类采用`virtual`虚析构函数是为了防止内存泄漏。

### 构造函数为什么一般不定义为虚函数

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数，所以构造函数不能定义为虚函数。

 3） 从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。


#### 构造函数或者析构函数中调用虚函数会怎样

在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。

在析构函数中调用虚函数，此时调用的是子类的函数实现方式。

### 静态绑定和动态绑定的介绍

[C++中的静态绑定和动态绑定](https://www.cnblogs.com/lizhenghn/p/3657717.html)

静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它声明的类型，在编译的时候就确定了。在调用的时候编译器会寻找它声明的类型进行访问。

动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。


### 纯虚函数

纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承

包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象

使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。

### 虚函数和纯虚函数区别

- 虚函数是为了实现动态绑定产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上`virtual`修饰符修饰，因为`virtual`会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

- 纯虚函数只是相当于一个接口名，所以含有纯虚函数的类不能够实例化。



纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“`=0`”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，**因此它在虚函数表中的值就为 0**，而具有函数体的虚函数则是函数的具体地址。

一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。

举个例子：

```C++
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void fun1()
	{
		cout << "普通虚函数" << endl;
	}
	virtual void fun2() = 0;
	virtual ~Base() {}
};

class Son : public Base
{
public:
	virtual void fun2() 
	{
		cout << "子类实现的纯虚函数" << endl;
	}
};

int main()
{
	Base* b = new Son;
	b->fun1(); //普通虚函数
	b->fun2(); //子类实现的纯虚函数
	return 0;
}
```

### 析构函数的作用，如何起作用

构造函数只是起初始化值的作用，实当例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。

它的规则是，只要你去实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。

析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加`~`。

析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。

每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。


### 构造函数、析构函数的执行顺序

1) 构造函数顺序

① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

③ 派生类构造函数。

2) 析构函数顺序

① 调用派生类的析构函数；

② 调用成员类对象的析构函数；

③ 调用基类的析构函数。

### 类什么时候会析构？

对象生命周期结束，被销毁时；

`delete`指向对象的指针时，或`delete`指向对象的基类类型指针，而其基类虚构函数是虚函数时；

比如：对象`A`是对象`B`的成员，`B`的析构函数被调用时，对象`A`的析构函数也被调用。


### 哪些函数不能是虚函数？把你知道的都说一说

1)  构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

2)  内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间才进行类型确定，所以内联函数不能是虚函数；

3)  静态函数，静态函数不属于对象属于类，静态成员函数没有`this`指针，因此静态函数设置为虚函数没有任何意义。

4)  友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

5)  普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

### 静态函数能定义为虚函数吗，说说你的理解

1、`static`成员不属于任何类对象或类实例，所以即使给此函数加上`virutal`也是没有任何意义的。

2、静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有`this`指针。

虚函数依靠`vptr`和`vtable`来处理。`vptr`是一个指针，在类的构造函数中创建生成，并且只能用`this`指针来访问它，因为它是类的一个成员，并且`vptr`指向保存虚函数地址的`vtable`.对于静态成员函数，它没有`this`指针，所以无法访问`vptr`。

所以`static`函数不能为`virtual`，虚函数的调用关系：`this -> vptr -> vtable ->virtual function`

## 有没有了解过(复制)拷贝构造函数

1.1 拷贝构造函数是一种特殊的构造函数，函数名称必须和类的名称一致，它只有一个参数，参数类型是本类的引用。

1.2 它的作用是用来复制对象，使用这个对象的实例来初始化这个对象的另一个实例

1.3 复制构造函数被调用的三种情况：
- 当用一个对象去初始化同类的另一个对象时，复制构造函数会被调用
```cpp
Complex c2(c1);
Complex c2 = c1;
```
- 函数的返回值是类A的对象时，则类A的复制构造函数会被调用
- 当函数的参数为类的对象时，复制构造函数会被调用
```cpp
#include<iostream>
using namespace std;
class A{
public:
    A(){};
    A(A & a){
        cout<<"Copy constructor called"<<endl;
    }
};
//函数的参数为类A的对象a
void Func(A a){ }
int main(){
    A a;
    Func(a);
    return 0;
}
```
程序的输出结果为：      
`Copy constructor called`           
这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。

1.4 此外，拷贝构造函数默认为**浅拷贝**，浅拷贝是指当前类进行等号赋值时，它能够完成静态成员的值复制。当数据成员中没有指针时，浅拷贝是可行的。但是当数据成员中有指针时，如果采用简单的浅拷贝，那么这两个类中的指针将指向同一个地址，对象即将结束时，两个类会分别调用析构函数，导致指针悬挂现象。所以这时必须采用深拷贝，在堆内存中另外申请空间来储存数据，防止指针悬挂现象。==>[说一下深拷贝和浅拷贝](/寻offer总结/Cpp基础/Cpp知识点02?id=说一下深拷贝和浅拷贝)

1.5 还有就是，拷贝构造函数必须是引用传递，不能是值传递，这是为了防止递归引用。

> 这时候大概率会问深拷贝和浅拷贝。深拷贝与浅拷贝可以参考我的[另一篇文章](/C++随记/C++深拷贝和浅拷贝.md)

## 说一下深拷贝和浅拷贝

- 浅拷贝将源对象的值拷贝到目标对象中去，也就是说源对象和目标对象使用的还是同一个实体，只是他们的变量名不同，但是它们的地址是相同的。
- 深拷贝在拷贝时先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标拷贝对象中去，这样两个指针就指向了不同的内存位置，并且里面的内容还是一样的。在拷贝构造函数中深拷贝可以解决指针悬挂问题。


## C ++内存管理(内存分区)

在操作系统中，不同应用程序之间的内存时相互独立的，一般不能互相进行访问。

一个引用程序的内存一般分成五个区：

- 栈区：栈区存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
- 堆区：堆区是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
- 全局区：存放未初始化的静态变量和全局变量
- 数据区：存放初始化的静态变量和全局变量
- 代码区：代码区存储的就是可执行的代码，这个区域的属性是只读的。

![C++内存管理](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/C++内存管理.png)

编写一段代码来了解内存四区的底层结构

```cpp
#include<stdio.h>
int main()
{
 int a = 0;
 int b = 0;
 char c='0';
 printf("变量int a的地址是：%d\n变量int b的地址是：%d\n变量char c的地址是：%d\n", &a, &b, &c);
}
```

运行结果

```
变量int a的地址是：-332826852
变量int b的地址是：-332826856
变量char c的地址是：-332826857
```

可以发现`a b c` 的地址是连续的，由于`int`是4个字节，所以`a`和`b`之间间隔为4，`char`是一个字节，所以`b`与`c`间隔为1。此外，它们的地址是从`a`到`c`减少的，这是因为栈的存储结构是**先进后出**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/C++内存管理01.png)

然后我们加上静态变量`d`和全局变量`e`。

```cpp
#include<stdio.h>
int e = 0;
int main()
{
    int a = 0;
    int b = 0;
    char c='0';
    static int d = 0;
    printf("变量int a的地址是：%d\n变量int b的地址是：%d\n变量char c的地址是：%d\n", &a, &b, &c);
    printf("静态变量static int d的地址是：%d\n" ,&d);
    printf("全局变量int e的地址是：%d\n", &e);
    return 0;
}
```

运行结果：

```
变量int a的地址是：-481331432
变量int b的地址是：-481331436
变量char c的地址是：-481331437
静态变量static int d的地址是：208703516
全局变量int e的地址是：208703512
```
变量 `d` 为静态变量，运行代码后从结果上得知，静态变量 `d`的地址与一般变量 `a`、`b`、`c` 的地址并不存在连续，他们两个的内存地址是分开的。那接下来在此建一个全局变量，通过上述内容得知，全局变量与静态变量都应该存储在静态区.

而且可知**栈区、数据区都是使用栈结构对数据进行存储**。

堆并没有和栈一样的结构，也没有栈一样的先进后出，需要人为的对的内存进行分配使用。

```cpp
#include<stdio.h>
#include<string.h>
#include <malloc.h>
int main()
{
 char *p1 = (char *)malloc(1024*1000000);
 strcpy(p1, "这里是堆区");
 printf("%s\n", p1);
}
```

上面的代码使用了`malloc`开辟了一块大小为`1024*1000000`的空间，这个大小如果在栈区就会出现栈溢出的现象，而堆没有，因为堆本身就是大容量。

然后注意`p1`存储的是开辟的内存空间的地址。

### 内存泄漏的定义，什么时候会造成内存泄漏

内存泄露是指在动态分配内存的过程中，忘记释放掉分配的内存或者因为某些原因导致内存无法释放。如果严重的话会导致系统崩溃发生。

- 比如在一个函数中使用`malloc`函数开辟了`100`个单位的内存空间，并没有释放，如果这个函数频繁地被调用，久而久之就会出现严重的后果，所以在使用完之后应该加上`free`进行释放。

- 如果使用`fopen`打开一个文件，使用完之后没有使用`fclose`进行关闭也会导致内存泄漏。

- 还有没有被初始化的指针也会造成内存泄漏，因为指针未初始化的话它的执行是不可控的。包括错误的释放。比如

```cpp
int *p;  //指针未初始化

int pp = p;
free(pp); //错误释放，这里导致指针p出现指针悬挂现象
```

- 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是`virtual`，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露


### 内存泄漏避免方法

1. **`malloc/free`要配套使用**

2. **使用智能指针** ==> [C++的智能指针](/寻offer总结/Cpp基础/Cpp知识点02?id=说一下c里的智能指针)

3. **将基类的析构函数设为虚函数**；==> [析构函数为什么一般写成虚函数](/寻offer总结/Cpp基础/Cpp知识点02?id=基类的析构函数为什么一般写成虚函数)

4. **`fopen/fclose`要配套使用**

### `new/delete` 与 `malloc/free` 的异同

它们都用于动态申请内存和释放。

- `new/delete` 是`C++`的运算符,`malloc/free`是`C/C++`标准库函数，
- 在`C++`中分别使用`new` 和 `delete`来分配和释放内存。`new` 和 `delete`**是运算符，不是函数**。`new/delete`相对于`malloc/free`除了分配和释放内存之外还做了其他很多事情。
  - `new` 相对于 `malloc` 会额外的做一些初始化工作，
  - `delete` 相对于 `free` 多做一些清理工作。
  - 比如说使用`new`生成一个对象时，系统会调用这个类的构造函数，使用`delete`删除一个对象时，系统会调用这个类的析构函数。


```cpp
class A
{
 public:
     A()
     {
        cont<<"A()构造函数被调用"<<endl;
     }
     ~A()
     {
        cont<<"~A()构造函数被调用"<<endl;
     }
}

//在 main 主函数中，加入如下代码

A* pa = new A();  //类 A 的构造函数被调用
delete pa;        //类 A 的析构函数被调用
```

- `new`是封装了`malloc`，直接`free`不会报错，但是这只是释放内存，而不会析构对象。

### new和delete是如何实现的

- `new`的实现过程是：
  - 首先调用名为 **operator new** 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；
  - 接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针
- `delete`的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为**operator delete**的标准库函数释放该对象所用内存


### `delete`和`delete[]`的区别

* `delete`只会调用一次析构函数，而`delete[]`会调用每个成员的析构函数

* 用`new`分配的内存用`delete`释放，用`new[]`分配的内存用`delete[]`释放

假如说使用`new int[10]`来开辟一个内存空间，针对这种简单类型，使用`new`分配后不管是数组还是非数组形式释放都是可以的。他们的效果是一样的，**因为分配简单类型内存的时候，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统不会调用析构函数**。它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间。

```cpp
int *a = new int[10];
delete a;        //方式1
delete[] a;     //方式2

int *a = new int[10];
delete a;
delete[] a;
```

但是如果针对类`class`，两种方式就出现差异了。

```cpp
class A
{
private:
    char *m_cBuffer;
    int m_nLen;

public:
    A(){ m_cBuffer = new char[m_nLen]; }
    ~A() { delete [] m_cBuffer; }
};

A *a = new A[10];
delete a;         
//仅释放了a指针指向的(首地址)全部内存空间 
//但是只调用了a[0]对象的析构函数 
//剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏
delete[] a;      
//调用使用类对象的析构函数释放用户自己分配内存空间并且释放了a指针指向的全部内存空间
```

所以在用这些类生成对象数组的时候，建议用 `delete[]` 来释放。

### malloc申请的存储空间能用delete释放吗

不能，`malloc /free`主要为了兼容`C`，`new`和`delete` 完全可以取代malloc /free的。

`malloc /free`的操作对象都是必须明确大小的，而且不能用在动态类上。

`new` 和`delete`会自动进行类型检查和大小，`malloc/free`不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用`malloc`申请的内存是可以通过`delete`释放的。不过一般不这样写的。而且也不能保证每个`C++`的运行时都能正常。

## 结构体的内存对齐

**内存对齐是一种用空间换时间以提高效率的方式**。

**为什么会有内存对齐**？

主要是两个原因

- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。

- 硬件原因：经过内存对齐后，`CPU`访问内存的速度大大提升。

可以看一下这段C++代码输出的各个数据类型大小是多少？
```cpp
struct node{
   int num;
   char cha;
}st;
int main() {
    int a[100];
    char b[100];
    cout << sizeof(int) << endl;
    cout << sizeof(char) << endl;
    cout << sizeof(a) << endl;
    cout << sizeof(b) << endl;
    cout << sizeof(st) << endl;
}
```
看一下和自己想的结果一样么， 我们来逐一分析一下。

其输出的结果依次为：
```
4
1
400
100
8
```
此时会发现，和单纯计算字节数的话是有一些误差的。

这就是因为内存对齐的原因。

**来看一下内存对齐和非内存对齐产生的效果区别**。

`CPU`读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是`2，4，8，16`个字节，具体取多少个字节取决于硬件。

假设`CPU`把内存划分为`4`字节大小的块，要读取一个`4`字节大小的`int`型数据，来看一下这两种情况下`CPU`的工作量：

第一种就是内存对齐的情况，如图

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐01.png)

一字节的`char`占用了四个字节，空了三个字节的内存地址，`int`数据从地址`4`开始。

此时，直接将地址`4，5，6，7`处的四个字节数据读取到即可。

第二种是没有内存对齐的情况如图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐02.png)

`char`型的数据和`int`型的数据挨在一起，这个`int`数据从地址`1`开始，那么`CPU`想要读这个数据的话,来看看需要几步操作：

因为`CPU`是四个字节四个字节来寻址，

首先`CPU`读取`0，1，2，3`处的四个字节数据

然后`CPU`读取`4，5，6，7`处的四个字节数据

最后还要合并地址`1，2，3，4`处四个字节的数据才是本次操作需要的`int`数据

此时**一共需要两次寻址，一次合并的操作**。

大家可能会发现内存对齐岂不是浪费的内存资源么？

是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。

##  说一下`C++`里的智能指针

 `C++`里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是c++11支持，并且第一个已经被`c++11`弃用。

 使用原因：智能指针的作用是管理一个指针，因为在程序设计中动态分配的堆内存没有正确释放或无法释放，导致资源浪费，程序运行速度变慢等问题。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。**智能指针其实就是一个类模板**。

- `auto_ptr`：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- `unique_ptr`：是一种独占式智能指针，也就是同一时刻，只能有一个 unique_ptr 指针指向这个对象（这块内存）。在 C++14 的时候，unique_ptr 提供了 make_unique 函数。可以使用这个函数初始化性能更高。

- `shared_ptr`：是一个共享指针，多个指针指向同一个对象，最后一个指针被销毁的时候，这个对象被释放，`shared_ptr`的工作机制是使用引用计数。            
可以使用 移动语义将对象变为空或者赋值，比如:

```cpp
shared_ptr<int> p1(new int(100)); //p1 指向这个对象（内存）
shared_ptr<int> p1(std::move(2));  //移动语义，移动构造 p2，p1 不再指向这个对象而变成空

shared_ptr <int> p3;   
p3 = std::move(p2);     //移动赋值，p2 指向空，p3 指向这个对象，整个对象引用计数依旧为 1
```


- `weak_ptr`：也是一个类模板，这个指针指针指向一个由 shared_ptr 管理的对象，但是这种智能指针并不控制所指向的对象的生命周期，也就是说，将 weak_ptr 绑定到 shared_ptr 不会改变 shared_ptr 的引用计数。另外，weak_ptr 来直接访问对象，必须使用一个叫做 lock 的成员函数，lock 的功能就是检查 weak_ptr 所指向的对象是否还存在，如果存在，lock 就能返回一个共享对象的 shared_ptr 如果不存在，就返回一个空的 shared_ptr 。


更详细的C++智能指针分析见《[C++智能指针](/C++随记/07C++智能指针)》

### 智能指针出现循环引用怎么解决？

`weak_ptr` 用于专门解决 shared_ptr 循环引用的问题，weak_ptr 不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr 成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，**弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。**

### 使用智能指针管理内存资源，RAII是怎么回事

- 1) RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。

因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

- 2) 智能指针（`std::shared_ptr`和`std::unique_ptr`）即 RAII 最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记 delete 造成的内存泄漏。

毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现`delete`了。

## C++中struct和class的区别

两者都拥有成员函数、公有和私有部分,任何可以使用`class`完成的工作，同样可以使用`struct`完成不同点。

两者中如果不对成员不指定公私有，`struct`默认是公有的，`class`则默认是私有的

`class`默认是`private`继承，而`struct`模式是`public`继承

### C++和C的struct区别

`C`语言中：`struct`是用户自定义数据类型（UDT）；`C++`中`struct`是抽象数据类型（ADT），支持成员函数的定义，（`C++`中的`struct`能继承，能实现多态）

`C++`对`C`语言的`struct`进行了扩展，使`struct`在`C++`中可以和`class`一样做为类使用，不同的是`struct`的成员默认访问修饰符是`public`，而`class`默认的是`private`;

## 指针和引用的区别

* 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作
* 指针可以有多级，引用只有一级
* 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
* 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小
* 指针可以为空，引用不可以。
* 引用一旦进行初始化之后，不会再改变其指向；但指针可以


```cpp
void test(int *p) {
    int a = 1;
    p = &a;
    cout << "p = " << p << endl;  // p = 0x7ffeef7836f4  指针指向的是一个变量的地址
    cout << "*p = " << *p << endl; // *p = 1  

    int &b = a;  //b只是a的别名,引用必须初始化，不能为空
    cout << "b = a = " <<  b << endl; //b = a = 1
    // 更改b，a也会更改，对引用的操作就是对变量的本身进行操作
    b = 2;
    cout << "a = " << a << endl; //a = 2
}

int main() {
    int *p = NULL;  //指针可以为空
    test(p);
    return 0;
}
```
《[**点击查看 C++引用详细介绍**](/C++随记/03C++中引用理解和应用.md)》

## 内连接与外连接

我们知道编译的时候(假如编译器是`VS`),是以源文件`cpp`文件为单位,编译成一个个的`obj`文件,然后再通过链接器把不同的`obj`文件连接起来.

简单的说, <font color=#0099fc size=3>如果一些变量或函数的定义是**内连接**的话,链接器连接的时候就不会拿它们去与`obj`比较有没有重复定义</font> 

<font color=#008940 size=3> 而如果是**外连接**的话则需要在不同的`obj`中比较是否有重定义的.除此之外,链接器还会查看通过`extern`修饰的变量或函数声明是否在其他`obj`中的定义. </font>

## main函数执行之前和执行之后有什么区别

首先我们来看一段代码

```cpp
#include <iostream>
using namespace std;
class A {
public:
    A() {
        cout << "this is A Contructor" << endl;
    }
    ~A() {
        cout << "this is A distructor" << endl;
    }
};

A a;

int main() {
    cout << "this is main" << endl;
    return 0;
}
```

程序输出：

```
this is A Contructor
this is main
this is A distructor
```
会发现最终打印的不仅仅是`this is main`这句话

以前我总以为所有的代码都是在`main`函数执行之后才会执行的,但其实不是这样的，`main`函数只不过是提供了一个函数的入口而已，在`main`函数中的代码在执行之前，编译器会生成`_main`函数，这时候会进行所有全局对象的构造以及初始化工作。简单的说就是静态变量、全局变量和全局对象的分配是在`main`函数之前完成的，所以`C++`中并非所有的动作都是由于`main`函数引起的。

同样在`main()`函数执行后,程序退出，这时候对全局变量和全局对象进行销毁操作，所以在`main()`函数之后还会执行相应的代码

还可以使用`ateit()`函数，使`main()`函数之后可以执行其他函数。

```cpp
void fun1() {
    cout << "this is fun1" << endl;
}
void fun2() {
    cout << "this is fun2" << endl;
}
int main() {
    atexit(fun1);
    atexit(fun2);
    cout << "this is main" << endl;
    return 0;
}
```

执行结果：
```
this is main
this is fun2
this is fun1
```
## 一个函数或者可执行文件的生成过程或者编译过程是怎样的

预处理，编译，汇编，链接

> hello.c 程序的编译过程


以下是一个 hello.c 程序：

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}


```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```bash
gcc -o hello hello.c
```

这个过程大致如下：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/编译过程01.dzgn990flrs.png)

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将目标文件彼此链接起来

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/编译过程02.3rtu4k0jpqs0.png)

**源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件**


## 在C++中const的用法（定义，用途）

* const修饰类的成员变量时，表示常量不能被修改
* const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非`const`的成员函数

### define和const的联系与区别

> 编译阶段、安全性、内存占用等

**联系**：它们都是定义常量的一种方法。

**区别**：

* `define`定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，`const`定义的常量是有类型的，存放在静态区，只有一个拷贝，占用的内存空间小。
* `define`定义的常量是在预处理阶段进行替换，而`const`在编译阶段才确定它的值。
* `define`不会进行类型安全检查，而`const`会进行类型安全检查，安全性更高。
* `const`可以定义函数而`define`不可以。

### define与inline的区别

1)  `#define`是关键字，`inline`是函数；

2)  宏定义在预处理阶段进行文本替换，`inline`函数在编译阶段进行替换；

3)  `inline`函数有类型检查，相比宏定义比较安全；

### `typdef`和`define`区别

`#define`是预处理命令，在预处理是执行简单的替换，不做正确性的检查

`typedef`是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名





