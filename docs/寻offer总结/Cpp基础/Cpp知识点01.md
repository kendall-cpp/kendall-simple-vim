## 堆和栈有什么区别

* 栈，栈由系统自动分配，存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
* 堆，是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
* 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小

### 堆快一点还是栈快一点？

栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，堆在分配和释放时都要调用函数（`malloc,free`)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## C++中的重载和重写的区别：

* 重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。
* 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。

## C++模板是什么，你知道底层怎么实现的?

1) 编译器并不是把函数模板处理成能够处理任意类的函数;编译器从函数模板通过具体类型产生不同 的函数;编译器会对函数模板进行两次编译:在声明的地方对模板代码本身进行编译，在调用的地方对 参数替换后的代码进行编译。

2) 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的 头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

#### 模板会写吗？写一个比较大小的模板函数

```cpp
#include<iostream> 

using namespace std; 
template<typename type1,typename type2>//函数模板 

type1 Max(type1 a,type2 b) 

 { 

   return a > b ? a : b; 

} 

void main() 

 { 

  cout<<"Max = "<<Max(5.5,'a')<<endl; 

} 
```

### 定义和声明的区别

* 声明是告诉编译器变量的类型和名字，不会为变量分配空间

* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次


## 说一说strcpy、sprintf与memcpy这三个函数的不同之处

1)  操作对象不同

①   strcpy的两个操作对象均为字符串 

②   sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串 

③   memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

2)  执行效率不同

memcpy最高，strcpy次之，sprintf的效率最低。

3)  实现功能不同

①   strcpy主要实现字符串变量间的拷贝 

②   sprintf主要实现其他数据类型格式到字符串的转化 

③   memcpy主要是内存块间的拷贝。

### strcpy函数和strncpy函数的区别？哪个函数更安全？

1)  函数原型

~~~cpp
char* strcpy(char* strDest, const char* strSrc)
char* strncpy(char* strDest, const char* strSrc, int pos)

~~~

2)  strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。 
 strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。 

3)  如果目标长>指定长>源长，则将源长全部拷贝到目标长，自动加上’\0’ 
 如果指定长<源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’ 
 如果指定长>目标长，运行时错误 ；

## C++ 11有哪些新特性

- `nullptr`替代 `NULL`
- 引入了 `auto` 和 `decltype` 这两个关键字实现了类型推导 基于范围的 `for` 循环`for(auto& i : res){}` 类和结构体的中初始化列表
- `Lambda` 表达式(匿名函数) `std::forward_list`(单向链表)
- 右值引用和`move`语义
- 新的智能指针 `unique_ptr`和`shared_ptr`

## 说一下C++左值引用和右值引用

**左值和右值**

- 左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符`const`的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值

`const int& a = 10;`

- 右值：表示无法获取地址的对象，有常量值、函数返回值、`lambda`表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。

**左值引用和右值引用**

- 左值引用：传统的C++中引用被称为左值引用

- 右值引用：`C++11`中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置

**这里主要说一下右值引用的特点**：

特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去

特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值

特点3：T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

举个例子：
```cpp
#include <bits/stdc++.h>
using namespace std;

template<typename T>
void fun(T&& t)
{
	cout << t << endl;
}

int getInt()
{
	return 5;
}

int main() {
	
	int a = 10;
	int& b = a;  //b是左值引用
	int& c = 10;  //错误，c是左值不能使用右值初始化
	int&& d = 10;  //正确，右值引用用右值初始化
	int&& e = a;  //错误，e是右值引用不能使用左值初始化
	const int& f = a; //正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int& g = 10;//正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int&& h = 10; //正确，右值常引用
	const int& aa = h;//正确
	int& i = getInt();  //错误，i是左值引用不能使用临时变量（右值）初始化
	int&& j = getInt();  //正确，函数返回值是右值
	fun(10); //此时fun函数的参数t是右值
	fun(a); //此时fun函数的参数t是左值
	return 0;
}
```
> 《c++右值引用以及使用》：https://www.cnblogs.com/likaiming/p/9045642.html

## 成员函数里memset(this,0,sizeof(*this))会发生什么

1)  有时候类里面定义了很多`int,char,struct`等`c`语言里的那些类型的变量，我习惯在构造函数中将它们初始化为`0`，但是一句句的写太麻烦，所以直接就`memset(this, 0, sizeof *this);`将整个对象的内存全部置为`0`。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；

2)  类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；

3)  类中含有`C+`+类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。

## 你知道回调函数吗？它的作用？

1)  当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；

2)  回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；

3)  回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；

4)  因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。

## C++如何解决头文件重复问题

`C++` 多文件编程中，处理“多次 `#include` 导致重复引入”问题的方式有以下 3 种

1) 使用宏定义避免重复引入

在实际多文件开发中，我们往往使用如下的宏定义来避免发生重复引入：
```cpp
#ifndef _NAME_H
#define _NAME_H
//头文件内容
#endif
```
其中，`_NAME_H` 是宏的名称。需要注意的是，**这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同**。

当程序中第一次 `#include` 该文件时，由于 `_NAME_H` 尚未定义，所以会定义 `_NAME_H` 并执行“头文件内容”部分的代码；当发生多次 `#include` 时，因为前面已经定义了 `_NAME_H`，所以不会再重复执行“头文件内容”部分的代码。

2) 使用#pragma once避免重复引入

除了前面第一种最常用的方式之外，还可以使用 #pragma one 指令，将其附加到指定文件的最开头位置，则该文件就只会被 `#include` 一次。

和 `ifndef` 相比，`#pragma once` 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。但值得一提的是，并不是每个版本的编译器都能识别 `#pragma once` 指令，一些较老版本的编译器就不支持该指令。

3) 使用_Pragma操作符

`C99` 标准中新增加了一个和 `#pragma` 指令类似的 `_Pragma `操作符，其可以看做是 `#pragma` 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，`_Pragma` 还能和宏搭配使用。

http://c.biancheng.net/view/7636.html


## C++的四种强制转换

> `reinterpret_cast/const_cast/static_cast /dynamic_cast`

**reinterpret_cast**

```cpp
reinterpret_cast<type-id> (expression)
```
type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

**const_cast**

const_cast<type_id> (expression)

该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：

- 常量指针被转化成非常量的指针，并且仍然指向原来的对象

- 常量引用被转换成非常量的引用，并且仍然指向原来的对象

- const_cast一般用于修改底指针。如const char *p形式

**static_cast**
```cpp
static_cast < type-id > (expression)
```

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

- 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换

  - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的

  - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的

- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。

- 把空指针转换成目标类型的空指针

- 把任何类型的表达式转换成void类型

注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

**dynamic_cast**

有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全
```cpp
dynamic_cast <type-id> (expression)
```

该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*

如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的

在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全

## 野指针和悬空指针

  都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

  + 野指针   
    野指针，指的是没有被初始化过的指针

    ```cpp
    int main(void) { 
        
        int* p;     // 未初始化
        std::cout<< *p << std::endl; // 未初始化就被使用
        
        return 0;
    }
    ```

    因此，为了防止出错，对于指针初始化时都是赋值为 `nullptr`，这样在使用时编译器就会直接报错，产生非法内存访问。

  + 悬空指针    
    悬空指针，指针最初指向的内存已经被释放了的一种指针。

    ```cpp
    int main(void) { 
      int * p = nullptr;
    
      int* p2 = new int;
      
      p = p2;
    
      delete p2;
    }
    ```

    此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。

    避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。

    

产生原因及解决办法：

野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。


## C++中的多线程

C++11中引入了多线程技术，通过`thread`线程类对象来管理线程，只需要`#include <thread>`即可。`thread`类对象的创建意味着一个线程的开始。

`thread first(线程函数名，参数1，参数2，......)`；每个线程有一个线程函数，线程要做的事情就写在线程函数中。

根据操作系统上的知识，一个进程至少要有一个线程，在C++中可以认为`main`函数就是这个至少的线程，我们称之为**主线程**。而在创建`thread`对象的时候，就是在这个线程之外创建了一个独立的子线程。这里的独立是真正的独立，只要创建了这个子线程并且开始运行了，主线程就完全和它没有关系了，不知道CPU会什么时候调度它运行，什么时候结束运行，一切都是独立，自由而未知的。

- `join()`是一个阻塞函数
- `first.detach()`表示主线程不用等待子线程执行完毕，两者脱离关系。这个一般用在守护线程上：有时候我们需要建立一个暗中观察的线程，默默查询程序的某种状态，这种的称为守护线程。这种线程会在主线程销毁之后自动销毁。

C++中一个标准线程函数只能返回`void`，因此需要从线程中返回值往往采用传递引用的方法



