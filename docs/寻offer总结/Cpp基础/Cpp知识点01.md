
<!-- TOC -->

- [堆和栈有什么区别](#堆和栈有什么区别)
  - [堆快一点还是栈快一点？](#堆快一点还是栈快一点)
- [C++中的重载和重写的区别](#c中的重载和重写的区别)
- [C++模板是什么，你知道底层怎么实现的?](#c模板是什么你知道底层怎么实现的)
    - [模板会写吗？写一个比较大小的模板函数](#模板会写吗写一个比较大小的模板函数)
  - [定义和声明的区别](#定义和声明的区别)
- [说一说strcpy、sprintf与memcpy这三个函数的不同之处](#说一说strcpysprintf与memcpy这三个函数的不同之处)
  - [strcpy函数和strncpy函数的区别？哪个函数更安全？](#strcpy函数和strncpy函数的区别哪个函数更安全)
- [C++ 11有哪些新特性](#c-11有哪些新特性)
  - [nullptr 和 NULL 的区别](#nullptr-和-null-的区别)
  - [说一下C++左值引用和右值引用](#说一下c左值引用和右值引用)
- [你知道回调函数吗,它的作用](#你知道回调函数吗它的作用)
- [C++如何解决头文件重复问题](#c如何解决头文件重复问题)
- [C++的四种强制转换](#c的四种强制转换)
- [全局变量和局部变量](#全局变量和局部变量)
  - [局部变量的存储方式](#局部变量的存储方式)
  - [static 关键字](#static-关键字)
- [野指针和悬空指针](#野指针和悬空指针)
- [C++中的多线程](#c中的多线程)
- [strlen 与 sizeof 的区别](#strlen-与-sizeof-的区别)
- [迭代器：++it、it++哪个好，为什么](#迭代器itit哪个好为什么)
- [类对象所占用的内存](#类对象所占用的内存)
- [`void*` 可以直接输出值吗](#void-可以直接输出值吗)
- [inline 内联函数](#inline-内联函数)

<!-- /TOC -->

--------

## 堆和栈有什么区别

* 栈，栈由系统自动分配，存储的是一些临时变量，包括局部变量，形参，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
* 堆，是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
* 堆的生长空间向高地址生长的，地址越来越大，栈的生长空间向低地址生长的，地址越来越小

### 堆快一点还是栈快一点？

栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，堆在分配和释放时都要调用函数（`malloc,free`)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## C++中的重载和重写的区别

* 重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。
* 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。

## C++模板是什么，你知道底层怎么实现的?

-  编译器从函数模板根据不同的类型产生不同的函数; 编译器会对函数模板进行两次编译:
   - 在声明的地方对模板代码本身进行编译，
   - 在调用的地方对参数替换后的代码进行编译。

- 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

#### 模板会写吗？写一个比较大小的模板函数

```cpp
#include<iostream> 

using namespace std; 
template<typename type1,typename type2>//函数模板 

type1 Max(type1 a,type2 b) 

 { 

   return a > b ? a : b; 

} 

void main() 

 { 

  cout<<"Max = "<<Max(5.5,'a')<<endl; 

} 
```

### 定义和声明的区别

* 声明是告诉编译器变量的类型和名字，不会为变量分配空间

* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次


## 说一说strcpy、sprintf与memcpy这三个函数的不同之处

1)  操作对象不同

①   `strcpy`的两个操作对象均为字符串 

②   `sprintf`的操作源对象可以是多种数据类型，目的操作对象是字符串 

③   `memcpy`的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

2)  执行效率不同

`memcpy`最高，`strcpy`次之，`sprintf`的效率最低。

3)  实现功能不同

①   `strcpy`主要实现字符串变量间的拷贝 

②   `sprintf`主要实现其他数据类型格式到字符串的转化 

③   `memcpy`主要是内存块间的拷贝。

>  `strcpy`主要实现字符串变量间的拷贝，函数传递的两个参数都是字符串   
> `sprintf`主要实现其他类型转成字符串     
> `memcpy`主要是内存块间的拷贝。

### strcpy函数和strncpy函数的区别？哪个函数更安全？

 函数原型

```cpp
char* strcpy(char* strDest, const char* strSrc)
char* strncpy(char* strDest, const char* strSrc, int pos)
```

 - `strcpy`函数: 如果参数 `dest` 所指的内存空间不够大，可能会造成**缓冲溢出**(`buffer Overflow`)的错误情况，在编写程序时请特别留意，或者用`strncpy()`来取代。  *src ==> dest* 
 - `strncpy`函数：用来复制源字符串的前`n`个字符，`src` 和 `dest` 所指的内存区域**不能重叠**，且 `dest` 必须有足够的空间放置`n`个字符。 *src 前 n 个字符 ==> dest (不能重叠)*



## C++ 11有哪些新特性

- `nullptr`替代 `NULL`
- 引入了 `auto` 和 `decltype` 这两个关键字实现了类型推导
- 基于范围的 `for` 循环`for(auto& i : res){}` 类和结构体的中初始化列表
- `Lambda` 表达式(匿名函数) `std::forward_list`(单向链表)
- 右值引用和`move`语义
- 新的智能指针 `unique_ptr`和`shared_ptr`

### nullptr 和 NULL 的区别

`NULL`在`C++`中就是 0，这是因为在 C++ 中`void*` 类型是不允许隐式转换成其他类型的，所以之前 C++ 中用 0 来代表空指针，但是在重载整形的情况下，会出现空指针二义性问题。所以，`C++11`加入了`nullptr`，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用`nullptr`替代`NULL`吧，而`NULL`就当做 0 使用。

### 说一下C++左值引用和右值引用

**左值和右值**

- **左值**：**表示的是可以获取地址的表达式**，它能出现在赋值语句的左边，对该表达式进行赋值。但是如果用`const`修饰符修饰的时候，比如`const int& a = 10;`，它可以取得地址，但是没办法对它进行赋值。*左值常引用相当于是万能型，可以用左值或者右值初始化*

- **右值**：**表示无法获取地址的对象**，<u>有常量值、函数返回值</u>、`lambda`表达式等。<u>无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</u>

**左值引用和右值引用**

- **左值引用**：传统的C++中引用被称为左值引用

- **右值引用**：<u>`C++11`中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</u>

**这里主要说一下右值引用的特点**：

特点1：右值引用的生命周期与右值引用类型变量的**生命周期一样长**，只要该变量还活着，该右值临时量将会一直存活下去

特点2：右值引用独立于左值和右值。意思是<u>右值引用类型的变量可能是左值也可能是右值</u>

特点3：`T&& t`在发生自动类型推断的时候，它是左值还是右值**取决于它的初始化**。

举个例子：
```cpp
#include <bits/stdc++.h>
using namespace std;

template<typename T>
void fun(T&& t)
{
	cout << t << endl;
}

int getInt()
{
	return 5;
}

int main() {
	
	int a = 10;
	int& b = a;  //b是左值引用
	int& c = 10;  //错误，c是左值不能使用右值初始化
	int&& d = 10;  //正确，右值引用用右值初始化
	int&& e = a;  //错误，e是右值引用不能使用左值初始化
	const int& f = a; //正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int& g = 10;//正确，左值常引用相当于是万能型，可以用左值或者右值初始化
	const int&& h = 10; //正确，右值常引用
	const int& aa = h;//正确
	int& i = getInt();  //错误，i是左值引用不能使用临时变量（右值）初始化
	int&& j = getInt();  //正确，函数返回值是右值
	fun(10); //此时fun函数的参数t是右值
	fun(a); //此时fun函数的参数t是左值
	return 0;
}
```
> 《c++右值引用以及使用》：https://www.cnblogs.com/likaiming/p/9045642.html


## 你知道回调函数吗,它的作用

1)  当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；

2)  回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：
    1) 声明；
    2) 定义；
    3) 设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；

3)  **回调函数就是一个通过函数指针调用的函数**。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；

4) 因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为`int`）的被调用函数。

> 回调函数就是一个通过函数指针调用的函数，就是把一个函数的指针作为一个参数传递给另一个函数。   
>  作用：可以把调用者与被调用者分开，调用者不用关心谁被调用。

## C++如何解决头文件重复问题

`C++` 多文件编程中，处理“多次 `#include` 导致重复引入”问题的方式有以下 3 种

1) **使用宏定义避免重复引入**

在实际多文件开发中，我们往往使用如下的宏定义来避免发生重复引入：
```cpp
#ifndef _NAME_H
#define _NAME_H
//头文件内容
#endif
```
其中，`_NAME_H` 是宏的名称。需要注意的是，**这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同**。

当程序中第一次 `#include` 该文件时，由于 `_NAME_H` 尚未定义，所以会定义 `_NAME_H` 并执行“头文件内容”部分的代码；当发生多次 `#include` 时，因为前面已经定义了 `_NAME_H`，所以不会再重复执行“头文件内容”部分的代码。

2) **使用`#pragma once`避免重复引入**

除了前面第一种最常用的方式之外，还可以使用 `#pragma one` 指令，将其附加到指定文件的最开头位置，则该文件就只会被 `#include` 一次。

和 `ifndef` 相比，`#pragma once` <u>不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以**效率很高**</u>。但值得一提的是，并不是每个版本的编译器都能识别 `#pragma once` 指令，一些较老版本的编译器就不支持该指令。

3) **使用`_Pragma`操作符**

`C99` 标准中新增加了一个和 `#pragma` 指令类似的 `_Pragma `操作符，其可以看做是 `#pragma` 的增强版，<u>不仅可以实现 `#pragma` 所有的功能，更重要的是，`_Pragma` 还能和宏搭配使用</u>。

http://c.biancheng.net/view/7636.html


## C++的四种强制转换

> `reinterpret_cast/const_cast/static_cast /dynamic_cast`

- **reinterpret_cast**

>  [ˌriːɪnˈtɜːrprət]

```cpp
reinterpret_cast<type-id> (expression)
```
type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

- **const_cast**

```cpp
const_cast<type_id> (expression)
```

`type_id` 必须为指针或引用

该运算符用来修改类型的`const`或`volatile`「 `[ˈvɑːlətl]`」属性。除了`const `或`volatile`修饰之外，`type_id`和`expression`的类型是一样的。用法如下：

<1> 常量指针被转化成非常量的指针，并且仍然指向原来的对象

<2> 常量引用被转换成非常量的引用，并且仍然指向原来的对象



- **static_cast**
```cpp
static_cast < type_id > (expression)
```

该运算符把`expression`转换为`type_id`类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

  - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换

    - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的

    - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的

  - 用于**基本数据类型之间的转换**，如把`int`转换成`char`，把`int`转换成`enum`。这种转换的安全性也要开发人员来保证。

  - 把空指针转换成目标类型的空指针

  - 把任何类型的表达式转换成`void`类型

> 注意：`static_cast`不能转换掉`expression`的`const`、`volatile`、或者`__unaligned`属性。

> 关键词：没有类型检查安全，派生类-->基类 安全  基类-->派生类 不安全，基本数据类型转换

- **dynamic_cast**

> `daɪˈnæmɪk`

有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全

```cpp
dynamic_cast <type-id> (expression)
```

该运算符把`expression`转换成`type-id`类型的对象。`type-id `必须是类的指针、类的引用或者`void*`

如果 `type-id `是类指针类型，那么`expression`也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用

`dynamic_cast`运算符可以在执行期决定真正的类型，也就是说`expression`必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）

`dynamic_cast`主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换

在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的

在进行下行转换时，`dynamic_cast`具有**类型检查的功能**，比`static_cast`更安全

> 关键词：有类型检查安全，可以在执行期决定真正的类型，用于类的层次转换

## 全局变量和局部变量

- 局部变量，在一个函数内部定义的变量叫做局部变量，它只是在本函数范围内有效，也就是说只有在本函数内才能使用，在函数外部是不能使用这些变量。

- 形参也是局部变量

- 在函数外部定义的变量叫做**全局变量**，它的有效范围是从定义的位置到程序结束。

- 如果某个函数想引用在它后面定义的全局变量，就可以在函数前面使用关键字 extern 做一个外部变量说明，表示这个变量在函数的外部定义，这样在函数内部就可以使用这个变量了。但是注意，在做外部变量说明时，是不可以给变量赋初值的。

>  在 linux 下可以使用 `nm` 命令列出某些文件中的符号（就是一些函数和全局变量等）

```cpp
extern int c1,c2;   //外部变量说明，不能赋值
void lookvalue()
{
  c1 = 5;            //因为用了 extern 外部变量说明，所以这里可以使用
  c2 = 8;
  return ;
}
void lookvalue1() {
    cout << c1 << " " << c2 << endl;
    return;
}
int c1,c2;    //这里才是全局变量的地方


int main() {

    lookvalue1(); // 0 0
    lookvalue();
    lookvalue1(); // 5 8
    return 0;
}
```

- 在同一源文件中，如果全局变量和局部变量同名，就会直接访问局部变量，全局变量不起作用。

> 函数背部有效，形参 ，栈区
> 全局变量，前面使用要用 extern，不能赋初值，同名时全局变量被覆盖

### 局部变量的存储方式

一般来说，**局部变量存储在动态存储区**，也就是存放在**栈区**

如果希望函数中局部变量在函数调用结束之后不自动消失，也就是它占用的存储单元不释放，下一次调用该函数时，该变量中保存的值就是上一次函数调用结束时的值。可以在遍历前面用 static 关键字加以说明即可。

- 局部静态变量存储在静态存储区，程序整个运行区间都不释放
- 局部静态变量是在编译时赋初值的。如果在定义的时候不赋初值就默认为 0 ，普通变量的定义和赋值是在函数调用时才进行的。如果不赋初值，它是一个不确定的值。

### static 关键字

- 函数内部定义一个局部对象时，使用 static 关键字时，这个变量就保存在静态存储区，在编译的时候初始化，如果不给初始化值，它的值就会被初始化为 0，并且，下次调用这个函数的时候该变量中保存的值就是上一次函数调用结束时的值

- 在全局变量时使用 static 关键字，那么这个全局变量只能在本文件中使用，无法在其他文件中被引用。

- 在函数之前加 static 时，那么函数只能在本源程序文件中调用，无法在其他源程序文件中调用。

- 在一个类中定义 static 成员，那么这个成员不属于某个对象，而是属于整个类。

> 编译阶段初始化，全局变量，函数，对象

## 野指针和悬空指针

都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

  + **野指针**   
    野指针，指的是没有被初始化过的指针

    ```cpp
    int main(void) { 
        
        int* p;     // 未初始化
        std::cout<< *p << std::endl; // 未初始化就被使用
        
        return 0;
    }
    ```

    因此，为了防止出错，对于指针初始化时都是赋值为 `nullptr`，这样在使用时编译器就会直接报错，产生非法内存访问。

  + **悬空指针**    
    悬空指针，指针最初指向的内存已经被释放了的一种指针。

    ```cpp
    int main(void) { 
      int * p = nullptr;
    
      int* p2 = new int;
      
      p = p2;
    
      delete p2;
    }
    ```

    此时 `p`和`p2`就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。

    避免野指针比较简单，但悬空指针比较麻烦。`c++`引入了智能指针，`C++`智能指针的本质就是避免悬空指针的产生。

    

**产生原因及解决办法**：

- 野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

- 悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。


## C++中的多线程

C++11中引入了多线程技术，通过`thread`线程类对象来管理线程，只需要`#include <thread>`即可。`thread`类对象的创建意味着一个线程的开始。

`thread first(线程函数名，参数1，参数2，......)`；每个线程有一个线程函数，线程要做的事情就写在线程函数中。

根据操作系统上的知识，一个进程至少要有一个线程，在C++中可以认为`main`函数就是这个至少的线程，我们称之为**主线程**。而在创建`thread`对象的时候，就是在这个线程之外创建了一个独立的子线程。这里的独立是真正的独立，只要创建了这个子线程并且开始运行了，主线程就完全和它没有关系了，不知道CPU会什么时候调度它运行，什么时候结束运行，一切都是独立，自由而未知的。

- `join()`是一个阻塞函数
- `first.detach()`表示主线程不用等待子线程执行完毕，两者脱离关系。这个一般用在守护线程上：有时候我们需要建立一个暗中观察的线程，默默查询程序的某种状态，这种的称为守护线程。这种线程会在主线程销毁之后自动销毁。

C++中一个标准线程函数只能返回`void`，因此需要从线程中返回值往往采用传递引用的方法

## strlen 与 sizeof 的区别

-  sizeof 是一个单目运算符，strlen是 函数。用 sizeof 时，会在测量的长度后加 `\0` ,而且分别在 int 和 char 的两种情况下得到的结果不同；用 strlen 则是精确算出其长度（不会加`\0`），但是 strlen 读到 `\0` 就会停止。

- 对 sizeof 而言，因为缓冲区已经用已知字符串进行了初始化，其长度是固定的，所以 sizeof 在**编译时**计算缓冲区的长度。也正是由于在编译时计算，因此 sizeof 不能用来返回动态分配的内存空间的大小。


## 迭代器：++it、it++哪个好，为什么

- 前置返回一个引用，后置返回一个对象

```cpp
// ++i实现代码为：
int& operator++()
{

  *this += 1;
  return *this;

} 
```

- 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低

```cpp
//i++实现代码为：                 
int operator++(int)                 
{
int temp = *this;                   

   ++*this;                       

   return temp;                  
} 
```

## 类对象所占用的内存

```cpp
class A {
public:
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 1
    return 0;
}
```
一个空类 sizeof(a) 的结果是 1。因为对象是有地址的。内存中的一个地址单元**里面存的是 1 个字节的内容**

```cpp
class A {
public:
    void func1();
    void func2();
    
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 1
    return 0;
}
```

类中的成员函数是不占用类对象内存空间的。

```cpp
class A {
public:
    int a = 1;
    void func1();
    void func2();
    
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 4
    return 0;
}
````

成员变量是包含在每个对象中，占字节的

```cpp
class A {
public:
    int a = 1;
    void func1() {
        int a = 2;
    }
    void func2();
    
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 4
    return 0;
}
```

成员函数不占类对象的字节空间

```cpp
class A {
public:
    virtual void fun3();
    
};

int main() {
    cout << sizeof(A) << endl; // 8
    return 0;
}
```

类中如果有一个虚函数，对象的 sizeof 会增加 4 个字节，因为这个类会有一个指向虚函数的指针。（但是我在 Linux 和 MacBook 测试是 8）

> 注意： sizeof(a)的返回值是一个无符号整数十进制的值，即 unsigned_int, 并不是 int 类型

静态成员变量不计算在对象的 sizeof 内

## `void*` 可以直接输出值吗

- `void *` 可以定义一个指针变量，但不说明它指向哪一种类型数据.

- `void *`可以强制转换成任何其他的类型

- 使用`void *`表示该函数指针可以不用指定为某种特定类型。例如，在套接字函数中，`send(void * pData, int nLength)`这意味着您可以通过多种方式调用它，`pData` 可以是字符串，甚至可以是一个对象。例如
  
  ```c
  char * data = "blah";
  send(data, strlen(data));
  POINT p;
  p.x = 1;
  p.y = 2;
  send(&p, sizeof(POINT));
  ```

- 指向`0`的地址,`(void *)0`，指向全是`0`的地址，相当于`NULL`。

- 可执行 赋值，取值操作，但**不能用于指定数据输出**，因为没有指定要输出的数据长度，如果可以输出，那么将会是一个无限长的输出。

-------

## inline 内联函数

在编译阶段完成对 inline  函数的处理，系统尝试将调用函数的动作替换为函数的本体（不再是函数调用）这种方式就省去了压栈，出栈动作，提升程序的性能。

inline 关键字只是程序员对编译器的一个建议，编译器可以去做或者不做。

