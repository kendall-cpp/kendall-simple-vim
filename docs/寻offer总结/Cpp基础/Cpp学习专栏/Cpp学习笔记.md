
- [C++的内存管理](#c的内存管理)
  - [堆](#堆)
  - [栈](#栈)
  - [RAII](#raii)
- [实现C++智能指针](#实现c智能指针)
  - [模板化变成一个类模板](#模板化变成一个类模板)


-----
## C++的内存管理

> 笔记来源：https://time.geekbang.org/column/article/169225

C++的内存管理需要涉及三个重要的概念：堆，栈，RAII。

- **堆**

在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。          
    
C++ 标准里一个相关概念是自由存储区，就是 free shop ,指使用 new 和 delete 来分配和释放内存区域，一般而言，这是堆的一个子集。

- new 和 delete 操作的区域是 free 
- storemalloc 和 free 操作的区域是 heap

但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。

- **栈**

在内存管理环境下，栈值的是函数调用过程中产生的本地变量和调用数据的区域，这个栈和数据结构中的栈其实很相似，都是先进后出。

- **RAII**

是 C++ 所特有的资源管理方式。RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，

### 堆

在堆上分配内存，有些语言可能使用 new 这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作：
  - 让内存管理器分配一个一定大小的内存块
  - 让内存管理器释放一个之前分配的内存块
  - 让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放

C++ 通常使用上面的 1 和 2。

> C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。

第一，分配内存要考虑程序当前已经有多少未分配的内存。内存不足时要从操作系统申请新的内存。内存充足时，要从可用的内存里取出一块合适大小的内存，并将其标记为已用，然后将其返回给要求内存的代码。

第二，释放内存不只是简单地把内存标记为未使用。对于连续未使用的内存块，通常内存管理器需要将其合并成一块，以便可以满足后续的较大内存分配要求。毕竟，目前的编程模式都要求申请的内存块是连续的。

第三，垃圾收集操作有很多不同的策略和实现方式，以实现性能、实时性、额外开销等各方面的平衡。但是 C++ 里通常都不使用垃圾收集。



**在不考虑垃圾收集的情况下，内存需要手工释放；我们可以使用 new 和 delete。每个 new 出来的对象都应该用 delete 来释放，但是在此过程中，内存也可能有碎片化的情况**。

但是我们如果漏掉了 delete ，就会导致内存泄漏。

> 在C++中，更常见、也更合理的情况，是分配和释放不在一个函数里。


### 栈

我们先来看一段示例代码，来说明 C++ 里函数调用、本地变量是如何使用栈的。

```cpp

void foo(int n)
{
  …
}

void bar(int n)
{
  int a = n + 1;
  foo(a);
}

int main()
{
  …
  bar(42);
  …
}
```

这段代码执行过程中的栈变化：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存管理栈变化01.5br4oybod6w0.png)

栈是向上增长的，栈的生长方向是地地址，因而上方意味着低地址。当一个函数调用另一个函数的时候，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，分配出本地变量所需的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。

本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。

- 栈上的分配极为简单，移动一下栈指针而已。
- 栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。
- 由于后进先出的执行过程，不可能出现内存碎片。

> 注意：编译器会自动调用析构函数，包括在函数执行发生异常的情况。也就是不管是否发生了异常，析构函数都会得到执行。「也就是栈展开」


### RAII

C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：
- 对象很大；
- 对象的大小在编译时不能确定；
- 对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。

设置一个函数返回值类型是基类，那么怎么保证返回值不发生内存泄露呢？

答案就在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。

```cpp
class shape_wrapper {
public:
  explicit shape_wrapper(
    shape* ptr = nullptr)
    : ptr_(ptr) {}
  ~shape_wrapper()
  {
    delete ptr_;
  }
  shape* get() const { return ptr_; }

private:
  shape* ptr_;
};
```

那么这样 delete 指针为空的话会怎样呢？

事实上，使用 new 分配内存时，会调用构造函数构造一个对象，如果构造成功 new 整体操作就完成，如果构造失败，那么就会释放掉刚刚分配内存并向外抛出构造函数产生异常。delete 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。

在析构函数里做必要的清理工作，这就是 RAII 的基本用法。

这种清理并不限于释放内存，也可以是：

- 关闭文件（fstream 的析构就会这么做）

- 释放同步锁

- 释放其他重要的系统资源

> [动手敲的代码](/寻offer总结/Cpp基础/Cpp学习专栏/code/Cpp学习笔记Code?id=c的内存管理代码)

具体见：[这里的 RAII 部分](https://time.geekbang.org/column/article/169225)


-----

## 实现C++智能指针

回忆一下这个类

```cpp
class shape_wrapper {
public:
  explicit shape_wrapper(
    shape* ptr = nullptr)
    : ptr_(ptr) {}
  ~shape_wrapper()
  {
    delete ptr_;
  }
  shape* get() const { return ptr_; }

private:
  shape* ptr_;
};
```

这个类可以完成智能指针的最基本的功能：**对超出作用域的对象进行释放**

但是：

- 这个类只适用于 shape 类
- 该类对象的行为不够像指针拷贝
- 该类对象会引发程序行为异常

### 模板化变成一个类模板

要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。

我们就是在开头增加模板声明 template ，然后把代码中的 shape 替换成模板参数 T 而已。

这个模板使用也很简单，把原来的 `shape_wrapper` 改成 `smart_ptr` 就行。

目前这个 smart_ptr 的行为还是和指针有点差异的：

- 它不能用 `*` 运算符解引用
- 它不能用 `->` 运算符指向对象成员
- 它不能像指针一样用在布尔表达式里

不过，这些问题也相当容易解决，加几个成员函数就可以：

```cpp
template <typename T>
class smart_ptr {
public:
    // explicit 的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,
  explicit smart_ptr(T* ptr = nullptr)
    : ptr_(ptr) 
    {}

  ~smart_ptr()
  {
    delete ptr_;
  }
  
  T* get() const { return ptr_; }

  T& operator*() const 
  { 
      return *ptr_; 
    } 
    T* operator->() const 
    { 
        return ptr_; 
    }
    operator bool() const 
    { 
        return ptr_; 
    }

private:
  T* ptr_;
};
```

如果我们拷贝,比如：

```cpp
smart_ptr<shape> ptr1{create_shape(shape_type::circle)};
smart_ptr<shape> ptr2{ptr1};
```

编译的时候不报错，但是执行的时候就报错。

```
a.out(88274,0x10c1d55c0) malloc: *** error for object 0x7f8628402b60: pointer being freed was not allocated
a.out(88274,0x10c1d55c0) malloc: *** set a breakpoint in malloc_error_break to debug
Abort trap: 6
```





