## 并发和并行有什么区别

在单核CPU的某一个瞬间只会运行一个程序，但是一个期间内，就会运行很多个进程，它们之间的切换非常快，让人产生并行的错觉，实际上是并发执行的。


- 并发就是一段时间内多个任务被处理，但是在同一个时刻，只有一个任务在执行
- 并行就是在同一时刻，有多个任务在执行，这个需要多核 CPU 才能完成

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/并发并行.4yasajdkbdo0.png)

## 进程的基本状态以及它们的转化

- 就绪状态：其他资源准备好，只差`CPU`资源的状态就称为就绪状态，只要获得`CPU`的使用权，就可以独立运行。
- 执行状态：进程获得`CPU`资源，程序正在处理器上执行，在单处理机中(`1`核)，在某个时刻最多只能有一个进程正在执行
- 阻塞状态：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

当然，进程另外两个基本状态：

- 创建状态（new）：进程正在被创建时的状态；
- 结束状态（Exit）：进程正在从系统中消失时的状态；

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程的状态.7e6q9ri1vzc0.png)

当一个进程获取 CPU 时，就会**从就绪状态转成执行状态**，当一个进程被剥夺 `CPU` 时，比如系统分配的时间片被用完，或者出现优先级更高的进程，就会**由运行状态变成就绪状态**，当一个运行进程由于某事件被阻时，比如申请资源被占用、启动 I/O 传输未完成，状态就会由 **运行状态变成阻塞状态**，当所有的等待事件发生时，比如得到申请资源、I/O 参数完成，状态就由 **阻塞变成就绪**。

> - 实际上进程还有另外一个状态 ---- **挂起状态**
> 
> 因为如果大量的进程处于阻塞状态，可能会一直占用着物理内存，当然这不是我们希望的，毕竟物理内存是有限的，所以在虚拟内存管理的操作系统中，通常会把阻塞状态的物理内存空间切换到硬盘，等需要运行的时候再从硬盘中换回到物理内存。那么就需要一个新的状态来**描述有没有占用实际物理内存的情况，这个状态就是挂起状态**，这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。
>
> 另外，挂起状态可以分为两种：
>
>   1. 阻塞挂起状态：进程在硬盘中（外存），等待某个事件出现
>   2. 就绪挂起状态：进程在硬盘中（外存），但主要进入内存就会立即执行。

## 什么是程序控制块PCB

PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

PCB 还用于记录当前进程的状态和控制进程运行的全部信息

### 每个 PCB 是如何组织的呢

通常是通过**链表**的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

除了链接的组织方式，还有**索引方式**，它的工作原理：**将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。**

一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

## 进程的上下文切换

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个**一个进程切换到另一个进程运行，称为进程的上下文切换**。

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

通常，会把交换的信息保存在进程的 PCB，当正在运行另外一个进程的时候要切换到这个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程上下文.22teesvhcg5c.png)

> 但是需要注意的是，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。

### 发生进程上下文切换有哪些场景

- 当一个进程的 CPU 时间片会完了的时候，这个进程就会由运行状态变成就绪状态，然后系统从就绪队列中选择另外一个进程运行。
- 当一个进程在系统资源不足，要等系统资源满足的时候才会被运行，这时候这个进程就会被挂起，然后调度其他进程先运行。
- 当一个进程通过睡眠函数 `sleep` 主动挂起的时候，自然也会进程调度，发生进程上下文切换。
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

## 进程、线程、协程(区别)
- 进程: 直观的说，就是保存在硬盘中的程序在运行以后，那么这个运行起来的执行程序就是进程了。另外，操作系统会**以进程为单位**进行分配资源，比如说`CPU`时间片，内存等资源。**进程是资源分配的最小单位**。

- 刚刚说到系统运行一个可执行程序就是进程，那么线程就是这个执行程序的基本单位，也可以说是**轻量级的进程**，<font color=#268bd2> 线程是操作系统进行 CPU 调度的最小单位</font>。然后每个进程都有一个唯一的主线程，主线程和进程是相互依存的，主线程结束进程也会终止。

- 进程和线程属于包含关系，没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一个线程完成的，而是多个线程共同完成的；线程是进程的一部分。另外线程可以共享它对应进程的系统资源。

- 在系统开销方面，每个进程都有独立的代码和数据空间（也就是程序的上下文），进程之间的切换会有较大的开销，因为涉及到系统的资源分配；线程因为是轻量级的进程，所以线程的切换开销小很多。而且同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

- 协程：**协程是一种用户态的轻量级线程**，协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程在调度切换的时候，将寄存器上下文保存在其他地方，在需要切换回来的时候恢复之前保存的寄存器上下文和栈，这种直接去操作栈而不是不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。

## 线程上下文切换的是什么

这还得看线程是不是属于同一个进程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；

所以，线程的上下文切换相比进程，开销要小很多。

## 线程的实现

主要有三种线程的实现方式：

- 用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
- 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；
- 轻量级进程（LightWeight Process）：在内核中来支持用户线程；
  
> - 用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。
> 
>   所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。

> - 内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。


### 用户线程和内核线程的对应关系

首先，第一种关系是多对一的关系，也就是多个用户线程对应同一个内核线程：

第二种是一对一的关系，也就是一个用户线程对应一个内核线程：

第三种是多对多的关系，也就是多个用户线程对应到多个内核线程：

## 进程的调度时机

当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。

什么时候会发生 CPU 调度呢？通常有以下情况：

- 当进程从运行状态转到等待状态；
- 当进程从运行状态转到就绪状态；
- 当进程从等待状态转到就绪状态；
- 当进程从运行状态转到终止状态；

其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。

非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。

而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。

接下来，说说常见的调度算法：

- 先来先服务调度算法
- 最短作业优先调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 最高优先级调度算法
- 多级反馈队列调度算法

------

## 进程间通信

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

- 管道

比如说在Linux终端敲下命令

```bash
ps -ef | grep bash
```

上面命令行里的「`|`」竖线就是一个管道，它的功能是将前一个命令（`ps -ef`）的输出，作为后一个命令（`grep bash`）的输入，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。


同时，我们得知上面这种管道是没有名字，所以「`|`」表示的管道称为匿名管道，用完了就销毁。

管道还有另外一个类型是命名管道，也被叫做 `FIFO`，因为数据是先进先出的传输方式。

在使用命名管道前，先需要通过 `mkfifo` 命令来创建，并且指定管道名字：


