## 1.进程的基本状态以及它们的转化

- 就绪状态：其他资源准备好，只差CPU资源的状态就称为就绪状态，只要获得CPU的使用权，就可以独立运行。
- 执行状态：进程获得CPU资源，程序正在处理器上执行，在单处理机中(1核)，在某个时刻最多只能有一个进程正在执行
- 阻塞状态：当进程因为某种原因，比如其他设备未就绪而无法继续执行，但是并没有放弃CPU的使用权。
- 创建状态：创建进程时拥有PCB但是其他资源尚未就绪的状态。创建状态成为两步：第一步分配PCB，第二步插入就绪队列。
    > - **进程的控制块**（PCB）：用于描述和控制进程运行的通用数据结构，每个进程都有进程控制块
    > - PCB还用于记录当前状态和控制进程运行的全部信息
    > - PCB使得进程是能够独立运行的基本单位，每个进程都依赖于进程控制块去被操作系统调度
- 终止状态: 进程结束由系统清理或者归还PCB的状态，分成两步：第一步是系统清理，第二步是归还 PCB。

![](./img/进程与线程01.png)

当一个进程获取 CPU 时，就会**从就绪状态转成执行状态**，当一个进程被剥夺 CPU 时，比如系统分配的时间片被用完，或者出现优先级更高的进程，就会**由运行状态变成就绪状态**，当一个运行进程由于某事件被阻时，比如申请资源被占用、启动 I/O 传输未完成，状态就会由 **执行变成阻塞**，当所有的等待事件发生时，比如得到申请资源、I/O 参数完成，状态就由 **阻塞变成就绪**。

## 2.进程和线程的区别

- 进程是**资源调度**的基本单位，运行一个可执行程序会创建一个或者多个进程，进程就是运行起来的可执行程序。
- 线程是**程序执行**的基本单位，是轻量级的进程，每个进程中都有且仅有一个唯一的主线程，主线程和进程是相互依存的，主线程结束进程也会结束。
- **拥有资源**：不论是传统的还是引入线程的操作系统，进程都是拥有资源的基本单位，线程不拥有资源（也有一点必不可少的资源），但是线程可以共享隶属进程的系统资源。
- **并发性**：在操作系统中，系统要分配和回收资源，比如内存空间、I/O设备等，因此操作系统付出的开销远大于创建或者撤销线程的开销，而线程切换时只需要保存和设置少量寄存器内存，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至不需要操作系统的干预。
- **地址空间和其他资源**（比如打开的文件）：进程的地址空间之间相互独立，同一进程的各个线程间共享进程的资源，一个进程内的线程对于其他进程是不可见的。
- **通信方面**：进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段（比如全局变量）来进行通信。

## 3.Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关

32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。

理论上，一个进程可用虚拟空间是`2G`，默认情况下，线程的栈的大小是`1MB`，所以理论上最多只能创建`2048`个线程。如果要创建多于`2048`的话，必须修改编译器的设置。

因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过`2K`以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。

## 4.进程之间的通信方法有哪几种（重点）

进程之间的通信有六种：分别是**管道**，**信号量**，**消息队列**，**信号**，**共享内存**，**套接字**。

* 管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的

![](./img/进程通信01.png)

匿名管道`pipe`和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。

管道的底层实现 https://segmentfault.com/a/1190000009528245

* 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(`P(sv)`)就是将其值减一或者挂起进程，发送(`V(sv)`)就是将其值加一或者将进程恢复运行。

* 信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的

* 共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。

* 消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。
  消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
  可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。

* 套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。

## 5.进程同步的四种方法?
- 1. 临界区

对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```cpp
// entry section
// critical section;
// exit section
```
- 2. 同步与互斥 
  
同步:多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。

互斥:多个进程在同一时刻只有一个进程能进入临界区。

- 3. 信号量

信号量(Semaphore)是一个整型变量，可以对其执行 `down` 和 `up` 操作，也就是常见的 `P` 和 `V` 操作。

`down` : 如果信号量大于 `0` ，执行 `-1` 操作;如果信号量等于 `0`，进程睡眠，等待信号量大于 `0`;

`up` :对信号量执行 `+1` 操作，唤醒睡眠的进程让其完成 down 操作。

`down` 和 `up` 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 `0` 或者 `1`，那么就成为了 互斥量(`Mutex`) ，`0` 表示临界区已经加锁，`1` 表示临界区解锁。
```cpp
typedef int semaphore;
semaphore mutex = 1;
void P1() {
down(&mutex); // 临界区 up(&mutex);
}
void P2() {
    down(&mutex);
// 临界区
    up(&mutex);
}
```
- 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

C 语言不支持管程，下面的示例代码使用了类 `Pascal` 语言来描述管程。示例代码的管程提供了 `insert()`和 `remove()` 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```c
monitor ProducerConsumer
    integer i;
condition c;
    procedure insert();
    begin
// ...
end;
    procedure remove();
    begin
// ...
    end;
end monitor;
```

**使用信号量实现生产者-消费者问题**

问题描述:使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品;只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这 里需要使用两个信号量:`empty` 记录空缓冲区的数量，`full` 记录满缓冲区的数量。

其中，`empty` 信号量是在生产者进程中使用，当 `empty` 不为 `0` 时，生产者才可以放入物品;`full` 信号 量是在消费者进程中使用，当 `full` 信号量不为 `0` 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 `down(mutex)` 再执行 `down(empty)`。如果这么做了，那么可能会出现这种情况:生产者对缓冲区加锁后，执行 `down(empty)` 操作，发现 `empty = 0`，此时生产者睡眠。

消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 `up(empty)` 操作，`empty` 永远都为 `0`，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```cpp
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;
void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
} }
void consumer() {
    while(TRUE) {
} }
```

管程有一个重要特性:**在一个时刻只能有一个进程使用管程**。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 条件变量 以及相关的操作:`wait()` 和 `signal()` 来实现同步操作。对条件变量执行 `wait()` 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。`signal()` 操作用于唤醒被阻塞的进程。

**使用管程实现生产者消费者问题**：
```c
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;
    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
end;
    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;
// 生产者客户端 procedure producer begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;
// 消费者客户端 procedure consumer begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

## 6.孤儿进程和僵尸进程分别是什么，怎么形成的？

https://www.cnblogs.com/Anker/p/3271773.html

* 孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。
* 僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。


## 7.进程调度方法详细介绍

https://blog.csdn.net/u011080472/article/details/51217754

https://blog.csdn.net/leex_brave/article/details/51638300

* 先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。
* 短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。
* 最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。
* 高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。
* 时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。
* 多级反馈队列(Multilevel Feedback Queue) 

## 8.进程的执行过程是什么样的，执行一个进程需要做哪些工作？

进程的执行需要经过三大步骤：编译，链接和装入。

* 编译：将源代码编译成若干模块
* 链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）
* 装入：将模块装入内存运行

https://blog.csdn.net/qq_38623623/article/details/78306498

将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。

通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。

## 9.什么时候用多进程，什么时候用多线程

https://blog.csdn.net/yu876876/article/details/82810178

* 频繁修改：需要频繁创建和销毁的优先使用**多线程**
* 计算量：需要大量计算的优先使用**多线程**  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点
* 相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。
* 多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。

但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。

## 10.多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）

https://blog.csdn.net/s_lisheng/article/details/74278765

* 临界区
* 信号量
* 事件
* 互斥量

### 10.1 如何避免僵尸进程?

- 通过`signal(SIGCHLD, SIG_IGN)`通知内核对子进程的结束不关心，由内核回收。如果不想让父进程 挂起，可以在父进程中加入一条语句:`signal(SIGCHLD,SIG_IGN)`;表示父进程忽略`SIGCHLD`信号， 该信号是子进程退出的时候向父进程发送的。 
- 父进程调用`wait/waitpid`等函数等待子进程结束，如果尚无子进程退出`wait`会导致父进程阻塞。 `waitpid`可以通过传递`WNOHANG`使父进程不阻塞立即返回。 
- 如果父进程很忙可以用`signal`注册信号处理函数，在信号处理函数调用`wait/waitpid`等待子进程退出。 通过两次调用`fork`。父进程首先调用`fork`创建一个子进程然后`waitpid`等待子进程退出，
- 子进程再 `fork`一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退 出所以孙进程成为一个孤儿进程，孤儿进程由`init`进程接管，孙进程结束后，`init`会等待回收。


第一种方法忽略`SIGCHLD`信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常`fork`很多子 进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核 把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。

《Linux系统下创建守护进程(Daemon)》:https://blog.csdn.net/linkedin_35878439/article/de tails/81288889

《01_fork()的使用》:https://blog.csdn.net/WUZHU2017/article/details/81636851


## 11.说一下PCB/说一下进程地址空间

https://blog.csdn.net/qq_38499859/article/details/80057427

PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。

PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息

![](./img/进程与线程02.png)

进程地址空间内有：

* 代码段text：存放程序的二进制代码
* 初始化的数据Data：已经初始化的变量和数据
* 未初始化的数据BSS：还没有初始化的数据
* 栈
* 堆
* 

## 12.在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？

https://blog.csdn.net/yusiguyuan/article/details/39496057

从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap

* brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小
* mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。

通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。

进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。

## 13.虚拟内存的了解

https://www.cnblogs.com/Przz/p/6876988.html

在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。

当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。

## 14.协程了解吗（高频）

协程和微线程是一个东西。

协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。
这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。

### 14.1 那协程的底层是怎么实现的，怎么使用协程？

协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。

## 15.死锁相关

死锁是指两个(多个)线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。

### 15.1、死锁产生原因

举个例子:两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2 加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然 后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也 无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。
理论上认为死锁产生有以下四个必要条件，缺一不可:

1. 互斥条件:进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。
2. 不剥夺条件:进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
3. 请求和保持条件:进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
4. 循环等待条件:存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。


### 15.2、死锁演示 通过代码的形式进行演示，需要两个线程和两个互斥量。

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <thread>
#include <mutex>  //引入互斥量头文件
using namespace std;

class A {
public:
	//插入消息，模拟消息不断产生
	void insertMsg() {
		for (int i = 0; i < 100; i++) {
			cout << "插入一条消息:" << i << endl;
			my_mutex1.lock(); //语句1
			my_mutex2.lock(); //语句2
			Msg.push_back(i);
			my_mutex2.unlock();
			my_mutex1.unlock();
		}
	}
	//读取消息
	void readMsg() {
		int MsgCom;
		for (int i = 0; i < 100; i++) {
			MsgCom = MsgLULProc(i);
			if (MsgLULProc(MsgCom)) {
				//读出消息了
				cout << "消息已读出" << MsgCom << endl;
			}
			else {
				//消息暂时为空
				cout << "消息为空" << endl;
			}
		}
	}
	//加解锁代码
	bool MsgLULProc(int &command) {
		int curMsg;
		my_mutex2.lock();   //语句3
		my_mutex1.lock();   //语句4
		if (!Msg.empty()) {
			//读取消息，读完删除
			command = Msg.front();
			Msg.pop_front();
			
			my_mutex1.unlock();
			my_mutex2.unlock();
			return true;
		}
		my_mutex1.unlock();
		my_mutex2.unlock();
		return false;
	}
private:
	std::list<int> Msg;  //消息变量
	std::mutex my_mutex1; //互斥量对象1
	std::mutex my_mutex2; //互斥量对象2
};

int main() {
	A a;
	//创建一个插入消息线程
	std::thread insertTd(&A::insertMsg, &a); //这里要传入引用保证是同一个对象
	//创建一个读取消息线程
	std::thread readTd(&A::readMsg, &a); //这里要传入引用保证是同一个对象
	insertTd.join();
	readTd.join();
	return 0;
}
```

语句1和语句2表示线程A先锁资源1，再锁资源2，语句3和语句4表示线程B先锁资源2再锁资源1，具备死锁产生的条件。


