
- [程序编译过程](#程序编译过程)
  - [hello world程序中有什么](#hello-world程序中有什么)
- [PC机的引导流程](#pc机的引导流程)
- [内核结构与设计](#内核结构与设计)
  - [硬件资源](#硬件资源)
  - [宏内核结构](#宏内核结构)
    - [宏内核提供内存分配功能的服务过程](#宏内核提供内存分配功能的服务过程)
  - [微内核结构](#微内核结构)
    - [微内核提供内存分配功能的服务过程](#微内核提供内存分配功能的服务过程)
  - [操作系统内核的分层](#操作系统内核的分层)

-------

## 程序编译过程

> 执行 `gcc HelloWorld.c -o HelloWorld` 的过程

其实，GCC 只是完成编译工作的驱动程序，它会根据编译流程分别调用**预处理程序**、**编译程序**、**汇编程序**、**链接程序**来完成具体工作。

下图就是编译这段代码的过程：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：

- `gcc HelloWorld.c -E -o HelloWorld.i` **预处理**：加入头文件，替换宏。将源文件生成**预处理文件**。
- `gcc HelloWorld.i -s -c HelloWorld.s` **编译**：预处理文件生成**编译文件**。
- `gcc HelloWorld.s -c HelloWorld.o` **汇编**：将编译文件生成**汇编文件**。
- `gcc HelloWorld.o -o HelloWorld` **链接**：汇编文件生成**可执行文件**


根据**冯诺依曼体系结构**构成的计算机，必须具有如下功能：

- 把程序和数据装入到计算机中；
- 必须具有长期记住程序、数据的中间结果及最终运算结果；
- 完成各种算术、逻辑运算和数据传送等数据加工处理；
- 根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；
- 能够按照要求将处理的数据结果显示给用户。

为了完成上述的功能，计算机必须具备五大基本组成部件：

- 装载数据和程序的 **输入设备**；
- 记住程序和数据的 **存储器**；
- 完成数据加工处理的 **运算器**；
- 控制程序执行的 **控制器**；
- 显示处理结果的 **输出设备**。

### hello world程序中有什么

通过执行`gcc -c -s hello.c` 得到汇编程序，然后通过命令 `objdump -d hello.o` 可以查看汇编代码。

```bash
$ objdump -d a.out

0000000000400526 <main>:
  400526:       55                      push   %rbp
  400527:       48 89 e5                mov    %rsp,%rbp
  40052a:       bf c4 05 40 00          mov    $0x4005c4,%edi
  40052f:       e8 cc fe ff ff          callq  400400 <puts@plt>
  400534:       b8 00 00 00 00          mov    $0x0,%eax
  400539:       5d                      pop    %rbp
  40053a:       c3                      retq   
  40053b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1) 
```

以上，分成四列：
- 第一列为地址；
- 第二列为十六进制，表示真正装入机器中的代码数据；
- 第三列是对应的汇编代码；
- 第四列是相关代码的注释。

这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集。

## PC机的引导流程

先借用一下 GRUB 引导程序，只要我们的 PC 机上安装了 Ubuntu Linux 操作系统，GRUB 就已经存在了。

那在写 Hello OS 之前，我们先要搞清楚 Hello OS 的引导流程，如下图所示：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/PC机引导过程.2tko93delqo0.jpg)

简单解释一下，PC 机 BIOS 固件是固化在 PC 机主板上的 ROM (只读存储器) 芯片中的，掉电也能保存，PC 机上电后的第一条指令就是 BIOS 固件中的，它**负责检测和初始化 CPU、内存及主板平台**，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到 `0x7c00` 地址开始的内存空间，再接着跳转到 `0x7c00` 处执行指令，在我们这里的情况下就是 GRUB 引导程序。

按下 PC 机电源开关开始，PC 机的引导过程。它从 CPU 上电，到加载 BIOS 固件，再由 BIOS 固件对计算机进行自检和默认的初始化，并加载 GRUB 引导程序，最后由 GRUB 加载具体的操作系统。

第一步，用汇编程序初始化 CPU 的寄存器、设置 CPU 的工作模式和栈，最重要的是加入了 GRUB 引导协议头；第二步，切换到 C 语言，用 C 语言写好了主函数和控制显卡输出的函数。

## 内核结构与设计

计算机中资源大致可以分为两类资源，一种是硬件资源，一种是软件资源。

### 硬件资源

1. 总线，负责连接各种其它设备，是其它设备工作的基础。
2. CPU，即中央处理器，负责执行程序和处理数据运算。
3. 内存，负责储存运行时的代码和数据。
4. 硬盘，负责长久储存用户文件数据
5. 网卡，负责计算机与计算机之间的通信。
6. 显卡，负责显示工作。
7. 各种 I/O 设备，如显示器，打印机，键盘，鼠标等。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/硬件结构.5sfuxlinpe80.jpeg)

### 宏内核结构

宏内核就是把诸如管理进程的代码、管理内存的代码、管理各种 I/O 设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码，把这些所有的代码经过编译，最后链接在一起，形成一个大的可执行程序。

这个大程序里有实现支持这些功能的所有代码，向用户应用软件提供一些接口，这些接口就是常说的系统 API 函数。而这个大程序会在处理器的特权模式下运行，这个模式通常被称为**宏内核模式**。

#### 宏内核提供内存分配功能的服务过程

1. 应用程序调用内存分配的 API（应用程序接口）函数。
2. 处理器切换到特权模式，开始运行内核代码。
3. 内核里的内存管理代码按照特定的算法，分配一块内存。
4. 把分配的内存块的首地址，返回给内存分配的 API 函数。
5. 内存分配的 API 函数返回，处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。

其实现在这种原始的宏内核结构已经没有人用了。这种宏内核唯一的优点是性能很好，因为在内核中，这些组件可以互相调用，性能极高。

### 微内核结构

微内核架构正好与宏内核架构相反，它提倡内核功能尽可能少：

微内核定义了一种良好的进程间通信的机制——**消息机制**。应用程序要请求相关服务，就向微内核发送一条与此服务对应的消息，微内核再把这条消息转发给相关的服务进程，接着服务进程会完成相关的服务。服务进程的编程模型就是循环处理来自其它进程的消息，完成相关的服务功能。

#### 微内核提供内存分配功能的服务过程

1. 应用程序发送内存分配的消息，这个发送消息的函数是微内核提供的，相当于系统 API，微内核的 API（应用程序接口）相当少，极端情况下仅需要两个，一个接收消息的 API 和一个发送消息的 API。
2. 处理器切换到特权模式，开始运行内核代码。
3. 微内核代码让当前进程停止运行，并根据消息包中的数据，确定消息发送给谁，分配内存的消息当然是发送给内存管理服务进程。
4. 内存管理服务进程收到消息，分配一块内存。
5. 内存管理服务进程，也会通过消息的形式返回分配内存块的地址给内核，然后继续等待下一条消息。
6. 微内核把包含内存块地址的消息返回给发送内存分配消息的应用程序。
7. 处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。

系统有良好的移植性，微内核代码量非常少，就算重写整个内核也不是难事。而且那些系统功能只是一个进程，可以随时拿掉一个服务进程以减少系统功能，或者增加几个服务进程以增强系统功能。

> **宏内核有极致的性能，微内核有极致的可移植性、可扩展性。还**

### 操作系统内核的分层

首先大致将我们的操作系统内核分为三个大层，分别是：
1. 内核接口层。
2. 内核功能层。
3. 内核硬件层。

- **内核接口层**，定义了一系列接口，主要有两点内容，如下

1. 定义了一套 UNIX 接口的子集，我们出于学习和研究的目的，使用 UNIX 接口的子集，优点之一是接口少，只有几个，并且这几个接口又能大致定义出操作系统的功能。

2. 这套接口的代码，就是检查其参数是否合法，如果参数有问题就返回相关的错误，接着调用下层完成功能的核心代码。

- **内核功能层**，主要完成各种实际功能，这些功能按照其类别可以分成各种模块，当然这些功能模块最终会用具体的算法、数据结构、代码去实现它，内核功能层的模块如下：

1. 进程管理，主要是实现进程的创建、销毁、调度进程，当然这要设计几套数据结构用于表示进程和组织进程，还要实现一个简单的进程调度算法。
2. 内存管理，在内核功能层中只有内存池管理，分两种内存池：页面内存池和任意大小的内存池。
3. 中断管理，这个在内核功能层中非常简单：就是把一个中断回调函数安插到相关的数据结构中，一旦发生相关的中断就会调用这个函数。
4. 设备管理，这个是最难的，需要用一系列的数据结构表示驱动程序模块、驱动程序本身、驱动程序创建的设备，最后把它们组织在一起，还要实现创建设备、销毁设备、访问设备的代码，这些代码最终会调用设备驱动程序，达到操作设备的目的。

- **内核硬件层**，主要包括一个具体硬件平台相关的代码，如下：

1. 初始化，初始化代码是内核被加载到内存中最先需要运行的代码，例如初始化少量的设备、CPU、内存、中断的控制、内核用于管理的数据结构等。
2. CPU 控制，提供 CPU 模式设定、开、关中断、读写 CPU 特定寄存器等功能的代码。
3. 中断处理，保存中断时机器的上下文，调用中断回调函数，操作中断控制器等。
4. 物理内存管理，提供分配、释放大块内存，内存空间映射，操作 MMU、Cache 等。
5. 平台其它相关的功能，有些硬件平台上有些特殊的功能，需要额外处理一下。

**API 接口以下的为内核空间，这才是设计、开发内核的重点**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/我们的内核结构.1tcm6veeokdc.jpeg)

我们的操作系统内核没有任何设备驱动程序，甚至没有文件系统和网络组件，内核所实现的功能很少。这吸取了**微内核**的优势，内核小出问题的可能性就少，扩展性就越强。

同时，我们把文件系统、网络组件、其它功能组件作为虚拟设备交由设备管理，比如需要文件系统时就写一个文件系统虚拟设备的驱动，完成文件系统的功能，需要网络时就开发一个网络虚拟设备的驱动，完成网络功能。

这些驱动一旦被装载，就是内核的一部分了，并不是像微内核一样作为服务进程运行。这又吸取了**宏内核**的优势，代码高度耦合，性能强劲

我们采取了两种内核架构的综合，组成了自己的内核结构。

