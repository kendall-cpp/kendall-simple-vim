## 并发和并行有什么区别

在单核CPU的某一个瞬间只会运行一个程序，但是一个期间内，就会运行很多个进程，它们之间的切换非常快，让人产生并行的错觉，实际上是并发执行的。


- **并发**就是一段时间内多个任务被处理，但是在同一个时刻，只有一个任务在执行
- **并行**就是在同一时刻，有多个任务在执行，这个需要多核 CPU 才能完成

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/并发并行.4yasajdkbdo0.png)

## 进程的基本状态以及它们的转化

- 就绪状态：其他资源准备好，只差`CPU`资源的状态就称为就绪状态，只要获得`CPU`的使用权，就可以独立运行。
- 执行状态：进程获得`CPU`资源，程序正在处理器上执行，在单处理机中(`1`核)，在某个时刻最多只能有一个进程正在执行
- 阻塞状态：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

当然，进程另外两个基本状态：

- 创建状态（new）：进程正在被创建时的状态；
- 结束状态（Exit）：进程正在从系统中消失时的状态；

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程的状态.7e6q9ri1vzc0.png)

当一个进程获取 CPU 时，就会**从就绪状态转成执行状态**，当一个进程被剥夺 `CPU` 时，比如系统分配的时间片被用完，或者出现优先级更高的进程，就会**由运行状态变成就绪状态**，当一个运行进程由于某事件被阻时，比如申请资源被占用、启动 I/O 传输未完成，状态就会由 **运行状态变成阻塞状态**，当所有的等待事件发生时，比如得到申请资源、I/O 参数完成，状态就由 **阻塞变成就绪**。

> - 实际上进程还有另外一个状态 ---- **挂起状态**
> 
> 因为如果大量的进程处于阻塞状态，可能会一直占用着物理内存，当然这不是我们希望的，毕竟物理内存是有限的，所以在虚拟内存管理的操作系统中，通常会把阻塞状态的物理内存空间切换到硬盘，等需要运行的时候再从硬盘中换回到物理内存。那么就需要一个新的状态来**描述有没有占用实际物理内存的情况，这个状态就是挂起状态**，这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。
>
> 另外，挂起状态可以分为两种：
>
>   1. 阻塞挂起状态：进程在硬盘中（外存），等待某个事件出现
>   2. 就绪挂起状态：进程在硬盘中（外存），但主要进入内存就会立即执行。

## 什么是程序控制块PCB

PCB 是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

PCB 还用于记录当前进程的状态和控制进程运行的全部信息

### 每个 PCB 是如何组织的呢

通常是通过**链表**的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

除了链接的组织方式，还有**索引方式**，它的工作原理：**将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。**

一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

## 进程的上下文切换

各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这样**一个进程切换到另一个进程运行，称为进程的上下文切换**。

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

通常，会把交换的信息保存在进程的 PCB，当正在运行另外一个进程的时候要切换到这个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程上下文.22teesvhcg5c.png)

> 但是需要注意的是，进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。

#### 内核空间与用户空间的区别

- 进程在用户态时，只能访问用户空间内存；
- 只有进入内核态后，才可以访问内核空间的内存；

虽然每个进程都各自有独立的虚拟内存，但是**每个虚拟内存中的内核地址，其实关联的都是相同的物理内存**。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。


### 发生进程上下文切换有哪些场景

- 当一个进程的**CPU 时间片用完**了的时候，这个进程就会由运行状态变成就绪状态，然后系统从就绪队列中选择另外一个进程运行。
- 当一个进程在**系统资源不足**，要等系统资源满足的时候才会被运行，这时候这个进程就会被挂起，然后调度其他进程先运行。
- 当一个进程通过**睡眠函数 `sleep` 主动挂起**的时候，自然也会进程调度，发生进程上下文切换。
- 当有**优先级更高的进程运行**时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- 发生**硬件中断**时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；

## 进程、线程、协程(区别)

- 进程: 直观的说，就是保存在硬盘中的程序在运行以后，那么这个运行起来的执行程序就是进程了。另外，操作系统会**以进程为单位**进行分配资源，比如说`CPU`时间片，内存等资源。**进程是资源分配的最小单位**。

- 刚刚说到系统运行一个可执行程序就是进程，那么线程就是这个执行程序的基本单位，也可以说是**轻量级的进程**，<font color=#268bd2> 线程是操作系统进行 CPU 调度的最小单位</font>。然后每个进程都有一个唯一的主线程，主线程和进程是相互依存的，主线程结束进程也会终止。

- 进程和线程属于包含关系，没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一个线程完成的，而是多个线程共同完成的；线程是进程的一部分。另外线程可以共享它对应进程的系统资源。

- 在系统开销方面，每个进程都有独立的代码和数据空间（也就是程序的上下文），进程之间的切换会有较大的开销，因为涉及到系统的资源分配；线程因为是轻量级的进程，所以线程的切换开销小很多。而且同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

- 协程：**协程是一种用户态的轻量级线程**，协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程在调度切换的时候，将寄存器上下文保存在其他地方，在需要切换回来的时候恢复之前保存的寄存器上下文和栈，这种直接去操作栈而不是不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。

## 线程上下文切换的是什么

这还得看线程是不是属于同一个进程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；

所以，线程的上下文切换相比进程，开销要小很多。

## 线程的实现

主要有三种线程的实现方式：

- 用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
- 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；
- 轻量级进程（LightWeight Process）：在内核中来支持用户线程；
  
> - 用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。
> 
>   所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。

> - 内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。


### 用户线程和内核线程的对应关系

首先，第一种关系是多对一的关系，也就是多个用户线程对应同一个内核线程：

第二种是一对一的关系，也就是一个用户线程对应一个内核线程：

第三种是多对多的关系，也就是多个用户线程对应到多个内核线程：

## 进程的调度时机

<u>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。</u>

当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。

有两种调度的方式，分别是「**非抢占式调度**」和「**抢占式调度**」

<u>**非抢占式**的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</u>

<u>而**抢占式调度**，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</u>

常见的调度算法：

- 先来先服务调度算法
- 最短作业优先调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 最高优先级调度算法
- 多级反馈队列调度算法

### 进程调度算法

#### 先来先服务调度算法

最简单的一个调度算法，就是非抢占式的**先来先服务**（First Come First Severd, FCFS）算法了

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程调度算法01.4s2hgfyszfy0.png)

每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择另一个进程接着运行。

这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。

所以，先来先服务调度算法有利于长作业运行，但是不利于短作业运行，

FCFS 对长作业有利，**适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统**。

#### 最短作业优先调度算法

**最短作业优先**（Shortest Job First, SJF）调度算法同样也是顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程调度算法02.1uorjth62fmo.png)

这显然对长作业不利，很容易造成一种极端现象。

比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。

#### 高响应比优先调度算法

前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。

那么，**高响应比优先**
（Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。

每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：

$$\frac{等待时间+要求服务时间}{要求服务时间}$$

从上面的公式，可以发现：

- 如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；
- 如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；

#### 时间片轮转调度算法

最古老、最简单、最公平且使用最广的算法就是时间片轮转（Round Robin, RR）调度算法。
。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程调度算法03.4144eayz4ns0.png)

每个进程被分配一个时间段，称为时间片（Quantum），也就是允许该进程在该时间段中运行。

如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；

如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；
另外，时间片的长度就是一个很关键的点：

如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；

如果设得太长又可能引起对短作业进程的响应时间变长。

通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。

#### 最高优先级调度算法

前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。

但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。

进程的优先级可以分为，**静态优先级**或**动态优先级**：

- **静态优先级**：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
- **动态优先级**：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。
  
该算法也有两种处理优先级高的方法，非抢占式和抢占式：

- 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
- 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

但是依然有缺点，可能会导致低优先级的进程永远不会运行。

#### 多级反馈队列调度算法

多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。

顾名思义：

- 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
- 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/进程调度算法04.5dtdedpqbhw0.png)

来看看，它是如何工作的：

设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；

新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；

当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。

------

## 进程间通信

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。

- **管道**

比如说在Linux终端敲下命令

```bash
ps -ef | grep bash
```

上面命令行里的「`|`」竖线就是一个管道，它的功能是将前一个命令（`ps -ef`）的输出，作为后一个命令（`grep bash`）的输入，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。


同时，我们得知上面这种管道是没有名字，所以「`|`」表示的管道称为**匿名管道**，用完了就销毁。

管道还有另外一个类型是**命名管道**，也被叫做 `FIFO`，因为数据是先进先出的传输方式。

在使用命名管道前，先需要通过 `mkfifo` 命令来创建，并且指定管道名字：

```bash
$ mkfifo myPipe
```

`myPipe` 就是这个管道的名称，基于 `Linux` 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 `ls` 看一下，这个文件的类型是 `p`，也就是 `pipe`（管道） 的意思：

```
prw-r--r--   1 kendy  staff      0  4 19 12:16 myPipe
```

-----

- **消息队列**

<u>管道的通信方式效率是很低的，因此管道不适合进程间频繁地交换数据。</u>

<u>对于这个问题，消息队列模式可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去消息队列读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</u>

再来，<u>**消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），</u>消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以<u>每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</u>

消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。

消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。

但邮件的通信方式存在不足的地方有两点，一是通信不及时，二是附件也有大小限制，这同样也是消息队列通信不足的点。

<u>**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。</u>在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。

<U>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</U>

----
- **共享内存**

<u>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这一问题。</U>

现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。

<u>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</U>

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/共享内存.39h8pfoxm8g0.png)

----

- **信号量**

用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

为了防止多进程竞争共享资源，而造成的数据错乱，信号量就是实现一个保护机制，使得共享的资源在任何时刻只能被一个进程访问。

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，**

信号量有两种原子操作
  -  P 操作
  -  V 操作

----
- **信号**

上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。


在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 `kill -l` 命令，查看所有的信号：

```bash
$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL
 2) SIGTRAP	 6) SIGABRT	 7) SIGEMT	 8) SIGFPE
 3) SIGKILL	10) SIGBUS	11) SIGSEGV	12) SIGSYS
1)  SIGPIPE	14) SIGALRM	15) SIGTERM	16) SIGURG
2)  SIGSTOP	18) SIGTSTP	19) SIGCONT	20) SIGCHLD
3)  SIGTTIN	22) SIGTTOU	23) SIGIO	24) SIGXCPU
4)  SIGXFSZ	26) SIGVTALRM	27) SIGPROF	28) SIGWINCH
5)  SIGINFO	30) SIGUSR1	31) SIGUSR2	
```

信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生。用户进程就可以对信号进行处理。

- **Socket**

前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信**，就需要 Socket 通信了。

实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

创建 socket 的系统调用：

```cpp
int socket(int domain, int type, int protocal)
```

----
----

### 管道的创建与原理

匿名管道的创建，需要通过下面这个系统调用：
```cpp
int pipe(int fd[2])
```

这里表示创建一个匿名管道，并返回了**两个描述符**，一个是管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`。注意，这个匿名管道是特殊的文件，**只存在于内存，不存于文件系统中**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/管道01.4a64wuvff780.png)

其实，所谓的管道，就是内核里面的一串缓存。从管道的一端写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，**管道传输的数据是无格式的流且大小受限**。

### 那么管道是怎么实现跨越两个进程通讯的呢

我们可以使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个「 `fd[0]` 与 `fd[1]`」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。

管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：

- 父进程关闭读取的 `fd[0]`，只保留写入的 `fd[1]`；
- 子进程关闭写入的 `fd[1]`，只保留读取的 `fd[0]`；

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/管道02.5l8wczaemy80.png)

所以说如果需要双向通信，则应该创建两个管道。

到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。

在 `shell` 里面执行 `A | B`命令的时候，A 进程和 B 进程都是 `shell` 创建出来的子进程，`A` 和 `B` 之间不存在父子关系，它俩的父进程都是 `shell`。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/管道03.3prebw44s740.png)


所以说，在 `shell` 里通过「`|`」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 `shell` 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。

我们可以得知，对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过 `fork` 来复制父进程 `fd` 文件描述符，来达到通信的目的。

另外，对于**命名管道**，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。

不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 `lseek` 之类的文件定位操作。

> 怎么说：      
> - 管道分为匿名管道和有名管道，比如说在`shell`里面执行 `A | B`这里的`|`就是匿名管道，它是存在内存中的，并不是存在文件系统中的。然后匿名管道就单向的，它是通过`int pipe(int fd[2])`这个系统调用实现的，返回的是两个描述符，第一个是读文件描述符，第二个是写文件描述符。       
> - 那么管道是怎么实现跨越两个进程通讯的呢        
> 我们可以使用 `fork` 创建子进程，创建的子进程会复制父进程的文件描述符，两个进程就可以通过各自的 `fd` 写入和读取同一个管道文件实现跨进程通信了。
> - 对于**命名管道**，它可以在不相关的进程间也能相互通信。因为命令管道，提前通过`mkfifo myPipe`创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。
> - 不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 `lseek` 之类的文件定位操作。

### 信号量的两种原子操作

信号量表示资源的数量，控制信号量的方式有两种原子操作：

- 一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
- 另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/信号量01.674t2zu9m040.png)

具体的过程如下：

进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。
若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。
直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。
可以发现，信号初始化为 1，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。

另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。

例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。

那么这时候，就可以用**信号量来实现多进程同步的方式**，我们可以初始化信号量为 0。
 
![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/信号量02.14intk7e6wxs.png)

具体过程：

- 如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；
- 接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；
- 最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。

可以发现，信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。


----

## 多线程和多线程的应用

同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量`int i = 10`，这一进程中所有并发运行的线程都可以读取和修改这个`i`的值，而多个线程被`CPU`调度的顺序又是不可控的，所以对临界资源的访问需要注意安全。

我们必须知道，**做一次简单的`i = i + 1`在计算机中并不是原子操作，会首先从内存中取出`i`值后，放入寄存器，然后对寄存器中的`i`值`+1`,最后把寄存器中的`i`值放回内存**，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

> 汇编指令的执行顺序

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/汇编指令执行顺序.rqmyoks7ljk.png)

> 从上图可以发现，只是单纯给 i 加上数字 1，在 CPU 运行的时候，实际上要执行 3 条指令。



但是，虽然多线程存在一些线程安全问题，但是线程也带来的很多好处。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。

比如 `QQ` 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果只有一个线程线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。

另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的`tid`，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。

而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和程序计数器`PC`即可，相比进程切换开销要小很多。

### 什么时候用多进程，什么时候用多线程

https://blog.csdn.net/yu876876/article/details/82810178

* 频繁修改：需要频繁创建和销毁的优先使用**多线程**
* 计算量：需要大量计算的优先使用**多线程**  因为需要消耗大量`CPU`资源且切换频繁，所以多线程好一点
* 相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用**多进程**。因为线程之间的数据共享和同步比较简单。
* 多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。

但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。

## 进程_线程的互斥与同步的实现和使用

在进程/线程并发执行的过程中，进程/线程之间存在协作的关系，例如有互斥、同步的关系。

为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：

- 锁：加锁、解锁操作；
- 信号量：P、V 操作；

这两个都可以方便地实现进程/线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程/线程同步。

### 进程同步方式

信号量和管程机制

* **信号量**：信号量可以说是类似一个计数器，它控制的是多个进程对一个共享资源的访问，就是说这个资源最多能被多少个进程进行访问。[见上面进程间通信的信号量的PV操作初始化为0的时候就实现了进程间同步](#信号量的两种原子操作)

* **管程**: 信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是**将共享变量和对它们的操作集中在一个模块中**，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，可以保证正确性。 

* **优缺点**： 

  * 1）信号量（Semaphore）及PV操作
  
   优：PV操作能够实现对临界区的管理要求；实现简单；允许使用它的代码休眠，持有锁的时间可相对较长。 

   缺：信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点。信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。加重了程序员的编码负担；核心操作P-V分散在各用户程序的代码中，不易控制和管理；一旦错误，后果严重，且不易发现和纠正。 

  * 管程
  
   优： 集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 

   缺：如果一个分布式系统具有多个CPU，并且每个CPU拥有自己的私有内存，它们通过一个局域网相连，那么这些原语将失效。而管程在少数几种编程语言之外又无法使用，并且，这些原语均未提供机器间的信息交换方法。 

### 线程同步的方式

实现线程间同步的方法：

**互斥量，自旋锁，读写锁，条件变量**

- **互斥量**：比如说有两个线程，线程1和线程2，分别充当生产者与消费者的角色，那么这两个线程就很有可能同时去操作临界资源，如果同时去操作临界资源的话就会引起线程同步问题，互斥量的话就是来解决这个问题，当一个线程，比如说线程1在操作临界资源的时候，它就会阻止另外的线程去访问这个临界资源。其实引发线程同步问题的最根本原因是**这两个线程的指令是交叉执行的**，互斥量能够保证指令执行的原子性，也就是说先执行完线程1的指令再执行线程2的指令，或者先执行完线程2的指令再执行线程1的指令。保证他们之间不会出现交叉执行的情况。互斥量也称为互斥锁，它要么处于加锁状态要么处于解锁状态。保证资源访问的串行。操作系统提供的API是`pthread_mutex_t`。

- **自旋锁**：其实自旋锁和互斥锁的原理是一样的，都是在使用临界资源之前加一个锁，阻止其他线程对它进行访问，完成之后再把锁给释放掉，保证临界资源的串行访问。但是它和互斥锁还是存在差别的，使用自旋锁的线程会一直循环反复检查锁的变量是否可用，因此**它不会让出CPU**，会处于忙等待的状态。其实自旋锁还是有很多好处的，它避免了进程或者线程上下文切换的开销，如果锁使用的时间不是很长的话，使用自旋锁的代价也是很小的，同时在操作系统内部很多地方使用的是自旋锁而不是互斥量的。这里还要提一点就是**自旋锁不适合在单核`CPU`中使用**。因为自旋锁在等待的时候并不会释放`CPU`，而是死循环地去等待。会引起其他的进程或者线程无法去执行。操作系统提供的API是`pthread_spinock_t`。

- **读写锁**: 读写锁和互斥锁还有自旋锁是类似的，但是做了一些改进，基于临界资源的考量，因为在开发环境中，临界资源很可能会出现多读少写的特性，就比如有一个数据库存储的是历史订单信息，而这些订单我们一般只是去查询很少去改变它，这个存储历史订单的数据库就属于多读少写的临界资源，如果在读写的时候也给它加锁，这样的话效率会很低的。读写锁的话是一种特殊的自旋锁，**它允许多个读者同时读取临界资源，但是不允许多个写操作同时访问这个资源**。在操作系统中提供的API是`thread_rwlock_t`，读锁是通过`thread_rwlock_rdlock`来加的，写锁是通过`thread_rwlock_wdlock`来加的.


- **条件变量**：条件变量是一种先对复杂的线程同步方法，它允许线程睡眠，在满足一定条件的时候再唤醒线程，就是当满足条件时，可以向这个线程发送信号，唤醒这个线程。因为在生产者和消费者模型中是存在问题的，举个例子，比如当缓冲区小于或者等于0时，这时候应该不允许消费者继续消费，消费者必须等待，当缓冲区满的时候，这个时候应该不允许生产者往里面生成数据了，生产者必须处于等待状态。条件变量呢就是对这个问题进行了约束，当缓冲区为0的时候，如果有生产者生产一个产品，那么就要唤醒可能等待的消费者；当缓冲区满的时候，如果有消费者消费了产品，就需要唤醒其他可能在等待的生产者。操作系统提供的`API`是`pthread_cont_t`来定义的,等待是通过`pthread_cont_wait`定义的，,唤醒是通过`pthread_cont_notify`定义的。

### 经典同步问题

#### 哲学家就餐问题

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/哲学家问题.2n2iy1dghiq0.png)

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。



```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}

void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {         
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}

```

#### 读者写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

即：读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。

一个整型变量 `count` 记录在对数据进行读操作的进程数量，一个互斥量 `count_mutex` 用于对 `count` 加锁，一个互斥量 `data_mutex` 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);//最后一个读者要对数据进行解锁，防止写进程无法访问
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

### 怎么回收线程？有哪几种方法？

- **等待线程结束**：`int pthread_join(pthread_t tid, void** retval);`

  主线程调用，等待子线程退出并回收其资源，类似于进程中`wait/waitpid`回收僵尸进程，调用`pthread_join`的线程会被阻塞。

  - `tid`：创建线程时通过指针得到tid值。

  - `retval`：指向返回值的指针。

- **结束线程**：`pthread_exit(void *retval);`

  子线程执行，用来结束当前线程并通过`retval`传递返回值，该返回值可通过`pthread_join`获得。

  - `retval`：同上。

- **分离线程**：`int pthread_detach(pthread_t tid);`

  主线程、子线程均可调用。主线程中`pthread_detach(tid)`，子线程中`pthread_detach(pthread_self())`，调用后和主线程分离，子线程结束时自己立即回收资源。

  - `tid`：同上。

----

## Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关

理论上，一个进程可用虚拟空间是`2G`，默认情况下，线程的栈的大小是`1MB`，所以理论上最多只能创建`2048`个线程。如果要创建多于`2048`的话，必须修改编译器的设置。

因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过`2K`以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。



## 守护进程、僵尸进程和孤儿进程

### 守护进程

指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。`Linux`的大多数服务器就是用守护进程的方式实现的，如`web`服务器进程`http`等

创建守护进程要点：

（1）**让程序在后台执行**。方法是调用`fork()`产生一个子进程，然后使父进程退出。

（2）**调用`setsid()`创建一个新会话**。因为控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用`setsid()`使子进程成为一个会话组长。`setsid()`调用成功后，子进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。

（3）**禁止进程重新打开控制终端**。经过以上步骤，子进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过`fork()`创建新的子进程，使调用`fork`的进程退出。

（4）**关闭不再需要的文件描述符**。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭从`0`到最高文件描述符值的所有文件描述符。

（5）**将当前目录更改为根目录**。

（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，**使用`unmask(0)`将屏蔽字清零**。

（7）**处理信号**，因为对于服务器来说，一个请求到来的时候一般是先生成一个子进程请求，如果子进程等待父进程捕获状态的话，那么子进程就会成为一个僵尸进程，占用系统资源，那么父进程等待子进程结束的话就会增加父进程的负担，从而影响服务器的并发性能。所以在`Linux`下可以简单地将`SIGCHLD`信号的操作设为`SIG_IGN`。这样，子进程结束时不会产生僵尸进程。

### 孤儿进程

如果父进程先退出，子进程还没退出，那么子进程的父进程将变为`init`进程。（注：任何一个进程都必须有父进程）。

 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被`init`进程(进程号为1)所收养，并由`init`进程对它们完成状态收集工作。 

### 僵尸进程

如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。

设置**僵尸进程的目的**是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用`wait`或`waitpid`时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程`ID`将被重置为`1`（init进程）。继承这些子进程的`init`进程将清理它们（也就是说`init`进程将`wait`它们，从而去除它们的僵尸状态）。

### 孤儿进程和僵尸进程分别是什么，怎么形成的？

https://www.cnblogs.com/Anker/p/3271773.html

* 孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被`init`进程收养并完成状态收集。
* 僵尸进程是指子进程完成并退出后父进程没有使用`wait()`或者`waitpid()`对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。

### 如何避免僵尸进程？

- 通过`signal`(SIGCHLD, SIG_IGN)通知内核回收子进程。如果不想让父进程挂起，可以在父进程中加入一条语句：`signal`(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。

- 父进程调用`wait/waitpid`等函数等待子进程结束，如果尚无子进程退出`wait`会导致父进程阻塞。`waitpid`可以通过传递`WNOHANG`使父进程不阻塞立即返回。

- 如果父进程很忙可以用`signal`注册信号处理函数，在信号处理函数调用`wait/waitpid`等待子进程退出。

- 通过两次调用`fork`。父进程首先调用`fork`创建一个子进程然后`waitpid`等待子进程退出，子进程再`fork`一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由`init`进程接管，孙进程结束后，`init`会等待回收。

第一种方法忽略`SIGCHLD`信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常`fork`很多子进程，子进程终结之后需要服务器进程去`wait`清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给`init`进程去处理，省去了大量僵尸进程占用系统资源。

> 《Linux系统下创建守护进程(Daemon)》：https://blog.csdn.net/linkedin_35878439/article/details/81288889

> 《01_fork()的使用》：https://blog.csdn.net/WUZHU2017/article/details/81636851

## 用户态和内核态的区别

内核态与用户态是操作系统的两种运行级别,当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。

**这两种状态的主要差别是**： 

（1）处于**用户态**执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是**可被抢占**的 ； 

（2）而处于**核心态**执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是**不允许被抢占**的。

通常来说，以下三种情况会导致用户态到内核态的切换：

1）系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如使用`fork()`实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

2）异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

3）外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。


------ 

