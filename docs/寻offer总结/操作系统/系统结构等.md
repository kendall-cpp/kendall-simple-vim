

## 冯诺依曼模型

冯诺依曼“约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出设备、总线。

中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据:
- 32 位 CPU 一次可以计算 4 个字节;
- 64 位 CPU 一次可以计算 8 个字节;

CPU 内部还有一些组件，常⻅的有**寄存器**、**控制单元**和**逻辑运算单元**等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。

### 常⻅的寄存器种类

- 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。 
- 程序计数器，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。
- 指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储
  在这里。

### 总线

总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种:

- 地址总线，用于指定 CPU 将要操作的内存地址; 
- 数据总线，用于读写内存的数据;
- 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线;

当 CPU 要读写内存数据的时候，一般需要通过两个总线: 

- 首先要通过「地址总线」来指定内存的地址;
- 再通过「数据总线」来传输数据;

## 程序执行的基本过程


程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。

- 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」
- 第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把 指令交给「逻辑运算单元」运算;如果是存储类型的指令，则交由「控制单元」执行;
- 第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数 器」的值会自增 4;

> 简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令⻓度自增，开始顺序读取下一条指令。
>
> CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个 不断循环的过程被称为 CPU 的指令周期。


-----

## 虚拟内存

**虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。**

如果`CPU`直接去操作操作系统的内存，也就是物理内存，在这种情况下，要想在内存中同时运行多个程序是不可能的，就比如 如果一个程序要向在`002`这个位置上写入一个新的值，那么就会覆盖掉上一个程序在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

操作系统为每一个进程分配一套独立的**虚拟地址**，各个程序操作自己的地址，互不干涉，但是有个前提就是每个进程不能直接访问物理地址。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚拟内存01.if9p8l54eag.png)

操作系统就是提供一种这样的机制，**将不同进程的虚拟地址和不同内存的物理地址映射起来。**

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。


> - 我们程序所使用的内存地址叫做**虚拟内存地址**（Virtual Memory Address）
> - 实际存在硬件里面的空间地址叫**物理内存地址**（Physical Memory Address）。


操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，


## 操作系统如何管理虚拟地址与物理地址(内存分段与内存分页)

主要有两种方式，分别是**内存分段**和**内存分页**

- **内存分段**

程序是由若干个逻辑分段组成的，比如有 代码分段、数据分段、栈段、堆段。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来**。



分段的好处就是能产生连续的内存空间，但是会出现**内存碎片**和**内存交换的空间太大**的问题。

要解决这些问题，就有了**内存分页**（Paging）。

分页是**把整个虚拟内存和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（`Page`）。在 `Linux` 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过**页表**来映射，如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页01.2waeymf4hwk.png)

页表实际上存储在 `CPU` 的内存管理单元（`MMU`） 中，于是 `CPU` 就可以直接通过 `MMU`，找出要实际要访问的物理内存地址。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

