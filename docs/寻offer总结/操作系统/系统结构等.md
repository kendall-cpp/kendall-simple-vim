

## 冯诺依曼模型

冯诺依曼“约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出设备、总线。

中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据:
- 32 位 CPU 一次可以计算 4 个字节;
- 64 位 CPU 一次可以计算 8 个字节;

CPU 内部还有一些组件，常⻅的有**寄存器**、**控制单元**和**逻辑运算单元**等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。

### 常⻅的寄存器种类

- 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。 
- 程序计数器，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。
- 指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储
  在这里。

### 总线

总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种:

- 地址总线，用于指定 CPU 将要操作的内存地址; 
- 数据总线，用于读写内存的数据;
- 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线;

当 CPU 要读写内存数据的时候，一般需要通过两个总线: 

- 首先要通过「地址总线」来指定内存的地址;
- 再通过「数据总线」来传输数据;

## 程序执行的基本过程


程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。

- 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」
- 第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把 指令交给「逻辑运算单元」运算;如果是存储类型的指令，则交由「控制单元」执行;
- 第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数 器」的值会自增 4;

> 简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令⻓度自增，开始顺序读取下一条指令。
>
> CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个 不断循环的过程被称为 CPU 的指令周期。


-----

## 虚拟内存

**虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。**

如果`CPU`直接去操作操作系统的内存，也就是物理内存，在这种情况下，要想在内存中同时运行多个程序是不可能的，就比如 如果一个程序要向在`002`这个位置上写入一个新的值，那么就会覆盖掉上一个程序在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

操作系统为每一个进程分配一套独立的**虚拟地址**，各个程序操作自己的地址，互不干涉，但是有个前提就是每个进程不能直接访问物理地址。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚拟内存01.if9p8l54eag.png)

操作系统就是提供一种这样的机制，**将不同进程的虚拟地址和不同内存的物理地址映射起来。**

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。


> - 我们程序所使用的内存地址叫做**虚拟内存地址**（Virtual Memory Address）
> - 实际存在硬件里面的空间地址叫**物理内存地址**（Physical Memory Address）。


操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，


## 操作系统如何管理虚拟地址与物理地址(内存分段与内存分页)

主要有两种方式，分别是**内存分段**和**内存分页**

- <font color="orange" font-weight=bolder size = 4>内存分段</font>

程序是由若干个逻辑分段组成的，比如有 代码分段、数据分段、栈段、堆段。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来**。


- <font color="orange" font-weight=bolder size = 4>内存分页</font>

分段的好处就是能产生连续的内存空间，但是会出现**内存碎片**和**内存交换的空间太大**的问题。

要解决这些问题，就有了**内存分页**（Paging）。

分页是**把整个虚拟内存和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（`Page`）。在 `Linux` 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过**页表**来映射，如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页01.2waeymf4hwk.png)

页表实际上存储在 `CPU` 的内存管理单元（`MMU`） 中，于是 `CPU` 就可以直接通过 `MMU`，找出要实际要访问的物理内存地址。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

## 分段机制下，虚拟地址和物理地址是如何映射的

分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分段01.1hsltcfttpa8.png)

- **段选择因子**就保存在段寄存器里面。段选择因子里面最重要的是**段号**，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等

- 虚拟地址中的**段内偏移量**应该位于 `0` 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：

- 第一个就是内存碎片的问题。
- 第二个就是内存交换的效率低的问题。

## 分段为什么会产生内存碎片的问题？

举个例子，假设有 `1G` 的物理内存，用户执行了多个程序，其中：

- 游戏占用了 512MB 内存
- 浏览器占用了 128MB 内存
- 音乐占用了 256 MB 内存。

这个时候，如果我们关闭了浏览器，则空闲内存还有 `1024 - 512 - 256 = 256MB`。

如果这个 `256MB` 不是连续的，被分成了两段 `128 MB` 内存，这就会导致没有空间再打开一个 `200MB` 的程序。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分段03.4ukry7t7qgs0.png)

这里的内存碎片的问题共有两个地方：

- 外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；
- 内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；

### 使用内存交换解决外部内存碎片

可以把音乐所占用的不连续的内存写到磁盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 `512MB` 内存后面。这样就能空缺出连续的 `256MB` 空间，于是新的 `200MB` 程序就可以装载进来。

### 分段为什么会导致内存交换效率低的问题

对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。

因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。

为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。


## 分页是怎么解决分段的内存碎片、内存交换效率低的问题

由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而**采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。**

如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。

## 分页机制下，虚拟地址和物理地址是如何映射的？

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号就是页表的索引，页表中的物理页号字段保存着每一页的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页03.3v4z7vjlwdc0.png)

对于一个内存地址转换，其实就是这样三个步骤：

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

**虚拟内存中的页通过页表映射为物理内存中的页**，如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页04.2auvuajdvge8.png)


### 简单的分页有什么缺陷吗？

**有空间上的缺陷**。

因为操作系统是可以同时运行非常多的进程的，这样的话就会导致页表非常大。

就比如在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。

那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。
