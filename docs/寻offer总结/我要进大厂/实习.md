
- [Hobot-SDK-<font color="orange">实习项目</font>](#hobot-sdk-font-colororange实习项目font)
- [静态变量](#静态变量)
  - [怎么使用静态变量](#怎么使用静态变量)
  - [为什么使用宏函数](#为什么使用宏函数)
  - [detach 函数](#detach-函数)
    - [使用 detach 时候需要注意什么问题(线程安全问题)](#使用-detach-时候需要注意什么问题线程安全问题)
  - [怎么进行测试](#怎么进行测试)
  - [说一下`C++` 的智能指针](#说一下c-的智能指针)
    - [RAII 是什么](#raii-是什么)
- [什么是 RTTI](#什么是-rtti)
  - [dynamic_cast 运算符](#dynamic_cast-运算符)
  - [typeid 运算符](#typeid-运算符)
- [H264 视频编码](#h264-视频编码)
  - [帧内预测编码的基本原理](#帧内预测编码的基本原理)
  - [为什么要有帧内预测](#为什么要有帧内预测)
    - [4×4 的亮度分量预测](#44-的亮度分量预测)
    - [16×16的亮度分量预测](#1616的亮度分量预测)
  - [帧内预测编码的预测实现方法](#帧内预测编码的预测实现方法)

----

## Hobot-SDK-<font color="orange">实习项目</font>

Hobot Framework 提供了一个通过有向图的形式, 将基础代码功能模块组织成较复杂功能模块的机制。

基于 Hobot Framework, 所有的基础的功能以 `Module` 的形式提供; 功能之间的数据交换以 `Message` 为单位。

一个 `Module` 由多个 `Forward{n}` 组成，其中 `Forward{n}` 又可以以一个或多个别的 `Module::Forward{n}` 产生的 `Message` 为输入, 可以输出自己的 `Message`。

这样, 基础功能的开发者可以将自己的基础功能封装成一个 包含多个 `Forward` 的 `Module`, 并说明自己的输入输出;

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/concept.2nnp25ds1lu0.png)

## 静态变量

- 函数内部定义一个局部对象时，使用 static 关键字时，这个变量就保存在静态存储区，在编译的时候初始化，如果不给初始化值，它的值就会被初始化为 0，并且，下次调用这个函数的时候该变量中保存的值就是上一次函数调用结束时的值

- 在全局变量时使用 static 关键字，那么这个全局变量只能在本文件中使用，无法在其他文件中被引用。

- 在函数之前加 static 时，那么函数只能在本源程序文件中调用，无法在其他源程序文件中调用。

- 在一个类中定义 static 成员，那么这个成员不属于某个对象，而是属于整个类。

> 编译阶段初始化，全局变量，函数，对象

### 怎么使用静态变量

在实现测试用例的自动保存的时候，会用一个宏函数 [`GTEST_TEST_CLASS_NAME_`]，这个宏函数里面有一个静态变量 test_info_ ，它利用”静态变量在程序运行前被初始化“的特性，抢在 main 函数执行之前，执行一段代码，从而有机会将测试用例放置于一个固定的位置。这个是”自动“保存测试用例的本质所在。

然后就是 test_info_ 的初始化的时候会插入一个模板类，这个模板类是一个 工厂类 ，类继承于 TestFactoryBase，并重载了 CreateTest 方法，主要的作用是 new 出一个 TestInfo 类对象，并实现一个 AddTestInfo 方法，将其测试用例保存起来。

在 AddTestInfo 中是通过 测试用例名 等信息获取测试用例，然后调用测试用例对象去新增一个测试特例—— test_info 

测试用例的保存使用一个 vetor 容器来保存

### 为什么使用宏函数

> 主要是 利用空间换时间的思想吧

普通函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了时间。大家都知道的是，函数调用是要使用系统的栈来保存数据的，*如果编译器里有栈检查选项，一般在函数的头会嵌入一些汇编语句对当前栈进行检查；同时，CPU 也要在函数调用时保存和恢复当前的现场，* 会涉及进行压栈和弹栈操作，所以，函数调用需要一些 CPU 时间。 而宏函数不存在这个问题。

宏在编译之前进行,也就是先用宏体替换宏名,然后再编译的,而函数显然是编译之后,在执行时,才调用的.因此,宏占用的是编译的时间,而函数占用的是执行时的时间.

宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，因为在进行单元测试的时候会频繁调用同一个宏函数，所以这样效率会高很多。

> 在使用 detach 分离父进程和子进程，会导致线程安全问题，当时使用的是 临时对象的方式解决的。

### detach 函数

如果创建了很多子线程，让主线程逐个等待子线程结束，这种方法就显得不是很好，所以需要引入 detach 这种写法，**让主线程和子线程分离**，主线程不必等待子进程运行结束。

```cpp
mytoobj.detach();
```
> 一旦调用了 detach，就不可再调用 join 了。当然可以使用 joinable 判断是否成功使用 join 或者 detach 。

但是使用 detach 时候会导致内存安全问题，就比如在线程中传递引用，指针之类的参数，这样的话形参的地址是原来主线程中分配的，一旦主线程退出后，子线程再使用这块内存肯定是不安全的。

所以需要使用值传递，在创建线程这一行就构造出 **临时对象**，主要用这个临时构造的对象传递给线程入口函数，那么线程中的到的第二个参数就一定能够在主线程执行完毕之前构造出来。从而确保 detach 线程是安全的。

#### 使用 detach 时候需要注意什么问题(线程安全问题)

- 不要往线程中传递引用，指针之类的参数
- 建议使用值传递，建议在创建线程这一行就构造出临时对象，然后线程入口函数的形参**使用引用**来作为形参。 


```cpp
//不能这样使用
void myprint(const int& i,const string& pmybuf) {...}

//main()中
std::thread mytojob(myprint,mvar,mybuf);
mytojob.detach();

//使用类
std::thread mytojob(myprint,mvar,A(myobj));
```

C++ 语言只会为 const 引用临时对象，第一个参数不建议使用引用，因为 主线程可能先执行结束被回收了，导致 mvar 变量被回收。

第二个参数系统内部隐式将 char 数组转成 string 对象，但是这个转换时机可能发生在 主线程 执行结束后，这时候 mybuf 被系统回收了。

更改：
```
std::thread mytojob(myprint,mvar,string(mybuf));
```

直接将 mybuf 转换成 string 对象，`string(mybuf))`会生成一个临时对象，并将这个临时对象绑定到  pmybuf ，因此可以保证 pmybuf 肯定是有效的。

> 给线程入口函数传递类型对象时，只要使用临时对象作为实参，就可以确保线程入口函数的形参在 main 主函数退出前就已经创建完毕，可以保证线程安全。


### 怎么进行测试

我们建立一个 `class A`，如果直接在在形参中写 `A(mysecondpar)` ;这个对象是由 主线程传入的时候构造出来的，那么就可以出现主线程先结束的时候，就不能再构造了。

那么在给线程入口函数传递类型对象形参时，传在主线程中构造一个临时对象`A(mysecondpar)` ，就可以保证线程入口函数的形参在 主线程 函数退出前就已经创建完完毕，可以安全使用。

```cpp
std::thread mytobj(myprint2,A(mysecondpar) );  //现在主线程构造出临时对象
```

###  说一下`C++` 的智能指针

 `C++`里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是 c++11 支持，并且第一个已经被`c++11`弃用。

智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。**智能指针其实就是一个类模板**。

对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命周期即将结束的时候，智能指针通过析构函数释放掉它管理的堆内存。

- <font color="#b5822d" size=5>auto_ptr</font>：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- <font color="#b5822d" size=5>unique_ptr</font>：是一种独占式智能指针，也就是同一时刻，只能有一个 unique_ptr 指针指向这个对象（这块内存）。在 C++14 的时候，unique_ptr 提供了 make_unique 函数。可以使用这个函数初始化性能更高。

- <font color="#b5822d" size=5>shared_ptr</font>：是一个共享指针，多个指针指向同一个对象（多个指针指向同一块内存），最后一个指针被销毁的时候，这个对象被释放，`shared_ptr`的工作机制是使用**引用计数**。            
可以使用 移动语义将对象变为空或者赋值，比如:

```cpp
shared_ptr<int> p1(new int(100)); //初始化：p1 指向这个对象（内存）
std::share_ptr<int> p2 = new int(100); //不行，因为智能指针是显式的类型转换 explicit ,不可以隐式类型转换

shared_ptr<int> p2(std::move(p1));  //移动语义，移动构造 p2，p1 不再指向这个对象而变成空

shared_ptr <int> p3;   
p3 = std::move(p2);     //移动赋值，p2 指向空，p3 指向这个对象，整个对象引用计数依旧为 1
```

<font color="orange" size=4 font-weight="bold">make_shared</font>

这是一个标准库里的函数模板，被认为最安全和更高效的分配和使用 shared_ptr 智能指针的一个 函数模板。

它能够在动态内存（堆）中分配并初始化一个对象，然后返回指向这个对象的 shared_ptr 。

```cpp
shared_ptr<int> p2 = std::make_shared<int>(100);  // 这个 shared_ptr 指向 100 的整数的内存，类似 int *p1 = new int(100);
shared_ptr<string> p3 = std::make_shared<string>(5,"a");  //类似 string p3(5,'a);

cout << *p2 << endl; //100
cout << *p3 << endl; //aaaaa
```


- <font color="#b5822d" size=5>weak_ptr</font>：也是一个类模板，这个指针指针指向一个由 shared_ptr 管理的对象，但是这种智能指针并不控制所指向的对象的生命周期，也就是说，将 weak_ptr 绑定到 shared_ptr 不会改变 shared_ptr 的引用计数。另外，weak_ptr 来直接访问对象，必须使用一个叫做 `lock` 的成员函数，`lock` 的功能就是检查 weak_ptr 所指向的对象是否还存在，如果存在，`lock` 就能返回一个共享对象的 shared_ptr 如果不存在，就返回一个空的 shared_ptr 。



#### RAII 是什么


RAII 全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，

RAII 依托「栈」和「析构函数」，来对所有的资源 —— 包括堆内存在内 —— 进行管理

也就是说在构造函数中申请分配资源，在析构函数中释放资源。


智能指针（`std::shared_ptr`和`std::unique_ptr`）即 RAII 最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记 delete 造成的内存泄漏。


C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：
- 对象很大；
- 对象的大小在编译时不能确定；
- 对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。

比如说在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。

我们怎样才能确保不会发生内存泄漏呢

答案就在析构函数和它的**栈展开**行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。这就是 RAII 的基本用法。

> 在发生异常时对析构函数的调用，也叫 **栈展开**，


## 什么是 RTTI

父类指针可以指向 new 一个子类对象

就比如：

```cpp
Human * phuman = new Men;
```

这时候很难确定 phuman 指向哪个类，要向得到所指向的对象相关的类信息就比较困难，所以 RTTI 就是要来解决这类问题的，也就是获取 phuman 所指向的对象相关的类的信息。

RTTI 的目的就是 让程序运行时能根据 **基类**的 指针 或者 引用 来获取这个 指针 或者 引用 指向的对象的实际类型

RTTI 通过两个运算符来实现：

- dynameic_cast `[daɪˈnæmɪk]` 运算符：将父类的指针或者引用安全地转换为 子类的指针或者引用
- typeid 运算符：返回指针或者引用所指向对象的实际类型

### dynamic_cast 运算符

想区分一个指针是父类类型还是子类类型，使用 dynamic_cast 运算符就能够判断出来 —— 用 dynamic_cast 能转换成功，就说明这个指针实际上是要转换到的那个类型，所以说 dynamic_cast 是帮助开发者做安全检查的。

> 使用 dynamic_cast 的前提条件是 父类中必须至少有一个虚函数。否则就会编译出错，或者可能无法得到正确的运行结果

### typeid 运算符

通过这个运算符可以获取对象的信息，这个运算符返回一个常量对象的引用。

- 只要两个指针定义时的类型相同，不管它们指向的是父类还是子类，typeid 就相等。

```cpp
Human *phuman = new Men;
Human *phuman2 = new Women;
```

- 只要两个指针运行时指向的类型相同，typeid 就相等，不管它们定义的类型是否相同。

```cpp
Human *phuman = new Men;
Human *phuman2 = new Men;

Human *phman3 = phuman2;
```

我们知道C++的多态性（运行时）是由虚函数实现的，对于多态性的对象，无法在程序编译阶段确定对象的类型。当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用 typeid 函数，该函数反回一个对`type_info`类对象的引用，要使用`typeid`必须使用头文件 `<typeinfo>`，因为`typeid是`一个返回类型为`typ_info`的引用的函数所以这里有必要先介绍一下`type_info`类。

因为`type_info`类的复制构造函数和赋值运算符都是私有的，所以不允许用户自已创建`type_info`的类。唯一要使用`type_info`类的方法就是使用`typeid`函数

---

## H264 视频编码

### 帧内预测编码的基本原理

对行车视线摄像头采集的视频进行编码

视频信息中一般会有空间冗余 和 时间冗余 的问题

- 空间冗余采用帧内预测编码压缩
- 时间冗余采用运动搜索和运动补偿压缩

### 为什么要有帧内预测

因为一般来说，对于一幅图像，相邻的两个像素的亮度和色度值之间经常是比较接近的，也就是颜色是逐渐变化的，不会一下子突变成完全不一样的颜色。而进行视频编码，目的就是利用这个相关性，来进行压缩。

很好理解，存储一个像素的亮度值可能需要8个bit，但是如果相邻的两个像素变化不大，我存储一个像素的原始值，以及第二个像素相对第一个像素的变化值，那么第二个值我可能用2个bit就够了，这就节约了很多的空间。而节约存储消耗的bit数，也就是节约码率，贯穿了H.264编码器的所有过程，不管是帧内预测、帧间预测、变换、量化、熵编码，一切的一切都是为这个目的服务的，明白了这一点，我们就能轻易的理解H.264编码器，所有看上去复杂难懂的地方，都是为了一个目的——节约码率。

![](https://upload-images.jianshu.io/upload_images/17427776-22df6f61691ed4e4.png?imageMogr2/auto-orient/strip|imageView2/2/w/792/format/webp)



[参考](https://www.jianshu.com/p/d5d92421186a?utm_campaign=haruki&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)


因为在各种视频帧类型中，I 帧全部采用帧内预测， I 帧的压缩比率通常比 P 帧 和 B 帧更低，因此帧内预测编码的效率对视频整体平均码率具有较大影响。另一方面，I 帧通常都会作为 `P/B` 帧解码过程中的参考帧，如果 I 帧的编码出现了错误，那么不仅仅是该I 帧出现错误，参考该I帧的 `P/B` 帧也同样不能正确解码。

I 帧采用的是帧内编码，对于 H.264 中采用的算法主要可分为预测编码模式和 PCM 编码模式。

H.264 的帧内预测算法通常可以分为三种情况讨论：4×4 的亮度分量预测、16×16 的亮度分量预测、色度分量预测。我们分别讨论这三种情况的算法原理。


#### 4×4 的亮度分量预测

就是对帧内预测宏块，分成 4x4 子块。每一块都会参考它相邻的像素来构建预测数据，

![](https://img-blog.csdnimg.cn/20181128223558801.png)

a~p表示预测块中的像素，A/B/C/D表示上方参考像素，E/F/G/H表示右上方的参考像素，I/J/K/L表示左方参考像素，Q表示左上方的参考像素。对于4×4亮度分量的帧内预测

- 垂直模式

![](https://img-blog.csdnimg.cn/20181128223639594.png)

在该模式下，每一个预测块的预测值由上方相邻的4个像素预测得到

- 水平模式

在该模式下，每一个预测块的预测值由左方相邻的4个像素预测得到；

![](https://img-blog.csdnimg.cn/20181128223709192.png)

该模式下，用上方和左方相邻像素的均值表示整个预测块

- 左下模式

![](https://img-blog.csdnimg.cn/20181128223718476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYXFvbmVhbA==,size_16,color_FFFFFF,t_70)

#### 16×16的亮度分量预测

和上面类似




[具体参考](https://yinwenjie.blog.csdn.net/article/details/77203414)


### 帧内预测编码的预测实现方法

[具体参考](https://yinwenjie.blog.csdn.net/article/details/78820128)


