
- [Hobot-SDK-<font color="orange">实习项目</font>](#hobot-sdk-font-colororange实习项目font)
  - [为什么使用宏函数](#为什么使用宏函数)
  - [detach 函数](#detach-函数)
    - [使用 detach 时候需要注意什么问题(线程安全问题)](#使用-detach-时候需要注意什么问题线程安全问题)
  - [怎么进行测试](#怎么进行测试)
  - [说一下`C++` 的智能指针](#说一下c-的智能指针)
    - [RAII 是什么](#raii-是什么)
- [什么是 RTTI](#什么是-rtti)
  - [dynamic_cast 运算符](#dynamic_cast-运算符)
  - [typeid 运算符](#typeid-运算符)
- [遇到的难题](#遇到的难题)
  - [解决了抽象类无法直接测试的问题](#解决了抽象类无法直接测试的问题)
  - [代码层面提出了代码优化](#代码层面提出了代码优化)
- [音视频](#音视频)

----

## Hobot-SDK-<font color="orange">实习项目</font>

Hobot Framework 提供了一个通过有向图的形式, 将基础代码功能模块组织成较复杂功能模块的机制。

基于 Hobot Framework, 所有的基础的功能以 `Module` 的形式提供; 功能之间的数据交换以 `Message` 为单位。

一个 `Module` 由多个 `Forward{n}` 组成，其中 `Forward{n}` 又可以以一个或多个别的 `Module::Forward{n}` 产生的 `Message` 为输入, 可以输出自己的 `Message`。

这样, 基础功能的开发者可以将自己的基础功能封装成一个 包含多个 `Forward` 的 `Module`, 并说明自己的输入输出;

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/concept.2nnp25ds1lu0.png)


### 为什么使用宏函数

> 主要是 利用空间换时间的思想吧

普通函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了时间。大家都知道的是，函数调用是要使用系统的栈来保存数据的，*如果编译器里有栈检查选项，一般在函数的头会嵌入一些汇编语句对当前栈进行检查；同时，CPU 也要在函数调用时保存和恢复当前的现场，* 会涉及进行压栈和弹栈操作，所以，函数调用需要一些 CPU 时间。 而宏函数不存在这个问题。

宏在编译之前进行,也就是先用宏体替换宏名,然后再编译的,而函数显然是编译之后,在执行时,才调用的.因此,宏占用的是编译的时间,而函数占用的是执行时的时间.

宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，因为在进行单元测试的时候会频繁调用同一个宏函数，所以这样效率会高很多。

> 在使用 detach 分离父进程和子进程，会导致线程安全问题，当时使用的是 临时对象的方式解决的。

### detach 函数

如果创建了很多子线程，让主线程逐个等待子线程结束，这种方法就显得不是很好，所以需要引入 detach 这种写法，**让主线程和子线程分离**，主线程不必等待子进程运行结束。

```cpp
mytoobj.detach();
```
> 一旦调用了 detach，就不可再调用 join 了。当然可以使用 joinable 判断是否成功使用 join 或者 detach 。

但是使用 detach 时候会导致内存安全问题，就比如在线程中传递引用，指针之类的参数，这样的话形参的地址是原来主线程中分配的，一旦主线程退出后，子线程再使用这块内存肯定是不安全的。

所以需要使用值传递，在创建线程这一行就构造出 **临时对象**，主要用这个临时构造的对象传递给线程入口函数，那么线程中的到的第二个参数就一定能够在主线程执行完毕之前构造出来。从而确保 detach 线程是安全的。

#### 使用 detach 时候需要注意什么问题(线程安全问题)

- 不要往线程中传递引用，指针之类的参数
- 建议使用值传递，建议在创建线程这一行就构造出临时对象，然后线程入口函数的形参**使用引用**来作为形参。 


```cpp
//不能这样使用
void myprint(const int& i,const string& pmybuf) {...}

//main()中
std::thread mytojob(myprint,mvar,mybuf);
mytojob.detach();

//使用类
std::thread mytojob(myprint,mvar,A(myobj));
```

C++ 语言只会为 const 引用临时对象，第一个参数不建议使用引用，因为 主线程可能先执行结束被回收了，导致 mvar 变量被回收。

第二个参数系统内部隐式将 char 数组转成 string 对象，但是这个转换时机可能发生在 主线程 执行结束后，这时候 mybuf 被系统回收了。

更改：
```
std::thread mytojob(myprint,mvar,string(mybuf));
```

直接将 mybuf 转换成 string 对象，`string(mybuf))`会生成一个临时对象，并将这个临时对象绑定到  pmybuf ，因此可以保证 pmybuf 肯定是有效的。

> 给线程入口函数传递类型对象时，只要使用临时对象作为实参，就可以确保线程入口函数的形参在 main 主函数退出前就已经创建完毕，可以保证线程安全。


### 怎么进行测试

我们建立一个 `class A`，如果直接在在形参中写 `A(mysecondpar)` ;这个对象是由 主线程传入的时候构造出来的，那么就可以出现主线程先结束的时候，就不能再构造了。

那么在给线程入口函数传递类型对象形参时，传在主线程中构造一个临时对象`A(mysecondpar)` ，就可以保证线程入口函数的形参在 主线程 函数退出前就已经创建完完毕，可以安全使用。

```cpp
std::thread mytobj(myprint2,A(mysecondpar) );  //现在主线程构造出临时对象
```

###  说一下`C++` 的智能指针

 `C++`里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是 c++11 支持，并且第一个已经被`c++11`弃用。

智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。**智能指针其实就是一个类模板**。

对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命周期即将结束的时候，智能指针通过析构函数释放掉它管理的堆内存。

- <font color="#b5822d" size=5>auto_ptr</font>：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- <font color="#b5822d" size=5>unique_ptr</font>：是一种独占式智能指针，也就是同一时刻，只能有一个 unique_ptr 指针指向这个对象（这块内存）。在 C++14 的时候，unique_ptr 提供了 make_unique 函数。可以使用这个函数初始化性能更高。

- <font color="#b5822d" size=5>shared_ptr</font>：是一个共享指针，多个指针指向同一个对象（多个指针指向同一块内存），最后一个指针被销毁的时候，这个对象被释放，`shared_ptr`的工作机制是使用**引用计数**。            
可以使用 移动语义将对象变为空或者赋值，比如:

```cpp
shared_ptr<int> p1(new int(100)); //初始化：p1 指向这个对象（内存）
std::share_ptr<int> p2 = new int(100); //不行，因为智能指针是显式的类型转换 explicit ,不可以隐式类型转换

shared_ptr<int> p2(std::move(p1));  //移动语义，移动构造 p2，p1 不再指向这个对象而变成空

shared_ptr <int> p3;   
p3 = std::move(p2);     //移动赋值，p2 指向空，p3 指向这个对象，整个对象引用计数依旧为 1
```

<font color="orange" size=4 font-weight="bold">make_shared</font>

这是一个标准库里的函数模板，被认为最安全和更高效的分配和使用 shared_ptr 智能指针的一个 函数模板。

它能够在动态内存（堆）中分配并初始化一个对象，然后返回指向这个对象的 shared_ptr 。

```cpp
shared_ptr<int> p2 = std::make_shared<int>(100);  // 这个 shared_ptr 指向 100 的整数的内存，类似 int *p1 = new int(100);
shared_ptr<string> p3 = std::make_shared<string>(5,"a");  //类似 string p3(5,'a);

cout << *p2 << endl; //100
cout << *p3 << endl; //aaaaa
```


- <font color="#b5822d" size=5>weak_ptr</font>：也是一个类模板，这个指针指针指向一个由 shared_ptr 管理的对象，但是这种智能指针并不控制所指向的对象的生命周期，也就是说，将 weak_ptr 绑定到 shared_ptr 不会改变 shared_ptr 的引用计数。另外，weak_ptr 来直接访问对象，必须使用一个叫做 `lock` 的成员函数，`lock` 的功能就是检查 weak_ptr 所指向的对象是否还存在，如果存在，`lock` 就能返回一个共享对象的 shared_ptr 如果不存在，就返回一个空的 shared_ptr 。



#### RAII 是什么


RAII 全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，

RAII 依托「栈」和「析构函数」，来对所有的资源 —— 包括堆内存在内 —— 进行管理

也就是说在构造函数中申请分配资源，在析构函数中释放资源。


智能指针（`std::shared_ptr`和`std::unique_ptr`）即 RAII 最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记 delete 造成的内存泄漏。


C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：
- 对象很大；
- 对象的大小在编译时不能确定；
- 对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。

比如说在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。

我们怎样才能确保不会发生内存泄漏呢

答案就在析构函数和它的**栈展开**行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。这就是 RAII 的基本用法。

> 在发生异常时对析构函数的调用，也叫 **栈展开**，


## 什么是 RTTI

父类指针可以指向 new 一个子类对象

就比如：

```cpp
Human * phuman = new Men;
```

这时候很难确定 phuman 指向哪个类，要向得到所指向的对象相关的类信息就比较困难，所以 RTTI 就是要来解决这类问题的，也就是获取 phuman 所指向的对象相关的类的信息。

RTTI 的目的就是 让程序运行时能根据 **基类**的 指针 或者 引用 来获取这个 指针 或者 引用 指向的对象的实际类型

RTTI 通过两个运算符来实现：

- dynameic_cast `[daɪˈnæmɪk]` 运算符：将父类的指针或者引用安全地转换为 子类的指针或者引用
- typeid 运算符：返回指针或者引用所指向对象的实际类型

### dynamic_cast 运算符

想区分一个指针是父类类型还是子类类型，使用 dynamic_cast 运算符就能够判断出来 —— 用 dynamic_cast 能转换成功，就说明这个指针实际上是要转换到的那个类型，所以说 dynamic_cast 是帮助开发者做安全检查的。

> 使用 dynamic_cast 的前提条件是 父类中必须至少有一个虚函数。否则就会编译出错，或者可能无法得到正确的运行结果

### typeid 运算符

通过这个运算符可以获取对象的信息，这个运算符返回一个常量对象的引用。

- 只要两个指针定义时的类型相同，不管它们指向的是父类还是子类，typeid 就相等。

```cpp
Human *phuman = new Men;
Human *phuman2 = new Women;
```

- 只要两个指针运行时指向的类型相同，typeid 就相等，不管它们定义的类型是否相同。

```cpp
Human *phuman = new Men;
Human *phuman2 = new Men;

Human *phman3 = phuman2;
```

我们知道C++的多态性（运行时）是由虚函数实现的，对于多态性的对象，无法在程序编译阶段确定对象的类型。当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用 typeid 函数，该函数反回一个对`type_info`类对象的引用，要使用`typeid`必须使用头文件 `<typeinfo>`，因为`typeid是`一个返回类型为`typ_info`的引用的函数所以这里有必要先介绍一下`type_info`类。

因为`type_info`类的复制构造函数和赋值运算符都是私有的，所以不允许用户自已创建`type_info`的类。唯一要使用`type_info`类的方法就是使用`typeid`函数


----

## 遇到的难题

### 解决了抽象类无法直接测试的问题

因为公司之前的项目都是给予 C 语言开发的，然后这次测试的项目内嵌了很多 C++ 的代码，所以公司使用的 vcast 工具也存在一些局限。

后面我就想着既然抽象类无法直接实例化，那就重写整个抽象类，然后用一个子类继承这个抽象类，并实现基类中的纯虚函数。

工具提供了在代码入口可以增加自定义代码的功能，然后就在这里自己写

### 代码层面提出了代码优化

在代码中大概的实现就是把 bp 指向位置的值多次加到 ap 指向位置。

大概的实现是这样的：

```c
void func1(int *ap,int *bp) {
  *ap += *bp;
  *ap += *bp;
}


//优化
void func2(int *ap,int *bp) {
  *ap += 2* *bp;
}
```

但是在构建测试用例时发现总是达不到预期的结果进不去。后来我参考代码的逻辑写了一个简单的，然后看了一下生成的汇编代码，发现了他们没有考虑到一个问题，就是 ap 和 bp 可能指向同一块内存。这样执行就得不到预期的结果。而且还提出了优化版本，可以减少内存的访问次数。


- func2 需要 3 次内存引用「读 *ap，读 *bp,写 *ap」
- func1 需要 6 次内存引用「2 次读 *ap，2 次读 *bp,2 次写 *ap」

虽然只是简单细节优化，但是我觉得对我来说也算是比较大的提升把

## 音视频

https://blog.csdn.net/qq_19923217/article/details/83348095

https://blog.csdn.net/weixin_52622200/article/details/116094163





