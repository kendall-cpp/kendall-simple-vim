> 每天学习一点面试

------

- [20210511](#20210511)
  - [堆和栈的区别](#堆和栈的区别)
  - [指针和引用的区别](#指针和引用的区别)
  - [TCP三次握手四次挥手，timewait多了怎么解决](#tcp三次握手四次挥手timewait多了怎么解决)
    - [三次握手](#三次握手)
    - [四次挥手](#四次挥手)
- [20210512](#20210512)
  - [同步io和异步io](#同步io和异步io)
  - [优化数据库](#优化数据库)
  - [B树和B+树的区别](#b树和b树的区别)
  - [长字符串找短字符串，可以使用hash吗](#长字符串找短字符串可以使用hash吗)
  - [各种排序的思路冒泡-快排-归并](#各种排序的思路冒泡-快排-归并)
  - [TCP与UDP的区别](#tcp与udp的区别)
    - [TCP 包过大会怎样](#tcp-包过大会怎样)
- [20200514](#20200514)
  - [MySQL存储引擎](#mysql存储引擎)
  - [大小端怎么判断](#大小端怎么判断)
  - [`void*` 可以直接输出值吗](#void-可以直接输出值吗)
  - [timewait状态多久，为什么要有](#timewait状态多久为什么要有)
  - [B+树一个节点有多大？一千万条数据，B+树多高？](#b树一个节点有多大一千万条数据b树多高)
  - [1亿数据数组找最大10万个](#1亿数据数组找最大10万个)
  - [STL中hashTable的实现](#stl中hashtable的实现)


## 20210511

-----

### 堆和栈的区别

* 栈，栈由系统自动分配，存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
* 堆，是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
* 堆的生长空间向高地址生长的，地址越来越大，栈的生长空间向低地址生长的，地址越来越小
* 栈相对于堆来说会快一点，因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，堆在分配和释放时都要调用函数（`malloc,free`)。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

### 指针和引用的区别

* 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作
* 指针可以有多级，引用只有一级
* 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
* 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小
* 指针可以为空，引用不可以。
* 引用一旦进行初始化之后，不会再改变其指向；但指针可以

### TCP三次握手四次挥手，timewait多了怎么解决

#### 三次握手


- 第一次握手：

客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号`ISN`(比如是`100`)，那客户端向服务端发送的报文段包含同步序号`SYN`标志位(也就是`SYN=1`)，序列号`seq=100`。

这时候`client`处于同步状态`SYN_SENT`。也就是可以建立连接。服务端处于监听状态`LISTEN`。

- 第二次握手

服务端收到客户端发过来的报文后，发现同步序号`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1`,`ACK=1`)、序列号`seq=300`、确认号`ack=101`(*客户端发过来的序列号+1*)。

  这个时候服务端处于`SYN_RECV`同步接收状态。

- 第三次握手

客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(*服务端序列号+1*)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。


> 上面过程中，**第三次捂手是可以携带数据的，前两次握手不可以携带数据。**

#### 四次挥手


> 四次挥手的目的是关闭一个连接

当我们的应用程序不需要数据通信了，就会发起断开 `TCP` 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

假如客户端先发起关闭请求。

- 第一次挥手。客户端向服务端发送一个 FIN 报文，报文中会指定一个序号（假如`seq = u`)，这个时候客户端处于终止等待1 `FIN_WAIT_1` 状态，客户端会停止发送数据，主动关闭 TCP 连接，并等待服务端确认。

- 第二次挥手，服务端收到客户端的 FIN 报文后，就知道这是一个关闭请求。然后服务端向客户端返回一个确认报文，包含确认序号`ACK = 1`，`ack = seq + 1`,也就是`u+1`,并带上自己的序号`squ = v`,这时候服务端处于终止等待`CLOSE_WAIT` 状态，客户端进入`FIN_WAIT_2` 状态。TCP 处于半关闭状态，因为客户端不会发送数据了，不过服务器端有数据发送的话，客户端依然需要接收。

- 第三次挥手，如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。也就是服务端没有数据要向客户端发送了，服务端发出**连接释放报文段**包含（`FIN=1`，`ACK=1`，序号`seq=w`，确认号`ack=u+1`），服务端进入` LAST_ACK`（最后确认）状态，等待客户端的确认。

- 第四次挥手。客户端收到服务器的 `FIN` 包后，向服务端返回确认报文（`ACK=1，ack=w+1`），这个时候客户端就进入了 `TIME_WAIT` （时间等待）状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 `TCP` 连接的时间要比客户端早一些。

> 客户端：FIN_WAIT_1 --> FIN_WAIT_2 --> TIME_WAIT

> 服务端：LISTEN --> CLOSE_WAIT --> LAST_ACK --> CLOSED





----

## 20210512

----

### 同步io和异步io

- **同步**：

所谓同步，是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。

例如普通`B/S`模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

- **异步**：

异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过 状态、通知和回调 来通知调用者。

例如 `ajax`请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

### 优化数据库

高频访问：

* 分表分库：将数据库表进行水平拆分，减少表的长度
* 增加缓存： 在web和DB(数据库)之间加上一层缓存层
* 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题

并发优化：

* 主从读写分离：只在主服务器上写，从服务器上读
* 负载均衡集群：通过集群或者分布式的方式解决并发压力

### B树和B+树的区别

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/Bptree.6qj0kx0hs900.png)

这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。

1. **关键字的数量不同**；B+树中分支结点有m个关键字，它的孩子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
2. **存储的位置不同**；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
3. `B+`树的所有叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。
4. **查询不同**；B树在找到具体的数值以后，则结束，而`B+`树则需要通过索引找到叶子结点中的数据才结束，也就是说`B+`树的搜索过程中走了一条从根结点到叶子结点的路径。

B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便查询，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来查找，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。

### 长字符串找短字符串，可以使用hash吗

> 长字符串找短字符串 的方法

- 暴力破解

一种幼稚的做法是轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要$O(n* m)$次操作，其中`n`是`string1`的长度，`m`是`string2`的长度。就拿上面的例子来说，最坏的情况下将会有$16*8 = 128$次操作。

- 排序后匹配

一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)$O(m log m) + O(n log n)$次操作，之后的线性扫描需要O(m+n)次操作。同样拿上面的字串做例子，将会需要$164 + 83 = 88$加上对两个字串线性扫描的$16 + 8 = 24$的操作。(随着字串长度的增长，你会发现这个算法的效果会越来越好)

- hashtable匹配

最终，我告诉了他一个最佳的算法，只需要$O(n+m)$次操作。方法就是，对第一个字串进行轮询，把其中的每个字母都放入一个`Hashtable`里(成本是$O(n)$或16次操作)。然后轮询第二个字串，在`Hashtable`里查询每个字母，看能否找到。如果找不到，说明没有匹配成功。这将消耗掉8次操作 —— 这样两项操作加起来一共只有24次。不错吧，比前面两种方案都要好。

### 各种排序的思路冒泡-快排-归并

* [常见排序算法](/寻offer总结/数据结构_场景应用/排序算法.md)

### TCP与UDP的区别

- 1.`TCP`面向连接，`UDP`无连接。
- 2.`TCP`面向字节流（文件传输），`UDP`是面向报文的，`UDP`没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（比如`IP`电话，实时视频会议等）。
- 3.`TCP`首部开销`20`字节，UDP的首部开销小，只有8个字节。
- 4.`TCP`的逻辑通信信道是全双工的可靠信道，提供可靠的服务。也就是说，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且有序到达; `UDP`是不可靠信道，`UDP`只是尽最大努力交付，并不保证可靠交付。
- 5.每一条`TCP`连接只能是点到点的；`UDP`支持一对一，一对多，多对一和多对多的交互通信。
- 6.`TCP`对系统资源的要求高于`UDP`，所以速度也比`UDP`慢。
- 7.`TCP`数据包是没有边界的，会出现粘包的问题，`UDP`包是独立的，不会出现粘包问题。
- 所以在应用方面，如果强调数据的完整性和正确性用`TCP`，当要求性能和速度的时候，使用`UDP`更加合适。

#### TCP 包过大会怎样

> TCP UDP 数据包过大导致分片

`MTU`大家都知道，是链路层中的网络对数据帧的一个限制，以太网为例，`MTU`为`1500`个字节。一个IP数据报在以太网中传输，如果它的长度大于该`MTU`值，就要进行分片传输，使得每片数据报的长度小`于MTU`。不过分片传输的`IP`数据报不一定按序到达，但`IP`首部中的信息能让这些数据报片按序组装。`IP`数据报的分片与重组是在网络层进完成的。

**MSS（最大分段大小）**

`MSS`是`TCP`首部的一个字段，`MSS`是`TCP`数据包每次能够传输的最大数据分段，`TCP`报文段的长度大于`MSS`时，要进行分段传输。`MSS`选项只出现在`SYN`报文段中，即`TCP`三次握手的前两次。`MSS`的值一般为`MTU`值减去两个首部大小。 

再来看`UDP`数据报，由于`UDP`数据报不会自己进行分段，因此当长度超过了`MTU`时，会在网络层进行`IP`分片。同样，`ICMP`（在网络层中）同样会出现`IP`分片情况。  
   
**总结：`UDP`不会分段，就由`IP`来分。`TCP`会分段，当然就不用`IP`来分了！**

PS: **内核缓冲区总是充满数据时会产生粘包问题**

-------

## 20200514

### MySQL存储引擎


存储引擎是`MYSQL`的核心技术，不同的存储引擎使用不同的存储机制、索引技巧、锁定水平并最终提供不同的功能和能力。常见的引擎分为三种：**InnoDB存储引擎（MYSQL默认的事务性引擎）、MyISAM存储引擎、Memory存储引擎**。

* InnoDB ： `InnoDB`是`mysql`的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁

* MyISAM ： 插入和查询速度比较快，支持大文件，但是不支持事务，适合在`web`和数据仓库场景下使用  表级锁

* MEMORY ： `memory`将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景

### 大小端怎么判断

计算机有两种存储数据的方式:**大端字节序** （big endian）和**小段字节序**（little endian）。

比如：数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11

>- 大端字节序：高位字节在前面，低位字节在后面,这符合人类的读写数值方法
>- 小端字节序：地位字节在前面，高位字节在后面。

**为什么会有小端字节序？**

计算机都是从低位开始处理字节效率比较高，因为计算都是从低位开始的，因此计算机内部都是小端字节序。            
但是人类比较习惯大端字节序，所以除了计算机内部处理，其他场合一般都用大端字节序，比如网络参数，文件存储。

计算机在处理字节序的时候是按照顺序读取字节的，**如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。**

### `void*` 可以直接输出值吗

- `void *` 可以定义一个指针变量，但不说明它指向哪一种类型数据.

- 使用`void *`表示该函数指针可以不用指定为某种特定类型。例如，在套接字函数中，`send(void * pData, int nLength)`这意味着您可以通过多种方式调用它，`pData` 可以是字符串，甚至可以是一个对象。例如
```c
char * data = "blah";
send(data, strlen(data));
POINT p;
p.x = 1;
p.y = 2;
send(&p, sizeof(POINT));
```

- 指向0的地址,`(void *)0`，指向全是`0`的地址，相当于`NULL`。

- 可执行 赋值，取值操作，但不能用于指定数据输出，因为没有指定要输出的数据长度，如果可以输出，那么将会是一个无限长的输出。

### timewait状态多久，为什么要有

`TIME_WAIT`是指四次挥手中客户端接收了服务端的`FIN`报文并发送`ACK`报文给服务器后，仍然需要等待`2MSL`时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入`CLOSED`状态了，但是我们必须假设网络是不可靠的，有可能最后一个`ACK`丢失。如果客户端发送的`ACK`发生丢失，服务器会再次发送`FIN`报文给客户端，所以`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。

### B+树一个节点有多大？一千万条数据，B+树多高？

B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 `<` 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。

在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是`16k`。之所以设置为一页，是因为对于大部分业务，一页就足够了：

首先 InnoDB 的 B+ 树中，非叶子节点存的是`key` + 指针；叶子节点存的是数据行。

- 对于叶子节点，如果一行数据大小为`1k`，那么一页就能存`16`条数据；
- 对于非叶子节点，如果`key`使用的是`bigint`，也就是为`8`字节，指针在`mysql`中为`6`字节，一共是`14`字节，则`16k`能存放 $16 * 1024 / 14 = 1170$ 个索引指针。

于是可以算出，对于一颗高度为`2`的`B+`树，根节点存储索引指针节点，那么它有`1170`个叶子节点存储数据，每个叶子节点可以存储`16`条数据，一共 $1170 * 16 = 18720$ 条数据。

而对于高度为`3`的B+树，就可以存放 $1170 x 1170 x 16 = 21902400$ 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为`3`的`B+`树就可以完成，通过主键查询只需要`3`次`IO`操作就能查到对应数据。所以在 InnoDB 中`B+`树高度一般为`3`层时，就能满足千万级的数据存储，所以一个节点为`1`页，也就是`16k`是比较合理的。

### 1亿数据数组找最大10万个

> 分治+最小堆，hash进行优化重复数据

关于海量数据问题：

https://blog.csdn.net/hitxueliang/article/details/52153476

https://blog.csdn.net/sinat_42483341/article/details/108277388

### STL中hashTable的实现

STL中的`hashtable`使用的是**开链法**解决`hash`冲突问题，`hashtable`表内的元素称为桶（`bucket`),而由桶所链接的元素称为节点（`node`), 如下图所示。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/哈希表01.2oeu7i4l7fo.png)

`HashTable` 中的 `bucket` 维护的 列表不是`list`，也不是 `slist`，而是自己定义的 `hashtable_node` 数据结构组成的`linked-list`,并使用`vector`存放桶元素。`hashtable`的迭代器只提供前进操作，不提供后退操作.

`hashTable` 中的 `bucket` 是由28个质数`[53, 97, 193,...,429496729]`实现的，在创建`hashtable`时，会根据存入的元素个数选择大于等于元素个数的质数作为`hashtable`的容量（也就是`vector`的长度），其中每个`bucket`所维护的`linked-list`长度也等于`hashtable`的容量。如果插入`hashtable`的元素个数超过了`bucket`的容量，就要进行重建`table`操作，也就是找出下一个质数，创建新的`buckets vector`，重新计算元素在新`hashtable`的位置。



