> 每天学习一点面试

------

- [20210511](#20210511)
  - [堆和栈的区别](#堆和栈的区别)
  - [指针和引用的区别](#指针和引用的区别)
  - [TCP三次握手四次挥手，timewait多了怎么解决](#tcp三次握手四次挥手timewait多了怎么解决)
    - [三次握手](#三次握手)
    - [四次挥手](#四次挥手)
- [20210512](#20210512)
  - [同步io和异步io](#同步io和异步io)
  - [优化数据库](#优化数据库)
  - [B树和B+树的区别](#b树和b树的区别)
  - [长字符串找短字符串，可以使用hash吗](#长字符串找短字符串可以使用hash吗)
  - [各种排序的思路冒泡-快排-归并](#各种排序的思路冒泡-快排-归并)
  - [TCP与UDP的区别](#tcp与udp的区别)
    - [TCP 包过大会怎样](#tcp-包过大会怎样)
- [20200514](#20200514)
  - [MySQL存储引擎](#mysql存储引擎)
  - [大小端怎么判断](#大小端怎么判断)
  - [`void*` 可以直接输出值吗](#void-可以直接输出值吗)
  - [timewait状态多久，为什么要有](#timewait状态多久为什么要有)
  - [B+树一个节点有多大？一千万条数据，B+树多高？](#b树一个节点有多大一千万条数据b树多高)
  - [1亿数据数组找最大10万个](#1亿数据数组找最大10万个)
  - [STL中hashTable的实现](#stl中hashtable的实现)
- [20150516](#20150516)
  - [五层协议，每层都有哪些协议](#五层协议每层都有哪些协议)
  - [TCP怎么保证可靠传输的](#tcp怎么保证可靠传输的)
  - [说一下`TCP`怎么进行拥塞控制的？](#说一下tcp怎么进行拥塞控制的)
  - [静态多态和动态多态](#静态多态和动态多态)
  - [C++虚函数相关，虚函数的实现原理](#c虚函数相关虚函数的实现原理)
  - [虚函数表是如何实现动态绑定的](#虚函数表是如何实现动态绑定的)
  - [多态时候基类的sizeof，子类的sizeof](#多态时候基类的sizeof子类的sizeof)
  - [为什么成员函数不占用类的空间](#为什么成员函数不占用类的空间)


## 20210511

-----

### 堆和栈的区别

* 栈，栈由系统自动分配，存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
* 堆，是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
* 堆的生长空间向高地址生长的，地址越来越大，栈的生长空间向低地址生长的，地址越来越小
* 栈相对于堆来说会快一点，因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，堆在分配和释放时都要调用函数（`malloc,free`)。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

### 指针和引用的区别

* 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作
* 指针可以有多级，引用只有一级
* 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
* 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小
* 指针可以为空，引用不可以。
* 引用一旦进行初始化之后，不会再改变其指向；但指针可以

### TCP三次握手四次挥手，timewait多了怎么解决

#### 三次握手


- 第一次握手：

客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号`ISN`(比如是`100`)，那客户端向服务端发送的报文段包含同步序号`SYN`标志位(也就是`SYN=1`)，序列号`seq=100`。

这时候`client`处于同步状态`SYN_SENT`。也就是可以建立连接。服务端处于监听状态`LISTEN`。

- 第二次握手

服务端收到客户端发过来的报文后，发现同步序号`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1`,`ACK=1`)、序列号`seq=300`、确认号`ack=101`(*客户端发过来的序列号+1*)。

  这个时候服务端处于`SYN_RECV`同步接收状态。

- 第三次握手

客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(*服务端序列号+1*)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。


> 上面过程中，**第三次捂手是可以携带数据的，前两次握手不可以携带数据。**

#### 四次挥手


> 四次挥手的目的是关闭一个连接

当我们的应用程序不需要数据通信了，就会发起断开 `TCP` 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

假如客户端先发起关闭请求。

- 第一次挥手。客户端向服务端发送一个 FIN 报文，报文中会指定一个序号（假如`seq = u`)，这个时候客户端处于终止等待1 `FIN_WAIT_1` 状态，客户端会停止发送数据，主动关闭 TCP 连接，并等待服务端确认。

- 第二次挥手，服务端收到客户端的 FIN 报文后，就知道这是一个关闭请求。然后服务端向客户端返回一个确认报文，包含确认序号`ACK = 1`，`ack = seq + 1`,也就是`u+1`,并带上自己的序号`squ = v`,这时候服务端处于终止等待`CLOSE_WAIT` 状态，客户端进入`FIN_WAIT_2` 状态。TCP 处于半关闭状态，因为客户端不会发送数据了，不过服务器端有数据发送的话，客户端依然需要接收。

- 第三次挥手，如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。也就是服务端没有数据要向客户端发送了，服务端发出**连接释放报文段**包含（`FIN=1`，`ACK=1`，序号`seq=w`，确认号`ack=u+1`），服务端进入` LAST_ACK`（最后确认）状态，等待客户端的确认。

- 第四次挥手。客户端收到服务器的 `FIN` 包后，向服务端返回确认报文（`ACK=1，ack=w+1`），这个时候客户端就进入了 `TIME_WAIT` （时间等待）状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 `TCP` 连接的时间要比客户端早一些。

> 客户端：FIN_WAIT_1 --> FIN_WAIT_2 --> TIME_WAIT

> 服务端：LISTEN --> CLOSE_WAIT --> LAST_ACK --> CLOSED





----

## 20210512

----

### 同步io和异步io

- **同步**：

所谓同步，是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。

例如普通`B/S`模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

- **异步**：

异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过 状态、通知和回调 来通知调用者。

例如 `ajax`请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

### 优化数据库

高频访问：

* 分表分库：将数据库表进行水平拆分，减少表的长度
* 增加缓存： 在web和DB(数据库)之间加上一层缓存层
* 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题

并发优化：

* 主从读写分离：只在主服务器上写，从服务器上读
* 负载均衡集群：通过集群或者分布式的方式解决并发压力

### B树和B+树的区别

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/Bptree.6qj0kx0hs900.png)

这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。

1. **关键字的数量不同**；B+树中分支结点有m个关键字，它的孩子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
2. **存储的位置不同**；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
3. `B+`树的所有叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。
4. **查询不同**；B树在找到具体的数值以后，则结束，而`B+`树则需要通过索引找到叶子结点中的数据才结束，也就是说`B+`树的搜索过程中走了一条从根结点到叶子结点的路径。

B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便查询，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来查找，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。

### 长字符串找短字符串，可以使用hash吗

> 长字符串找短字符串 的方法

- 暴力破解

一种幼稚的做法是轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要$O(n* m)$次操作，其中`n`是`string1`的长度，`m`是`string2`的长度。就拿上面的例子来说，最坏的情况下将会有$16*8 = 128$次操作。

- 排序后匹配

一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)$O(m log m) + O(n log n)$次操作，之后的线性扫描需要$O(m+n)$次操作。同样拿上面的字串做例子，将会需要$164 + 83 = 88$加上对两个字串线性扫描的$16 + 8 = 24$的操作。(随着字串长度的增长，你会发现这个算法的效果会越来越好)

- hashtable匹配

最终，有一个最佳的算法，只需要$O(n+m)$次操作。方法就是，对第一个字串进行轮询，把其中的每个字母都放入一个`Hashtable`里(成本是$O(n)$或16次操作)。然后轮询第二个字串，在`Hashtable`里查询每个字母，看能否找到。如果找不到，说明没有匹配成功。这将消耗掉8次操作 —— 这样两项操作加起来一共只有24次。不错吧，比前面两种方案都要好。

### 各种排序的思路冒泡-快排-归并

* [常见排序算法](/寻offer总结/数据结构_场景应用/排序算法.md)

### TCP与UDP的区别

- 1.`TCP`面向连接，`UDP`无连接。
- 2.`TCP`面向字节流（文件传输），`UDP`是面向报文的，`UDP`没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（比如`IP`电话，实时视频会议等）。
- 3.`TCP`首部开销`20`字节，UDP的首部开销小，只有8个字节。
- 4.`TCP`的逻辑通信信道是全双工的可靠信道，提供可靠的服务。也就是说，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且有序到达; `UDP`是不可靠信道，`UDP`只是尽最大努力交付，并不保证可靠交付。
- 5.每一条`TCP`连接只能是点到点的；`UDP`支持一对一，一对多，多对一和多对多的交互通信。
- 6.`TCP`对系统资源的要求高于`UDP`，所以速度也比`UDP`慢。
- 7.`TCP`数据包是没有边界的，会出现粘包的问题，`UDP`包是独立的，不会出现粘包问题。
- 所以在应用方面，如果强调数据的完整性和正确性用`TCP`，当要求性能和速度的时候，使用`UDP`更加合适。

#### TCP 包过大会怎样

> TCP UDP 数据包过大导致分片

`MTU`大家都知道，是链路层中的网络对数据帧的一个限制，以太网为例，`MTU`为`1500`个字节。一个IP数据报在以太网中传输，如果它的长度大于该`MTU`值，就要进行**分片传输**，使得每片数据报的长度小于`MTU`。不过分片传输的`IP`数据报不一定按序到达，但`IP`首部中的信息能让这些数据报片按序组装。`IP`数据报的分片与重组是在网络层进完成的。

**MSS（最大分段大小）**

`MSS`是`TCP`首部的一个字段，`MSS`是`TCP`数据包每次能够传输的最大数据分段，`TCP`报文段的长度大于`MSS`时，要进行分段传输。`MSS`选项只出现在`SYN`报文段中，即`TCP`三次握手的前两次。`MSS`的值一般为`MTU`值减去两个首部大小。 

再来看`UDP`数据报，由于`UDP`数据报不会自己进行分段，因此当长度超过了`MTU`时，会在网络层进行`IP`分片。同样，`ICMP`（在网络层中）同样会出现`IP`分片情况。  
   
**总结：`UDP`不会分段，就由`IP`来分。`TCP`会分段，当然就不用`IP`来分了！**

> PS: **内核缓冲区总是充满数据时会产生粘包问题**

-------

## 20200514

### MySQL存储引擎


存储引擎是`MYSQL`的核心技术，不同的存储引擎使用不同的存储机制、索引技巧、锁定水平并最终提供不同的功能和能力。常见的引擎分为三种：**InnoDB存储引擎（MYSQL默认的事务性引擎）、MyISAM存储引擎、Memory存储引擎**。

* InnoDB ： `InnoDB`是`mysql`的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁

* MyISAM ： 插入和查询速度比较快，支持大文件，但是不支持事务，适合在`web`和数据仓库场景下使用  表级锁

* MEMORY ： `memory`将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景

### 大小端怎么判断

计算机有两种存储数据的方式:**大端字节序** （big endian）和**小段字节序**（little endian）。

比如：数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11

>- 大端字节序：高位字节在前面，低位字节在后面,这符合人类的读写数值方法
>- 小端字节序：地位字节在前面，高位字节在后面。

**为什么会有小端字节序？**

计算机都是从低位开始处理字节效率比较高，因为计算都是从低位开始的，因此计算机内部都是小端字节序。            
但是人类比较习惯大端字节序，所以除了计算机内部处理，其他场合一般都用大端字节序，比如网络参数，文件存储。

计算机在处理字节序的时候是按照顺序读取字节的，**如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。**

### `void*` 可以直接输出值吗

- `void *` 可以定义一个指针变量，但不说明它指向哪一种类型数据.

- 使用`void *`表示该函数指针可以不用指定为某种特定类型。例如，在套接字函数中，`send(void * pData, int nLength)`这意味着您可以通过多种方式调用它，`pData` 可以是字符串，甚至可以是一个对象。例如
```c
char * data = "blah";
send(data, strlen(data));
POINT p;
p.x = 1;
p.y = 2;
send(&p, sizeof(POINT));
```

- 指向`0`的地址,`(void *)0`，指向全是`0`的地址，相当于`NULL`。

- 可执行 赋值，取值操作，但**不能用于指定数据输出**，因为没有指定要输出的数据长度，如果可以输出，那么将会是一个无限长的输出。

### timewait状态多久，为什么要有

`TIME_WAIT`是指四次挥手中客户端接收了服务端的`FIN`报文并发送`ACK`报文给服务器后，仍然需要等待`2MSL`时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入`CLOSED`状态了，但是我们必须假设网络是不可靠的，有可能最后一个`ACK`丢失。如果客户端发送的`ACK`发生丢失，服务器会再次发送`FIN`报文给客户端，所以`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。

### B+树一个节点有多大？一千万条数据，B+树多高？

B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 `<` 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。

在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是`16k`。之所以设置为一页，是因为对于大部分业务，一页就足够了：

首先 InnoDB 的 B+ 树中，非叶子节点存的是`key` + 指针；叶子节点存的是数据行。

- 对于叶子节点，如果一行数据大小为`1k`，那么一页就能存`16`条数据；
- 对于非叶子节点，如果`key`使用的是`bigint`，也就是为`8`字节，指针在`mysql`中为`6`字节，一共是`14`字节，则`16k`能存放 $16 * 1024 / 14 = 1170$ 个索引指针。

于是可以算出，对于一颗高度为`2`的`B+`树，根节点存储索引指针节点，那么它有`1170`个叶子节点存储数据，每个叶子节点可以存储`16`条数据，一共 $1170 * 16 = 18720$ 条数据。

而对于高度为`3`的B+树，就可以存放 $1170 x 1170 x 16 = 21902400$ 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为`3`的`B+`树就可以完成，通过主键查询只需要`3`次`IO`操作就能查到对应数据。所以在 InnoDB 中`B+`树高度一般为`3`层时，就能满足千万级的数据存储，所以一个节点为`1`页，也就是`16k`是比较合理的。

### 1亿数据数组找最大10万个

> 分治+最小堆，hash进行优化重复数据

关于海量数据问题：

https://blog.csdn.net/hitxueliang/article/details/52153476

https://blog.csdn.net/sinat_42483341/article/details/108277388

### STL中hashTable的实现

STL中的`hashtable`使用的是**开链法**解决`hash`冲突问题，`hashtable`表内的元素称为桶（`bucket`),而由桶所链接的元素称为节点（`node`), 如下图所示。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/哈希表01.2oeu7i4l7fo.png)

`HashTable` 中的 `bucket` 维护的 列表不是`list`，也不是 `slist`，而是自己定义的 `hashtable_node` 数据结构组成的`linked-list`,并使用`vector`存放桶元素。`hashtable`的迭代器只提供前进操作，不提供后退操作.

`hashTable` 中的 `bucket` 是由28个质数`[53, 97, 193,...,429496729]`实现的，在创建`hashtable`时，会根据存入的元素个数选择大于等于元素个数的质数作为`hashtable`的容量（也就是`vector`的长度），其中每个`bucket`所维护的`linked-list`长度也等于`hashtable`的容量。如果插入`hashtable`的元素个数超过了`bucket`的容量，就要进行重建`table`操作，也就是找出下一个质数，创建新的`buckets vector`，重新计算元素在新`hashtable`的位置。

----------

## 20150516

### 五层协议，每层都有哪些协议

每一层的作用：
- 物理层：负责底层数据传输，就是为数据链路层提供二进制传输服务。如网线；网卡标准。 （比特`Bit`）

- 数据链路层：接收来自物理层的数据，并封装成帧，传送到网络层；如网卡`MAC`地址。（帧Frame），ARP，STP

- 网络层：定义`IP`编址，定义路由选择功能；如不同设备的数据转发。（包Packet），IP，ICMP

- 传输层：主要负责端到端之间传输数据；如 `TCP`、`UDP`。（段 Segments）

- 会话层：负责在网络中的两节点之间建立、维持和终止通信；如一个软件的数据分发给另一个软件。

- 表示层：数据格式标识，基本压缩加密功能。

- 应用层：各种应用软件，包括 `Web` 应用。HTTP，HTTPS，DNS，RTMP

### TCP怎么保证可靠传输的

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：`TCP`报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：`tcp`会按最大传输单元(MTU)合理分片，接收方如果收到的数据不按顺序的时候，就会对它重新排序再交给应用层。
  - 而对于UDP：`IP`数据报如果大于1500字节，也就是大于`MTU`。这个时候就会对数据包进行分片，让每一片都少于`MTU`，由于`UDP`的特性，有些分片会被丢弃，所以导致最终无法重组数据包，导致丢弃整个`UDP`数据报。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

> 拥塞控制有四种算法，**慢启动、拥塞避免，快速重传和快速恢复**

### 说一下`TCP`怎么进行拥塞控制的？

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。


`TCP` 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快速重传、快速恢复**。

- **慢启动**。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即`1、2、4、8、16`
  * 为了防止拥塞窗口`cwnd`增长过大引起网络拥塞，还要另外设置一个慢启动阈值`ssthresh`状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ `cwnd > ssthresh` 时），停止使用慢启动算法而改用拥塞避免算法。

- **拥塞避免**：设置慢启动阈值，一般开始都设为`65536`。拥塞避免是指当拥塞窗口大小达到这个阈值的时候，拥塞窗口的值不再指数上升，而是采用加法增加（也就是每经过一个往返时间`RTT`就把发送方的拥塞窗口大小`+1`），以此来避免拥塞。

- **快速重传**：当发送端连续收到三个重复的`ack`时，表示该数据段已经丢失，需要重发。这个时候慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd`变为`ssth+3`，然后使用`+1+1`的发（也就是每一轮`RTT`就+1）

- **快速恢复**。当超过设定的时间没有收到某个报文段的`ack`时，表示网络拥塞，慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd=1`，进入慢启动阶段。

### 静态多态和动态多态

- **静态多态**

静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。
静态多态有两种实现方式：

  1.函数重载：包括普通函数的重载和成员函数的重载

  2.函数模板的使用

- **动态多态**（动态绑定）

即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法

**C++是依靠虚函数来实现动态多态的**

### C++虚函数相关，虚函数的实现原理

虚函数：在基类的函数前加上`virtual`关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.

**`C++`的虚函数是实现多态的机制**。它是通过虚函数表和虚表指针实现的，虚表是一个指针数组，它存放着指向虚函数的指针，类的实例在调用虚函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。[也就是 ==> 实现编译器处理虚函数表应该如何处理](#实现编译器处理虚函数表应该如何处理)

### 虚函数表是如何实现动态绑定的

>  虚函数的动态绑定是利用虚表和虚表指针类实现的

假如有一个类 B 继承另一个类 A ，如果基类 A 中有包含了虚函数，那么继承类 B 就可以调用基类 A 的虚函数，也就是说一个类继承了包含虚函数的基类，那么这个类就应有自己的虚表。

我们来看以下的代码。类 A 包含虚函数`vfunc1`，`vfunc2`，由于类 A 包含虚函数，故类 A 拥有一个虚表。

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

![虚函数表01](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表01.png)

**虚表是一个指针数组，它存放着指向虚函数的指针**，普通函数也就非虚函数，它的调用不需要经过虚表，所以虚表中并没有存放指向非虚函数的指针。

为了指定对象的虚表，对象中包含一个指向虚表的指针，指向自己的虚表，为了让每个包含虚表的类的对象都用一个虚表指针，编译器在类中添加一个指针`*__vptr`，每个类创建的对象的时候这个指针默认指向类的虚表。

![虚函数表02](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表02.png)

一个继承类的基类如果包含虚函数，那这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。

**那么C++ 是如何利用虚表和虚表指针来实现动态绑定的呢**？

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类 A 是基类，类 B 继承类 A，类 C 又继承类 B。类 A，类 B，类 C，其对象模型如下图所示。

![虚函数表03](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表03.png)

由于这三个类都有虚函数，所以编译器为每个类都创建了一个虚表，即类 A 的虚表（`A vtbl`），类 B 的虚表（`B vtbl`），类 C 的虚表（`C vtbl`）。类 A，类 B，类 C 的对象都拥有一个虚表指针，`*__vptr`，用来指向自己所属类的虚表。

类 A 包括两个虚函数，故 `A vtbl` 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 `B vtbl` 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 `C vtbl` 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。

综上所诉，对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向它继承的最近的一个类的虚函数。

非虚函数的调用不用经过虚表，所以不需要虚表中的指针指向这些函数

### 多态时候基类的sizeof，子类的sizeof

根据虚函数的工作机制，通常编译器处理虚函数时会给对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，因此类中添加虚函数后，sizeof(类名)应为该指针的大小。

> https://blog.csdn.net/weixin_42067304/article/details/108547910

### 为什么成员函数不占用类的空间

> https://blog.csdn.net/weixin_39888807/article/details/111103858

