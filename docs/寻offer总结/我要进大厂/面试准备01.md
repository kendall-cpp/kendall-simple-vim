> 每天学习一点面试

------

- [20210511](#20210511)
  - [堆和栈的区别](#堆和栈的区别)
  - [指针和引用的区别](#指针和引用的区别)
  - [TCP三次握手四次挥手，timewait多了怎么解决](#tcp三次握手四次挥手timewait多了怎么解决)
    - [三次握手](#三次握手)
    - [四次挥手](#四次挥手)
- [20210512](#20210512)
  - [同步io和异步io](#同步io和异步io)
  - [优化数据库](#优化数据库)
  - [B树和B+树的区别](#b树和b树的区别)
  - [长字符串找短字符串，可以使用hash吗](#长字符串找短字符串可以使用hash吗)
  - [各种排序的思路冒泡-快排-归并](#各种排序的思路冒泡-快排-归并)
  - [TCP与UDP的区别](#tcp与udp的区别)
    - [TCP 包过大会怎样](#tcp-包过大会怎样)
- [20200514](#20200514)
  - [MySQL存储引擎](#mysql存储引擎)
  - [大小端怎么判断](#大小端怎么判断)
  - [`void*` 可以直接输出值吗](#void-可以直接输出值吗)
  - [timewait状态多久，为什么要有](#timewait状态多久为什么要有)
  - [B+树一个节点有多大？一千万条数据，B+树多高？](#b树一个节点有多大一千万条数据b树多高)
  - [1亿数据数组找最大10万个](#1亿数据数组找最大10万个)
  - [STL中hashTable的实现](#stl中hashtable的实现)
- [20150516](#20150516)
  - [五层协议，每层都有哪些协议](#五层协议每层都有哪些协议)
  - [TCP怎么保证可靠传输的](#tcp怎么保证可靠传输的)
  - [说一下`TCP`怎么进行拥塞控制的？](#说一下tcp怎么进行拥塞控制的)
  - [静态多态和动态多态](#静态多态和动态多态)
  - [C++虚函数相关，虚函数的实现原理](#c虚函数相关虚函数的实现原理)
  - [虚函数表是如何实现动态绑定的](#虚函数表是如何实现动态绑定的)
  - [多态时候基类的sizeof，子类的sizeof](#多态时候基类的sizeof子类的sizeof)
  - [为什么成员函数不占用类的空间](#为什么成员函数不占用类的空间)
- [好未来实习面试准备](#好未来实习面试准备)
  - [对好未来产品的认识](#对好未来产品的认识)
  - [设计一个在线教育平台需要有哪些功能需求](#设计一个在线教育平台需要有哪些功能需求)
  - [非阻塞connect实现](#非阻塞connect实现)
  - [程序编译过程](#程序编译过程)
  - [静态库和动态库](#静态库和动态库)
    - [静态库](#静态库)
    - [共享库/动态库](#共享库动态库)
  - [写一个不能复制的类](#写一个不能复制的类)
  - [说一下`C++`里的智能指针](#说一下c里的智能指针)
    - [智能指针出现循环引用怎么解决？](#智能指针出现循环引用怎么解决)
  - [select和epoll的区别](#select和epoll的区别)
  - [https建立的过程](#https建立的过程)
  - [DNS解析](#dns解析)
  - [`DNS`解析过程](#dns解析过程)
  - [什么时候用多进程，什么时候用多线程](#什么时候用多进程什么时候用多线程)
  - [一个进程都分为那些内存空间](#一个进程都分为那些内存空间)

## 20210511

-----

### 堆和栈的区别

* 栈，栈由系统自动分配，存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
* 堆，是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
* 堆的生长空间向高地址生长的，地址越来越大，栈的生长空间向低地址生长的，地址越来越小
* 栈相对于堆来说会快一点，因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，堆在分配和释放时都要调用函数（`malloc,free`)。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

### 指针和引用的区别

* 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作
* 指针可以有多级，引用只有一级
* 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改
* 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小
* 指针可以为空，引用不可以。
* 引用一旦进行初始化之后，不会再改变其指向；但指针可以

### TCP三次握手四次挥手，timewait多了怎么解决

#### 三次握手

- 第一次握手：

客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号`ISN`(比如是`100`)，那客户端向服务端发送的报文段包含同步序号`SYN`标志位(也就是`SYN=1`)，序列号`seq=100`。

这时候`client`处于同步状态`SYN_SENT`。也就是可以建立连接。服务端处于监听状态`LISTEN`。

- 第二次握手

服务端收到客户端发过来的报文后，发现同步序号`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1`,`ACK=1`)、序列号`seq=300`、确认号`ack=101`(*客户端发过来的序列号+1*)。

  这个时候服务端处于`SYN_RECV`同步接收状态。

- 第三次握手

客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(*服务端序列号+1*)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。

> 上面过程中，**第三次捂手是可以携带数据的，前两次握手不可以携带数据。**

#### 四次挥手

> 四次挥手的目的是关闭一个连接

当我们的应用程序不需要数据通信了，就会发起断开 `TCP` 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

假如客户端先发起关闭请求。

- 第一次挥手。客户端向服务端发送一个 FIN 报文，报文中会指定一个序号（假如`seq = u`)，这个时候客户端处于终止等待1 `FIN_WAIT_1` 状态，客户端会停止发送数据，主动关闭 TCP 连接，并等待服务端确认。

- 第二次挥手，服务端收到客户端的 FIN 报文后，就知道这是一个关闭请求。然后服务端向客户端返回一个确认报文，包含确认序号`ACK = 1`，`ack = seq + 1`,也就是`u+1`,并带上自己的序号`squ = v`,这时候服务端处于终止等待`CLOSE_WAIT` 状态，客户端进入`FIN_WAIT_2` 状态。TCP 处于半关闭状态，因为客户端不会发送数据了，不过服务器端有数据发送的话，客户端依然需要接收。

- 第三次挥手，如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。也就是服务端没有数据要向客户端发送了，服务端发出**连接释放报文段**包含（`FIN=1`，`ACK=1`，序号`seq=w`，确认号`ack=u+1`），服务端进入` LAST_ACK`（最后确认）状态，等待客户端的确认。

- 第四次挥手。客户端收到服务器的 `FIN` 包后，向服务端返回确认报文（`ACK=1，ack=w+1`），这个时候客户端就进入了 `TIME_WAIT` （时间等待）状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 `TCP` 连接的时间要比客户端早一些。

> 客户端：FIN_WAIT_1 --> FIN_WAIT_2 --> TIME_WAIT

> 服务端：LISTEN --> CLOSE_WAIT --> LAST_ACK --> CLOSED

----

## 20210512

----

### 同步io和异步io

- **同步**：

所谓同步，是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。

例如普通`B/S`模式（同步）：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事

- **异步**：

异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过 状态、通知和回调 来通知调用者。

例如 `ajax`请求（异步）: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕

### 优化数据库

高频访问：

* 分表分库：将数据库表进行水平拆分，减少表的长度
* 增加缓存： 在web和DB(数据库)之间加上一层缓存层
* 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题

并发优化：

* 主从读写分离：只在主服务器上写，从服务器上读
* 负载均衡集群：通过集群或者分布式的方式解决并发压力

### B树和B+树的区别

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/Bptree.6qj0kx0hs900.png)

这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。

1. **关键字的数量不同**；B+树中分支结点有m个关键字，它的孩子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
2. **存储的位置不同**；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
3. `B+`树的所有叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。
4. **查询不同**；B树在找到具体的数值以后，则结束，而`B+`树则需要通过索引找到叶子结点中的数据才结束，也就是说`B+`树的搜索过程中走了一条从根结点到叶子结点的路径。

B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便查询，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来查找，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。

### 长字符串找短字符串，可以使用hash吗

> 长字符串找短字符串 的方法

- 暴力破解

一种幼稚的做法是轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要$O(n* m)$次操作，其中`n`是`string1`的长度，`m`是`string2`的长度。就拿上面的例子来说，最坏的情况下将会有$16*8 = 128$次操作。

- 排序后匹配

一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)$O(m log m) + O(n log n)$次操作，之后的线性扫描需要$O(m+n)$次操作。同样拿上面的字串做例子，将会需要$164 + 83 = 88$加上对两个字串线性扫描的$16 + 8 = 24$的操作。(随着字串长度的增长，你会发现这个算法的效果会越来越好)

- hashtable匹配

最终，有一个最佳的算法，只需要$O(n+m)$次操作。方法就是，对第一个字串进行轮询，把其中的每个字母都放入一个`Hashtable`里(成本是$O(n)$或16次操作)。然后轮询第二个字串，在`Hashtable`里查询每个字母，看能否找到。如果找不到，说明没有匹配成功。这将消耗掉8次操作 —— 这样两项操作加起来一共只有24次。不错吧，比前面两种方案都要好。

### 各种排序的思路冒泡-快排-归并

* [常见排序算法](/寻offer总结/数据结构_场景应用/排序算法.md)

### TCP与UDP的区别

- 1.`TCP`面向连接，`UDP`无连接。
- 2.`TCP`面向字节流（文件传输），`UDP`是面向报文的，`UDP`没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（比如`IP`电话，实时视频会议等）。
- 3.`TCP`首部开销`20`字节，UDP的首部开销小，只有8个字节。
- 4.`TCP`的逻辑通信信道是全双工的可靠信道，提供可靠的服务。也就是说，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且有序到达; `UDP`是不可靠信道，`UDP`只是尽最大努力交付，并不保证可靠交付。
- 5.每一条`TCP`连接只能是点到点的；`UDP`支持一对一，一对多，多对一和多对多的交互通信。
- 6.`TCP`对系统资源的要求高于`UDP`，所以速度也比`UDP`慢。
- 7.`TCP`数据包是没有边界的，会出现粘包的问题，`UDP`包是独立的，不会出现粘包问题。
- 所以在应用方面，如果强调数据的完整性和正确性用`TCP`，当要求性能和速度的时候，使用`UDP`更加合适。

#### TCP 包过大会怎样

> TCP UDP 数据包过大导致分片

`MTU`大家都知道，是链路层中的网络对数据帧的一个限制，以太网为例，`MTU`为`1500`个字节。一个IP数据报在以太网中传输，如果它的长度大于该`MTU`值，就要进行**分片传输**，使得每片数据报的长度小于`MTU`。不过分片传输的`IP`数据报不一定按序到达，但`IP`首部中的信息能让这些数据报片按序组装。`IP`数据报的分片与重组是在网络层进完成的。

**MSS（最大分段大小）**

`MSS`是`TCP`首部的一个字段，`MSS`是`TCP`数据包每次能够传输的最大数据分段，`TCP`报文段的长度大于`MSS`时，要进行分段传输。`MSS`选项只出现在`SYN`报文段中，即`TCP`三次握手的前两次。`MSS`的值一般为`MTU`值减去两个首部大小。 

再来看`UDP`数据报，由于`UDP`数据报不会自己进行分段，因此当长度超过了`MTU`时，会在网络层进行`IP`分片。同样，`ICMP`（在网络层中）同样会出现`IP`分片情况。  

**总结：`UDP`不会分段，就由`IP`来分。`TCP`会分段，当然就不用`IP`来分了！**

> PS: **内核缓冲区总是充满数据时会产生粘包问题**

-------

## 20200514

### MySQL存储引擎

存储引擎是`MYSQL`的核心技术，不同的存储引擎使用不同的存储机制、索引技巧、锁定水平并最终提供不同的功能和能力。常见的引擎分为三种：**InnoDB存储引擎（MYSQL默认的事务性引擎）、MyISAM存储引擎、Memory存储引擎**。

* InnoDB ： `InnoDB`是`mysql`的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁

* MyISAM ： 插入和查询速度比较快，支持大文件，但是不支持事务，适合在`web`和数据仓库场景下使用  表级锁

* MEMORY ： `memory`将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景

### 大小端怎么判断

计算机有两种存储数据的方式:**大端字节序** （big endian）和**小段字节序**（little endian）。

比如：数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11

> - 大端字节序：高位字节在前面，低位字节在后面,这符合人类的读写数值方法
> - 小端字节序：地位字节在前面，高位字节在后面。

**为什么会有小端字节序？**

计算机都是从低位开始处理字节效率比较高，因为计算都是从低位开始的，因此计算机内部都是小端字节序。            
但是人类比较习惯大端字节序，所以除了计算机内部处理，其他场合一般都用大端字节序，比如网络参数，文件存储。

计算机在处理字节序的时候是按照顺序读取字节的，**如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。**

### `void*` 可以直接输出值吗

- `void *` 可以定义一个指针变量，但不说明它指向哪一种类型数据.

- 使用`void *`表示该函数指针可以不用指定为某种特定类型。例如，在套接字函数中，`send(void * pData, int nLength)`这意味着您可以通过多种方式调用它，`pData` 可以是字符串，甚至可以是一个对象。例如
  
  ```c
  char * data = "blah";
  send(data, strlen(data));
  POINT p;
  p.x = 1;
  p.y = 2;
  send(&p, sizeof(POINT));
  ```

- 指向`0`的地址,`(void *)0`，指向全是`0`的地址，相当于`NULL`。

- 可执行 赋值，取值操作，但**不能用于指定数据输出**，因为没有指定要输出的数据长度，如果可以输出，那么将会是一个无限长的输出。

### timewait状态多久，为什么要有

`TIME_WAIT`是指四次挥手中客户端接收了服务端的`FIN`报文并发送`ACK`报文给服务器后，仍然需要等待`2MSL`时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入`CLOSED`状态了，但是我们必须假设网络是不可靠的，有可能最后一个`ACK`丢失。如果客户端发送的`ACK`发生丢失，服务器会再次发送`FIN`报文给客户端，所以`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。

### B+树一个节点有多大？一千万条数据，B+树多高？

B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 `<` 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。

在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是`16k`。之所以设置为一页，是因为对于大部分业务，一页就足够了：

首先 InnoDB 的 B+ 树中，非叶子节点存的是`key` + 指针；叶子节点存的是数据行。

- 对于叶子节点，如果一行数据大小为`1k`，那么一页就能存`16`条数据；
- 对于非叶子节点，如果`key`使用的是`bigint`，也就是为`8`字节，指针在`mysql`中为`6`字节，一共是`14`字节，则`16k`能存放 $16 * 1024 / 14 = 1170$ 个索引指针。

于是可以算出，对于一颗高度为`2`的`B+`树，根节点存储索引指针节点，那么它有`1170`个叶子节点存储数据，每个叶子节点可以存储`16`条数据，一共 $1170 * 16 = 18720$ 条数据。

而对于高度为`3`的B+树，就可以存放 $1170 x 1170 x 16 = 21902400$ 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为`3`的`B+`树就可以完成，通过主键查询只需要`3`次`IO`操作就能查到对应数据。所以在 InnoDB 中`B+`树高度一般为`3`层时，就能满足千万级的数据存储，所以一个节点为`1`页，也就是`16k`是比较合理的。

### 1亿数据数组找最大10万个

> 分治+最小堆，hash进行优化重复数据

**问题一**：有 10 亿个不重复的数字，内存中只能放进 1 万个数，怎么找到最大的 10 万个数字？

这道题的思路是，先拿 1w 个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的 c 个数就是所需的最大的 1w 个。

**复杂度分析**

建堆时间复杂度是`O(m)`，堆调整的时间复杂度是`O(logm)`，最终时间复杂度等于，1次建堆时间+n次堆调整时间=`O(m+nlogm)=O(nlogm)`
这里的n为`10`亿，`m`为`1w`

**优化的方法**

可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。


关于海量数据问题：

https://blog.csdn.net/hitxueliang/article/details/52153476

https://blog.csdn.net/sinat_42483341/article/details/108277388

### STL中hashTable的实现

STL中的`hashtable`使用的是**开链法**解决`hash`冲突问题，`hashtable`表内的元素称为桶（`bucket`),而由桶所链接的元素称为节点（`node`), 如下图所示。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/哈希表01.2oeu7i4l7fo.png)

`HashTable` 中的 `bucket` 维护的 列表不是`list`，也不是 `slist`，而是自己定义的 `hashtable_node` 数据结构组成的`linked-list`,并使用`vector`存放桶元素。`hashtable`的迭代器只提供前进操作，不提供后退操作.

`hashTable` 中的 `bucket` 是由28个质数`[53, 97, 193,...,429496729]`实现的，在创建`hashtable`时，会根据存入的元素个数选择大于等于元素个数的质数作为`hashtable`的容量（也就是`vector`的长度），其中每个`bucket`所维护的`linked-list`长度也等于`hashtable`的容量。如果插入`hashtable`的元素个数超过了`bucket`的容量，就要进行重建`table`操作，也就是找出下一个质数，创建新的`buckets vector`，重新计算元素在新`hashtable`的位置。

----------

## 20150516

### 五层协议，每层都有哪些协议

每一层的作用：

- 物理层：负责底层数据传输，就是为数据链路层提供二进制传输服务。如网线；网卡标准。 （比特`Bit`）

- 数据链路层：接收来自物理层的数据，并封装成帧，传送到网络层；如网卡`MAC`地址。（帧Frame），ARP，STP

- 网络层：定义`IP`编址，定义路由选择功能；如不同设备的数据转发。（包Packet），IP，ICMP

- 传输层：主要负责端到端之间传输数据；如 `TCP`、`UDP`。（段 Segments）

- 会话层：负责在网络中的两节点之间建立、维持和终止通信；如一个软件的数据分发给另一个软件。

- 表示层：数据格式标识，基本压缩加密功能。

- 应用层：各种应用软件，包括 `Web` 应用。HTTP，HTTPS，DNS，RTMP

### TCP怎么保证可靠传输的

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：`TCP`报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：`tcp`会按最大传输单元(MTU)合理分片，接收方如果收到的数据不按顺序的时候，就会对它重新排序再交给应用层。
  - 而对于UDP：`IP`数据报如果大于1500字节，也就是大于`MTU`。这个时候就会对数据包进行分片，让每一片都少于`MTU`，由于`UDP`的特性，有些分片会被丢弃，所以导致最终无法重组数据包，导致丢弃整个`UDP`数据报。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

> 拥塞控制有四种算法，**慢启动、拥塞避免，快速重传和快速恢复**

### 说一下`TCP`怎么进行拥塞控制的？

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

`TCP` 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快速重传、快速恢复**。

- **慢启动**。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即`1、2、4、8、16`
  
  * 为了防止拥塞窗口`cwnd`增长过大引起网络拥塞，还要另外设置一个慢启动阈值`ssthresh`状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ `cwnd > ssthresh` 时），停止使用慢启动算法而改用拥塞避免算法。

- **拥塞避免**：设置慢启动阈值，一般开始都设为`65536`。拥塞避免是指当拥塞窗口大小达到这个阈值的时候，拥塞窗口的值不再指数上升，而是采用加法增加（也就是每经过一个往返时间`RTT`就把发送方的拥塞窗口大小`+1`），以此来避免拥塞。

- **快速重传**：当发送端连续收到三个重复的`ack`时，表示该数据段已经丢失，需要重发。这个时候慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd`变为`ssth+3`，然后使用`+1+1`的发（也就是每一轮`RTT`就+1）

- **快速恢复**。当超过设定的时间没有收到某个报文段的`ack`时，表示网络拥塞，慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd=1`，进入慢启动阶段。

### 静态多态和动态多态

- **静态多态**

静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。
静态多态有两种实现方式：

  1.函数重载：包括普通函数的重载和成员函数的重载

  2.函数模板的使用

- **动态多态**（动态绑定）

即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法

**C++是依靠虚函数来实现动态多态的**

### C++虚函数相关，虚函数的实现原理

虚函数：在基类的函数前加上`virtual`关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.

**`C++`的虚函数是实现多态的机制**。它是通过虚函数表和虚表指针实现的，虚表是一个指针数组，它存放着指向虚函数的指针，类的实例在调用虚函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。[也就是 ==> 实现编译器处理虚函数表应该如何处理](#实现编译器处理虚函数表应该如何处理)

### 虚函数表是如何实现动态绑定的

>  虚函数的动态绑定是利用虚表和虚表指针类实现的

假如有一个类 B 继承另一个类 A ，如果基类 A 中有包含了虚函数，那么继承类 B 就可以调用基类 A 的虚函数，也就是说一个类继承了包含虚函数的基类，那么这个类就应有自己的虚表。

我们来看以下的代码。类 A 包含虚函数`vfunc1`，`vfunc2`，由于类 A 包含虚函数，故类 A 拥有一个虚表。

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

![虚函数表01](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表01.png)

**虚表是一个指针数组，它存放着指向虚函数的指针**，普通函数也就非虚函数，它的调用不需要经过虚表，所以虚表中并没有存放指向非虚函数的指针。

为了指定对象的虚表，对象中包含一个指向虚表的指针，指向自己的虚表，为了让每个包含虚表的类的对象都用一个虚表指针，编译器在类中添加一个指针`*__vptr`，每个类创建的对象的时候这个指针默认指向类的虚表。

![虚函数表02](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表02.png)

一个继承类的基类如果包含虚函数，那这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。

**那么C++ 是如何利用虚表和虚表指针来实现动态绑定的呢**？

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类 A 是基类，类 B 继承类 A，类 C 又继承类 B。类 A，类 B，类 C，其对象模型如下图所示。

![虚函数表03](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表03.png)

由于这三个类都有虚函数，所以编译器为每个类都创建了一个虚表，即类 A 的虚表（`A vtbl`），类 B 的虚表（`B vtbl`），类 C 的虚表（`C vtbl`）。类 A，类 B，类 C 的对象都拥有一个虚表指针，`*__vptr`，用来指向自己所属类的虚表。

类 A 包括两个虚函数，故 `A vtbl` 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 `B vtbl` 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 `C vtbl` 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。

综上所诉，对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向它继承的最近的一个类的虚函数。

非虚函数的调用不用经过虚表，所以不需要虚表中的指针指向这些函数

### 多态时候基类的sizeof，子类的sizeof

根据虚函数的工作机制，通常编译器处理虚函数时会给对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，因此类中添加虚函数后，sizeof(类名)应为该指针的大小。

> https://blog.csdn.net/weixin_42067304/article/details/108547910

### 为什么成员函数不占用类的空间

> https://blog.csdn.net/weixin_39888807/article/details/111103858

-------

## 好未来实习面试准备

### 对好未来产品的认识

学而思网校，学而思培优，挺好用的。我的堂弟堂妹都在用。

### 设计一个在线教育平台需要有哪些功能需求

- 学习功能，学生利用在线教育系统完成浏览课程信息，浏览实验信息，浏览课程内容，下载教学资源等功能。
- 交流功能，与现实中的教育一样，学生有可能会遇到各种自己无法解决的问题，就需要向别人求助，设计一个在线留言板就能够很好的解决这个问题，它能方便用户之间的交流，提高学习的效率-。
- 在线练习，学生熟悉课程内容之后，可以在系统上选择在线练习，这样学生可以通过练习使得自己得到提高，并且在完成试题后，可以随即查到所有试题的答案。
- 后台管理，在线学习平台的内容是不断更新的，这就需要教师适时的更新，这要求教师及时添加相关最新教学资源，同时及时反馈学生的问题，这样方便师生之间的交流。

### 非阻塞connect实现

在广域网中，connect函数可能需要比较长的时间返回（等待对端发送ack），所以我们通常需要非阻塞connect。

-  fcntl 函数可以将一个socket 句柄设置成非阻塞模式: 
-  采用信号处理函数设置阻塞超时控制。

- 第一步:创建socket,返回套接口描述符;
- 第二步:调用fcntl把套接口描述符设置成非阻塞;
- 第三步:调用connect开始建立连接;
- 第四步:判断连接是否成功建立;

A:如果`connect`返回0,表示连接简称成功(服务器可客户端在同一台机器上时就有可能发生这种情况);

B:调用`select`来等待连接建立成功完成;

如果`select`返回`0`,则表示建立连接超时;我们返回超时错误给用户,同时关闭连接,以防止三路握手操作继续进行下去;

如果`select`返回大于0的值,则需要检查套接口描述符是否可读或可写;如果套接口描述符可读或可写,则我们可以通过调用`getsockopt`来得到套接口上待处理的错误(`SO_ERROR`),如果连接建立成功,这个错误值将是0,如果建立连接时遇到错误,则这个值是连接错误所对应的`errno`值(比如:`ECONNREFUSED`,`ETIMEDOUT`等).

> http://blog.chinaunix.net/uid-20205875-id-5761482.html

```c

bool nonblockingConnect(const char* ip, short port, int timeout = 3)
{
	int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (fd == -1)
    {
        cout << "create socket failed" << endl;
        return false;
    }
 
    //设置非阻塞
	int flag = fcntl(fd, F_GETFL, 0);
	if (fcntl(fd, F_SETFL, flag | O_NONBLOCK) == -1)
	{
		cout << "fcntl failed" << endl;
		close(fd);
		return false;
	}
 
	struct sockaddr_in srvAddr;
	memset(&srvAddr, 0, sizeof(struct sockaddr_in));
	srvAddr.sin_addr.s_addr = inet_addr(ip);
	srvAddr.sin_port = htons(port);
	srvAddr.sin_family = AF_INET;
 
    //为了处理EINTR,将connect放在循环内
    while (1)
    {
        int ret = connect(fd, (sockaddr*)&srvAddr, sizeof(struct sockaddr_in));
        if (ret == 0)
        {
            cout << "connect successfully" << endl;
            return true;
        }
        else if (ret == -1)
        {
            if (errno == EINTR)
            {
                cout << "signal interrupt" << endl;
                continue;
            }
            else if (errno != EINPROGRESS)
            {
                cout << "can not connect to server, errno: " << errno << endl;
                close(fd);
                return false;
            }
            else
            {
                break;
            }
        }
 
    }
 
	fd_set wfds;
    FD_ZERO(&wfds);
    FD_SET(fd, &wfds);
	timeval tv = { timeout, 0 };
 
	int ret = select(fd + 1, nullptr, &wfds, nullptr, &tv);
	if (ret <= 0)
	{
		cout << "can not connect to server" << endl;
		close(fd);
		return false;
	}
 
	if (FD_ISSET(fd, &wfds))
	{
		int error;
		socklen_t error_len = sizeof(int);
		ret = getsockopt(fd, SOL_SOCKET, SO_ERROR, &error, &error_len);
		if (ret == -1 || error != 0)
		{
			cout << "getsockopt connect failed, errno: " << errno << endl;
			return false;
		}
 
        /**
        * 在linux下，select返回fd可写，有两种情况：1.连接成功，2.发生错误
        * getsockopt返回error为0则排除错误情况，连接已建立
        */
        cout << "connect successfully" << endl;
 
        while (1)
        {
            int send_len = 0;
            const char buf[] = "hello\n";
 
            if ((send_len = send(fd, buf, sizeof(buf), 0)) == -1)
            {
                cout << "send failed";
                return false;
            }
            cout << "send len: " << send_len << endl;
            sleep(3);
        }
 
        return true;
    }
 
    cout << "can not connect to server, errno: " << errno << endl;
	close(fd);
	return false;
}
```

### 程序编译过程

> 执行 `gcc HelloWorld.c -o HelloWorld` 的过程

其实，GCC 只是完成编译工作的驱动程序，它会根据编译流程分别调用**预处理程序**、**编译程序**、**汇编程序**、**链接程序**来完成具体工作。

下图就是编译这段代码的过程：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：

- `gcc HelloWorld.c -E -o HelloWorld.i` **预处理**：加入头文件，替换宏。将源文件生成**预处理文件**。
- `gcc HelloWorld.i -s -c HelloWorld.s` **编译**：预处理文件生成**编译文件**。
- `gcc HelloWorld.s -c HelloWorld.o` **汇编**：将编译文件生成**汇编文件**。
- `gcc HelloWorld.o -o HelloWorld` **链接**：汇编文件生成**可执行文件**


### 静态库和动态库

#### 静态库
静态库可以认为是一些目标代码的集合, 是在可执行程序运行前就已经加入到执行码中, 成为执行程序的一部分. 按照习惯, 一般以`.a`做为文件后缀名.

静态库的命名一般分为三个部分：
- 前缀：lib
- 库名称：自定义即可, 如test
- 后缀：.a

所以最终的静态库的名字应该为：`libtest.a`

#### 共享库/动态库

共享库在程序编译的时候是不会被连接到目标代码中, 而是在程序运行是才被载入。 **不同的应用程序如果调用相同的库, 那么在内存里只需要有一份该共享库的拷贝, 规避了空间浪费问题。** 动态库在程序运行时才被载入, 也解决了静态库对程序的更新、部署和发布会带来麻烦. 用户只需要更新动态库即可, 增量更新。为什么需要动态库, 其实也是静态库的特点导致。
按照习惯, 一般以”.so”做为文件后缀名. 共享库的命名一般分为三个部分：
- 前缀：lib
- 库名称：自己定义即可, 如test
- 后缀：.so

所以最终的静态库的名字应该为：`libtest.so`

### 写一个不能复制的类

老式写法

```cpp

class noncopyable
{
protected:
	noncopyable() {}
	~noncopyable() {}
private:
	noncopyable( const noncopyable& );
	noncopyable& operator=( const noncopyable& );
```

C++ 11 写法

```cpp

class noncopyable
{
protected:
	constexpr noncopyable() = default;
	~noncopyable() = default;
	noncopyable( const noncopyable& ) = delete;
	noncopyable& operator=( const noncopyable& ) = delete;
};
```

### 说一下`C++`里的智能指针

 `C++`里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是c++11支持，并且第一个已经被`c++11`弃用。

 使用原因：智能指针的作用是管理一个指针，因为在程序设计中动态分配的堆内存没有正确释放或无法释放，导致资源浪费，程序运行速度变慢等问题。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- `unique_ptr`：实现独占式模式，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以`new`创建对象后因为发生异常而忘记调用`delete`”)特别有用，可以通过标准库的`move()`函数实现指针转移。

- `shared_ptr`：实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字`share`就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。

- `weak_ptr`：是一种不控制对象生命周期的智能指针, `weak_ptr` 设计的目的是为配合 `shared_ptr` 而引入的一种智能指针来协助 `shared_ptr` 工作, 它只可以从一个 `shared_ptr` 或另一个 `weak_ptr` 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

更详细的C++智能指针分析见《[C++智能指针](/C++随记/07C++智能指针)》

#### 智能指针出现循环引用怎么解决？

弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。

### select和epoll的区别

[IO多路复用](/寻offer总结/linux编程/IO多路复用相关.md)

### https建立的过程

`https`包括**非对称加密**和**对称加密**两个阶段，在客户端与服务器建立连接的时候使用**非对称加密**，连接建立以后使用的是**对称加密**。

（1）客户端向服务器端发起`SSL`连接请求；<br>
（2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥<br>
（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端<br>
（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，<br>
（5）进行数据传输，服务器和客户端用相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，也就是即使第三方获得数据包，也无法对其进行加密，解密和篡改。<br>

### DNS解析

### `DNS`解析过程

如下图所示，详细阐述`DNS`解析流程。

![](./img/dns-02.jpeg)

- 客户机提出域名解析请求，并将该请求发送给本地的域名服务器。

- 当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该记录项，则本地的域名服务器就直接把查询的结果返回。

- 如果没有，就到互联网中根服务器去查找，获取`.com`的顶级域名服务器

- 然后在`.com`的顶级域名服务器中进行查找，比如说获取`google.com`的授权域名服务器

- 在`google.com`的授权域名服务器中查找主机`www.google.com`的`IP`地址，最后将`IP`地址返回给计算机。

- 计算机获得`www.google.com`的`IP`地址后，用户就可以访问这个网站了。

### 什么时候用多进程，什么时候用多线程

https://blog.csdn.net/yu876876/article/details/82810178

* 频繁修改：需要频繁创建和销毁的优先使用**多线程**
* 计算量：需要大量计算的优先使用**多线程**  因为需要消耗大量`CPU`资源且切换频繁，所以多线程好一点
* 相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用**多进程**。因为线程之间的数据共享和同步比较简单。
* 多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。

但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。

### 一个进程都分为那些内存空间

Linux进程可分为五部分：

代码区：存放可执行的指令操作，只能读不能写

全局区：存放未初始化的静态变量和全局变量

数据区：存放初始化的静态变量和全局变量

栈：存放临时变量，函数参数等

堆：存放new/malloc等动态申请的变量，用户必须手动进行delete/free操作