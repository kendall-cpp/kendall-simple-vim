

---- 

## 怎么使用多线程机实现录制和播放

如果录制和播放都放在主线程中执行的话，就会造成界面一直处于阻塞状态，所以就将播放和录制的逻辑放在子线程中执行，当线程启动的时候就会自动调用 run 函数。这样就可以用多个线程分别处理不同的任务。

## 播放 PCM

播放 PCM 使用的是多媒体开发库 SDL 来实现的，播放的步骤是

- 先初始化子系统，就是调用 SDL_Init 函数，传入的参数决定播放音频还是视频

- 接着是调用 SDL_OpenAudio 开发音频设备，

查看音频设备可以通过 ffmpeg 命令查看

```
./ffmpeg.exe -f dshow -list_devices true -i dunmy
```

SDL_OpenAudio 这个函数插进去的是一个 SDL_AudioSpec 的结构体，这个结构体中包含音频的各种数据，比如采样率，频道等等。

- 打开文件开始播放 PCM 数据

然后播放 PCM 数据在 SDL 有两种方式

1.一种是 push, 程序主动推送数据给音频设备

2.另一种是 pull，音频设备主动从程序中拉取数据

> 这里选择第二种

- 最后调用 SDL_Quit 清楚子系统释放资源

## H264 编码

原始视频如果不经过压缩的话是会占用很大内存的，由于网络带宽和硬盘存储空间都非常有限，需要先试用视频编码技术对原始视频进行压缩，然后再进行存储和分发。H264 的压缩比率大概是 100：1

- 编码器采用的是 X264，在 ffmpeg 中的名称是 libx264

- 解码器采用的是 ffmpeg 默认内置的 H264 解码器。名称就是 h264


### 谈谈FFmpeg的解码流程，说说你能够认识的函数作用

https://zhuanlan.zhihu.com/p/126693434


> 比如说从本地读取 AAC 码流，然后解码

大致流程

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/音频解码01.4mvaz31l8xe0.png)

解码需要理解四个结构体`AVStream`、 `AVPacket` 和 `AVFrame` 以及 `AVCodecContext`， 其中`AVPacket` 是存放是编码格式的一帧数据， `AVFrame` 存放的是解码后的一帧数据。 解码的过程其实就是从`AVCodecContext` 取出一个`AVPacket` 解码成 `AVFrame`的过程。


![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/音频解码02.3d4aphvcp5y0.jpg)

- `avcodec_register_all()`：注册所有的编解码器。「新版本不需要这步」
- `avcodec_find_decoder`：根据指定的`AVCodecID`查找注册的解码器。
- `av_parser_init`：初始化`AVCodecParserContext`。返回的是  `AVCodecParserContext`
- `avcodec_alloc_context3`：为`AVCodecContext`分配内存。
- `avcodec_open2`：打开解码器。
- `av_parser_parse2`：解析获得一个`Packet`。
- `avcodec_send_packet`：将`AVPacket`压缩数据给解码器。
- `avcodec_receive_frame`：获取到解码后的`AVFrame`数据。
- `av_get_bytes_per_sample`: 获取每个`sample`中的字节数。



## 基于 VideoToolbox 来实现 H264 硬编码和硬解码

### H264 硬编码

> https://zfpp25.blog.csdn.net/article/details/108219421

iOS8.0及以上我们可以通过 VideoToolbox 实现视频数据的硬编解码。

基本步骤

- 1、通过 VTCompressionSessionCreate 创建编码器
- 2、通过 VTSessionSetProperty 设置编码器属性
- 3、设置完属性调用 VTCompressionSessionPrepareToEncodeFrames 准备编码
- 4、输入采集到的视频数据，调用 VTCompressionSessionEncodeFrame 进行编码
- 5、获取到编码后的数据并进行处理
- 6、调用 VTCompressionSessionCompleteFrames 停止编码器
- 7、调用 VTCompressionSessionInvalidate 销毁编码器

> 创建编码器 --> 设置编码器的属性 --> 然后准备进行编码 --> 接着是对编码后的数据进行处理 --> 最后还需要 停止和销毁编码器     
> 主要是用 `VTCompressionSession` 下的几个函数

#### 遇到难题

在弄视频编解码的时候，发现720P的分辨率，码率1Mbps，在画面晃动的时候马赛克很严重，码率设置的再低一点更严重。一开始我以为是编码器的某些属性漏了设置了，或者是参数设置错了。查阅了很多资料都找不到原因。后来怀疑是ABR模式当画面从静止到晃动码率一下子上不去，导致马赛克，这个假设似乎成立，结果去打印编码出来的码率，画面晃动的时候码率是有上去的，说明这个思路还是不对。后来，我发现，摄像头采集的数据是720P，也就是1280x720的分辨率，我给编码器设置编码宽高的时候也是按1280x720的宽高设给编码器的，但实际上我解码、播放是展示的画面尺寸(像素)只有320x180，于是我尝试了一下把编码的宽高设置为320x180，马赛克问题解决了！

### H264 硬解码

> https://zfpp25.blog.csdn.net/article/details/108219440

硬解码流程很简单：
- 1、解析H264数据
- 2、初始化解码器（VTDecompressionSessionCreate）
- 3、将解析后的 H264 数据送入解码器（VTDecompressionSessionDecodeFrame）
- 4、解码器回调输出解码后的数据（CVImageBufferRef）


## ffmpeg 部分源码


ffmpeg博客：https://www.cnblogs.com/leisure_chn/category/1351812.html

### ffmpeg 源码中内存管理

> https://blog.csdn.net/King1425/article/details/70613310

`av_malloc()`: 是内存分配函数，`av_malloc() `就是简单的封装了系统函数malloc()，并做了一些错误检查工作。

`av_realloc()`用于对申请的内存的大小进行调整. `av_realloc()` 简单封装了系统的`realloc()`函数。


`av_free()`用于释放申请的内存,`av_free()` 简单的封装了`free`

`av_freep()`简单封装了`av_free()`。并且在释放内存之后将目标指针设置为 NULL

### AVFormatContext 和 AVInputFormat之间的关系

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/ffmpeg数据结构04.fnx3k76bak0.png)


`AVInputFormat`被封装在`AVFormatContext`里

`AVFormatContext` 作为`API`被外界调用

`AVInputFormat` 主要是`FFmpeg`内部调用

`AVFormatContext`里保存了视频文件封装格式相关信息，它是负责储存数据的结构体。而`AVInputFormat`代表了各个封装格式，属于方法，这是一种面向对象的封装。
 
通过 `int avformat_open_input(AVFormatContext **ps, const char *filename,AVInputFormat *fmt, AVDictionary **options)`函数装载解封装器.

