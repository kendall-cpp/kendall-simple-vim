- [静态变量](#静态变量)
  - [怎么使用静态变量](#怎么使用静态变量)
  - [为什么使用宏函数](#为什么使用宏函数)
  - [介绍一下工厂模式](#介绍一下工厂模式)
    - [简单工厂模式](#简单工厂模式)
    - [工厂方法模式](#工厂方法模式)
    - [抽象工厂模式](#抽象工厂模式)
- [死亡测试](#死亡测试)
  - [死亡测试运行方式](#死亡测试运行方式)
  - [detach 函数](#detach-函数)
    - [怎么进行测试](#怎么进行测试)
  - [说一下`C++` 的智能指针](#说一下c-的智能指针)
    - [RAII 是什么](#raii-是什么)

-------

## 静态变量

- 函数内部定义一个局部对象时，使用 static 关键字时，这个变量就保存在静态存储区，在编译的时候初始化，如果不给初始化值，它的值就会被初始化为 0，并且，下次调用这个函数的时候该变量中保存的值就是上一次函数调用结束时的值

- 在全局变量时使用 static 关键字，那么这个全局变量只能在本文件中使用，无法在其他文件中被引用。

- 在函数之前加 static 时，那么函数只能在本源程序文件中调用，无法在其他源程序文件中调用。

- 在一个类中定义 static 成员，那么这个成员不属于某个对象，而是属于整个类。

> 编译阶段初始化，全局变量，函数，对象

### 怎么使用静态变量

在实现测试用例的自动保存的时候，会用一个宏函数 [`GTEST_TEST_CLASS_NAME_`]，这个宏函数里面有一个静态变量 test_info_ ，它利用”静态变量在程序运行前被初始化“的特性，抢在 main 函数执行之前，执行一段代码，从而有机会将测试用例放置于一个固定的位置。这个是”自动“保存测试用例的本质所在。

然后就是 test_info_ 的初始化的时候会插入一个模板类，这个模板类是一个 工厂类 ，类继承于 TestFactoryBase，并重载了 CreateTest 方法，主要的作用是 new 出一个 TestInfo 类对象，并实现一个 AddTestInfo 方法，将其测试用例保存起来。

在 AddTestInfo 中是通过 测试用例名 等信息获取测试用例，然后调用测试用例对象去新增一个测试特例—— test_info 

测试用例的保存使用一个 vetor 容器来保存

### 为什么使用宏函数

函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了时间。大家要知道的是，函数调用是要使用系统的栈来保存数据的，如果编译器里有栈检查选项，一般在函数的头会嵌入一些汇编语句对当前栈进行检查；同时，CPU 也要在函数调用时保存和恢复当前的现场，进行压栈和弹栈操作，所以，函数调用需要一些 CPU 时间。 而宏函数不存在这个问题。

宏在编译之前进行,也就是先用宏体替换宏名,然后再编译的,而函数显然是编译之后,在执行时,才调用的.因此,宏占用的是编译的时间,而函数占用的是执行时的时间.

宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，因为在进行单元测试的时候回频繁调用同一个宏函数，所以这样效率会高很多。

### 介绍一下工厂模式

> https://www.cnblogs.com/xiaolincoding/p/11524376.html

- 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
- 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，这样客户端就不需要关心对象是如何创建的，并且是通过使用一个共同的接口来指向新创建的对象。

简单来说，使用了 C++ 多态的特性，将存在继承关系的类，通过一个工厂类创建对应的子类（派生类）对象。在项目复杂的情况下，可以便于子类对象的创建。

如果我们直接new一个对象时，如果需要的对象构造方法比较复杂，那么可能需要一连串的代码去创建对象，如果在别的类中又需要创建该对象，那么代码的重复度肯定不小。通过工厂模式的话，我们把对象创建的具体逻辑给隐藏起来了，交给工厂统一管理，这样不仅减少了代码量，以后如果想改代码的话，只需要改一处即可，也方便我们日常的维护。

工厂模式的实现方式可分别简单工厂模式、工厂方法模式、抽象工厂模式，每个实现方式都存在优和劣。

以鞋厂为例分析

#### 简单工厂模式

鞋厂可以指定生产耐克、阿迪达斯和李宁牌子的鞋子。哪个鞋炒的火爆，老板就生产哪个，看形势生产。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/工厂模式01.5dzo9gqbwi00.png)

简单工厂模式的结构组成：

- 工厂类(ShoesFactory)：工厂模式的核心类，会定义一个用于创建指定的具体实例对象的接口。
- 抽象产品类(Shoes)：是具体产品类的继承的父类或实现的接口。
- 具体产品类(NiKeShoes\AdidasShoes\LiNingShoes)：工厂类所创建的对象就是此具体产品实例。

**简单工厂模式的特点**：

工厂类封装了创建具体产品对象的函数。

**简单工厂模式的缺陷**：

扩展性非常差，新增产品的时候，需要去修改工厂类。

#### 工厂方法模式

现各类鞋子抄的非常火热，于是为了大量生产每种类型的鞋子，则要针对不同品牌的鞋子开设独立的生产线，那么每个生产线就只能生产同类型品牌的鞋。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/工厂模式02.md22sc5xhkw.png)

工厂方法模式的结构组成：
- 抽象工厂类厂（ShoesFactory）：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
- 具体工厂类（NiKeProducer\AdidasProducer\LiNingProducer）：继承于抽象工厂，实现创建对应具体产品对象的方式。
- 抽象产品类（Shoes）：它是具体产品继承的父类（基类）。
- 具体产品类（NiKeShoes\AdidasShoes\LiNingShoes）：具体工厂所创建的对象，就是此类。

**工厂方法模式的特点**：

- 工厂方法模式抽象出了工厂类，提供创建具体产品的接口，交由子类去实现。
- 工厂方法模式的应用并不只是为了封装具体产品对象的创建，而是要把具体产品对象的创建放到具体工厂类实现。

**工厂方法模式的缺陷**：

- 每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂模式而言，工厂方法模式需要更多的类定义。
- 一条生产线只能一个产品。

#### 抽象工厂模式

鞋厂为了扩大了业务，不仅只生产鞋子，把运动品牌的衣服也一起生产了。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/工厂模式03.4kdzxh4jx5e0.png)

抽象工厂模式的结构组成（和工厂方法模式一样）：
- 抽象工厂类厂（ShoesFactory）：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现。
- 具体工厂类（NiKeProducer）：继承于抽象工厂，实现创建对应具体产品对象的方式。
- 抽象产品类（Shoes\Clothe）：它是具体产品继承的父类（基类）。
- 具体产品类（NiKeShoes\NiKeClothe）：具体工厂所创建的对象，就是此类。

**抽象工厂模式的特点**：

提供一个接口，可以创建多个产品族中的产品对象。如创建耐克工厂，则可以创建耐克鞋子产品、衣服产品、裤子产品等。

**抽象工厂模式的缺陷**：

同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。

## 死亡测试

死亡测试是为了 判断一段逻辑是否会导致进程退出 而设计的。通常在测试过程中，我们需要考虑各种各样的输入，有的输入可能直接导致程序崩溃，这时我们就需要检查程序是否按照预期的方式挂掉，这也就是所谓的“**死亡测试**”。`gtestX`的死亡测试能做到在一个安全的环境下执行崩溃的测试案例，同时又对崩溃结果进行验证。

死亡测试 在 linux 上实现的过程

- 测试实体中准备启动新的进程，进程路径就是本进程可执行文件路径
- 通过 fork 创建子进程，fork 是标准的子进程和父进程分离执行，所以 threadsafe 对应的  ExecDeathTest 死亡测试类在底层调用的是 fork，从而可以保证是安全的。

- 接着子进程传入了标准输入输出句柄
- 启动子进程时传入类型筛选，即指定执行该测试用例
- 监听子进程的输出
- 判断子进程退出模式

子进程的执行过程是：

- 执行父进程指定的测试特例
- 运行死亡测试宏中的表达式
- 如果没有 crash「崩溃」 ，则根据情况选择退出模式

### 死亡测试运行方式

- fast方式（默认的方式）

```cpp
testing::FLAGS_gtest_death_test_style = "fast";
```

- threadsafe方式

```cpp
testing::FLAGS_gtest_death_test_style = "threadsafe";
```

我们可以在 `main()` 里为所有的死亡测试设置测试形式，也可以为某次测试单独设置。Google Test 会在每次测试之前保存这个标记并在测试完成后恢复，所以你不需要去管这部分工作 。如：

```cpp
TEST(MyDeathTest, TestOne) {
  testing::FLAGS_gtest_death_test_style = "threadsafe";
  // This test is run in the "threadsafe" style:
  ASSERT_DEATH(ThisShouldDie(), "");
}

TEST(MyDeathTest, TestTwo) {
  // This test is run in the "fast" style:
  ASSERT_DEATH(ThisShouldDie(), "");
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  testing::FLAGS_gtest_death_test_style = "fast";
  return RUN_ALL_TESTS();
}
```

> 在使用 detach 分离父进程和子进程，会导致线程安全问题，当时使用的是 临时对象的方式解决的。

### detach 函数

如果创建了很多子线程，让主线程逐个等待子线程结束，这种方法就显得不是很好，所以需要引入 detach 这种写法，**让主线程和子线程分离**，主线程不必等待子进程运行结束。

```cpp
mytoobj.detach();
```
> 一旦调用了 detach，就不可再调用 join 了。当然可以使用 joinable 判断是否成功使用 join 或者 detach 。

但是使用 detach 时候会导致内存安全问题，就比如在线程中传递引用，指针之类的参数，这样的话形参的地址是原来主线程中分配的，一旦主线程退出后，子线程再使用这块内存肯定是不安全的。

所以需要使用值传递，在创建线程这一行就构造出 **临时对象**，主要用这个临时构造的对象传递给线程入口函数，那么线程中的到的第二个参数就一定能够在主线程执行完毕之前构造出来。从而确保 detach 线程是安全的。

#### 怎么进行测试

我们建立一个 `class A`，如果直接在在形参中写 `A(mysecondpar)` ;这个对象是由 主线程传入的时候构造出来的，那么就可以出现主线程先结束的时候，就不能再构造了。

那么在给线程入口函数传递类型对象形参时，传在主线程中构造一个临时对象`A(mysecondpar)` ，就可以保证线程入口函数的形参在 主线程 函数退出前就已经创建完完毕，可以安全使用。

```cpp
std::thread mytobj(myprint2,A(mysecondpar) );  //现在主线程构造出临时对象
```

###  说一下`C++` 的智能指针

 `C++`里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是 c++11 支持，并且第一个已经被`c++11`弃用。

 使用原因：智能指针的作用是管理一个指针，因为在程序设计中动态分配的堆内存没有正确释放或无法释放，导致资源浪费，程序运行速度变慢等问题。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。
 
 所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。**智能指针其实就是一个类模板**。

- <font color="#b5822d" size=5>auto_ptr</font>：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- <font color="#b5822d" size=5>unique_ptr</font>：是一种独占式智能指针，也就是同一时刻，只能有一个 unique_ptr 指针指向这个对象（这块内存）。在 C++14 的时候，unique_ptr 提供了 make_unique 函数。可以使用这个函数初始化性能更高。

- <font color="#b5822d" size=5>shared_ptr</font>：是一个共享指针，多个指针指向同一个对象（多个指针指向同一块内存），最后一个指针被销毁的时候，这个对象被释放，`shared_ptr`的工作机制是使用**引用计数**。            
可以使用 移动语义将对象变为空或者赋值，比如:

```cpp
shared_ptr<int> p1(new int(100)); //初始化：p1 指向这个对象（内存）
std::share_ptr<int> p2 = new int(100); //不行，因为智能指针是显式的类型转换 explicit ,不可以隐式类型转换

shared_ptr<int> p2(std::move(p1));  //移动语义，移动构造 p2，p1 不再指向这个对象而变成空

shared_ptr <int> p3;   
p3 = std::move(p2);     //移动赋值，p2 指向空，p3 指向这个对象，整个对象引用计数依旧为 1
```

<font color="orange" size=4 font-weight="bold">make_shared</font>

这是一个标准库里的函数模板，被认为最安全和更高效的分配和使用 shared_ptr 智能指针的一个 函数模板。

它能够在动态内存（堆）中分配并初始化一个对象，然后返回指向这个对象的 shared_ptr 。

```cpp
shared_ptr<int> p2 = std::make_shared<int>(100);  // 这个 shared_ptr 指向 100 的整数的内存，类似 int *p1 = new int(100);
shared_ptr<string> p3 = std::make_shared<string>(5,"a");  //类似 string p3(5,'a);

cout << *p2 << endl; //100
cout << *p3 << endl; //aaaaa
```


- <font color="#b5822d" size=5>weak_ptr</font>：也是一个类模板，这个指针指针指向一个由 shared_ptr 管理的对象，但是这种智能指针并不控制所指向的对象的生命周期，也就是说，将 weak_ptr 绑定到 shared_ptr 不会改变 shared_ptr 的引用计数。另外，weak_ptr 来直接访问对象，必须使用一个叫做 `lock` 的成员函数，`lock` 的功能就是检查 weak_ptr 所指向的对象是否还存在，如果存在，`lock` 就能返回一个共享对象的 shared_ptr 如果不存在，就返回一个空的 shared_ptr 。



#### RAII 是什么


RAII 全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，

RAII 依托「栈」和「析构函数」，来对所有的资源 —— 包括堆内存在内 —— 进行管理

也就是说在构造函数中申请分配资源，在析构函数中释放资源。


智能指针（`std::shared_ptr`和`std::unique_ptr`）即 RAII 最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记 delete 造成的内存泄漏。


C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：
- 对象很大；
- 对象的大小在编译时不能确定；
- 对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。

比如说在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。

我们怎样才能确保不会发生内存泄漏呢

答案就在析构函数和它的**栈展开**行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。这就是 RAII 的基本用法。

> 在发生异常时对析构函数的调用，也叫 **栈展开**，


