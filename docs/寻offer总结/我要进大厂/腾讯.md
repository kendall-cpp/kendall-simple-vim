> [腾讯光子一面](https://www.nowcoder.com/discuss/653260?type=2&order=3&pos=3&page=1&channel=-1&source_id=discuss_tag_nctrack)

------

## 虚表相关

**虚函数**：在基类的函数前加上`virtual`关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.

**`C++`的虚函数是实现多态的机制**。它是通过虚函数表和虚表指针实现的，虚表是一个指针数组，它存放着指向虚函数的指针，类的实例在调用虚函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。

### 虚函数表是如何实现动态绑定的

>  虚函数的动态绑定是利用虚表和虚表指针类实现的

假如有一个类 B 继承另一个类 A ，如果基类 A 中有包含了虚函数，那么继承类 B 就可以调用基类 A 的虚函数，也就是说一个类继承了包含虚函数的基类，那么这个类就应有自己的虚表。

我们来看以下的代码。类 A 包含虚函数`vfunc1`，`vfunc2`，由于类 A 包含虚函数，故类 A 拥有一个虚表。

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

![虚函数表01](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表01.png)

**虚表是一个指针数组，它存放着指向虚函数的指针**，普通函数也就非虚函数，它的调用不需要经过虚表，所以虚表中并没有存放指向非虚函数的指针。

为了指定对象的虚表，对象中包含一个指向虚表的指针，指向自己的虚表，为了让每个包含虚表的类的对象都用一个虚表指针，编译器在类中添加一个指针`*__vptr`，每个类创建的对象的时候这个指针默认指向类的虚表。

![虚函数表02](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表02.png)

一个继承类的基类如果包含虚函数，那这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。

**那么C++ 是如何利用虚表和虚表指针来实现动态绑定的呢**？

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类 A 是基类，类 B 继承类 A，类 C 又继承类 B。类 A，类 B，类 C，其对象模型如下图所示。

![虚函数表03](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表03.png)

由于这三个类都有虚函数，所以编译器为每个类都创建了一个虚表，即类 A 的虚表（`A vtbl`），类 B 的虚表（`B vtbl`），类 C 的虚表（`C vtbl`）。类 A，类 B，类 C 的对象都拥有一个虚表指针，`*__vptr`，用来指向自己所属类的虚表。

类 A 包括两个虚函数，故 `A vtbl` 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 `B vtbl` 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 `C vtbl` 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。

综上所诉，对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向它继承的最近的一个类的虚函数。

非虚函数的调用不用经过虚表，所以不需要虚表中的指针指向这些函数

## 堆和栈有什么区别

* 栈，栈由系统自动分配，存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
* 堆，是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
* 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小

**而且，栈相对堆来说会快一些**。

栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由`C/C++`函数库提供的，堆在分配和释放时都要调用函数（`malloc,free`)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## new和malloc的区别

它们都用于动态申请内存的。`new`对应的是`delete`,`malloc`对应的是`free`。

- `new/delete` 是`C++`的运算符,`malloc/free`是`C/C++`标准库函数，
- 在`C++`中分别使用`new` 和 `delete`来分配和释放内存。`new` 和 `delete`**是运算符，不是函数**。`new/delete`相对于`malloc/free`除了分配和释放内存之外还做了其他很多事情。
  - `new` 相对于 `malloc` 会额外的做一些初始化工作，
  - `delete` 相对于 `free` 多做一些清理工作。
  - 比如说使用`new`生成一个对象时，系统会调用这个类的构造函数，使用`delete`删除一个对象时，系统会调用这个类的析构函数。
- `new`是封装了`malloc`，直接`free`不会报错，但是这只是释放内存，而不会析构对象。

## 进程和线程的区别

- 进程: 直观的说，就是保存在硬盘中的程序在运行以后，那么这个运行起来的执行程序就是进程了。另外，操作系统会**以进程为单位**进行分配资源，比如说`CPU`时间片，内存等资源。**进程是资源分配的最小单位**。

- 刚刚说到系统运行一个可执行程序就是进程，那么线程就是这个执行程序的基本单位，也可以说是**轻量级的进程**，<font color=#268bd2> 线程是操作系统进行 CPU 调度的最小单位</font>。然后每个进程都有一个唯一的主线程，主线程和进程是相互依存的，主线程结束进程也会终止。

- 进程和线程属于包含关系，没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一个线程完成的，而是多个线程共同完成的；线程是进程的一部分。另外线程可以共享它对应进程的系统资源。

- 在系统开销方面，每个进程都有独立的代码和数据空间（也就是程序的上下文），进程之间的切换会有较大的开销，因为涉及到系统的资源分配；线程因为是轻量级的进程，所以线程的切换开销小很多。而且同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；

## 虚拟内存

**虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。**

如果`CPU`直接去操作操作系统的内存，也就是物理内存，在这种情况下，要想在内存中同时运行多个程序是不可能的，就比如如果一个程序要向在`002`这个位置上写入一个新的值，那么就会覆盖掉上一个程序在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

操作系统为每一个进程分配一套独立的**虚拟地址**，各个程序操作自己的地址，互不干涉，但是这样每个进程不能直接访问物理地址。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚拟内存01.if9p8l54eag.png)

操作系统就是提供一种这样的机制，**将不同进程的虚拟地址和不同内存的物理地址映射起来。**

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。

## 算法题

[知道前序遍历和中序重建二叉树](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=188&tqId=38345&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fjob-code-high-week%2Fquestion-ranking&tab=answerKey)

## C++ 11有哪些新特性

- `nullptr`替代 `NULL`
- 引入了 `auto` 和 `decltype` 这两个关键字实现了类型推导 基于范围的 `for` 循环`for(auto& i : res){}` 类和结构体的中初始化列表
- `Lambda` 表达式(匿名函数) `std::forward_list`(单向链表)
- 右值引用和`move`语义
- 新的智能指针 `unique_ptr`和`shared_ptr`

## 说一下C++左值引用和右值引用

**左值和右值**

- **左值**：**表示的是可以获取地址的表达式**，它能出现在赋值语句的左边，对该表达式进行赋值。但是如果用`const`修饰符修饰的时候，比如`const int& a = 10;`，它可以取得地址，但是没办法对它进行赋值。

- **右值**：**表示无法获取地址的对象**，有常量值、函数返回值、`lambda`表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。

**左值引用和右值引用**

- **左值引用**：传统的C++中引用被称为左值引用

- **右值引用**：`C++11`中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，<u>右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</u>

**这里主要说一下右值引用的特点**：

特点1：右值引用的生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去

特点2：右值引用独立于左值和右值。意思是<u>右值引用类型的变量可能是左值也可能是右值</u>

特点3：`T&& t`在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

## 说一下`C++`里的智能指针

 `C++`里面的四个智能指针，`auto_ptr`，`unique_ptr`，`shared_ptr`，`weak_ptr`，其中后三个是c++11支持，并且第一个已经被`c++11`弃用。

 使用原因：智能指针的作用是管理一个指针，因为在程序设计中动态分配的堆内存没有正确释放或无法释放，导致资源浪费，程序运行速度变慢等问题。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

- `auto_ptr`：采用所有权模式。`p2`剥夺了`p1`的所有权，但是当程序运行时访问`p1`将会报错。所以`auto_ptr`的缺点是：存在潜在的内存崩溃问题。

- `unique_ptr`：实现独占式模式，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以`new`创建对象后因为发生异常而忘记调用`delete`”)特别有用，可以通过标准库的`move()`函数实现指针转移。

- `shared_ptr`：实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字`share`就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。

- `weak_ptr`：是一种不控制对象生命周期的智能指针, `weak_ptr` 设计的目的是为配合 `shared_ptr` 而引入的一种智能指针来协助 `shared_ptr` 工作, 它只可以从一个 `shared_ptr` 或另一个 `weak_ptr` 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

## C++模板是什么，你知道底层怎么实现的?

- 编译器从函数模板根据不同的类型产生不同的函数; 编译器会对函数模板进行两次编译:
  
  - 在声明的地方对模板代码本身进行编译，
  - 在调用的地方对参数替换后的代码进行编译。

- 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

-----

[腾讯游戏客户端](https://www.nowcoder.com/discuss/652271?type=2&order=3&pos=12&page=1&channel=-1&source_id=discuss_tag_nctrack)

-----

## C+ 的内存分布

在操作系统中，不同应用程序之间的内存时相互独立的，一般不能互相进行访问。

一个引用程序的内存一般分成四个区：

- **栈区**：栈区存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
- **堆区**：堆区是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
- **数据区**：数据区主要存放的是全局变量、常量和静态变量。数据区又可以分为**全局区**和**静态区**(常量区)
- **代码区**：代码区存储的就是可执行的代码，这个区域的属性是只读的。

![C++内存管理](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/C++内存管理.png)

实际上，**栈区、数据区都是使用栈结构对数据进行存储**

堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小

堆并没有和栈一样的结构，也没有栈一样的先进后出，需要人为的对的内存进行分配使用。

 在`C++`中分别使用`new` 和 `delete`来分配和释放内存。在 C 语言中是使用`malloc`和`free`分配和释放内存。

 动态分配内存的过程中，忘记释放掉分配的内存或者因为某些原因导致内存无法释放从而造成内存泄露。

- 比如在一个函数中使用`malloc`函数开辟了`100`个单位的内存空间，并没有释放，如果这个函数频繁地被调用，久而久之就会出现严重的后果，所以在使用完之后应该加上`free`进行释放。

- 如果使用`fopen`打开一个文件，使用完之后没有使用`fclose`进行关闭也会导致内存泄漏。

- 还有没有被初始化的指针也会造成内存泄漏，因为指针未初始化的话它的执行是不可控的。包括错误的释放。比如

```cpp
int *p;  //指针未初始化

int pp = p;
free(pp); //错误释放，这里导致指针p出现指针悬挂现象
```

- 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是`virtual`，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露

> C++内存布局：https://blog.csdn.net/tianya_lu/article/details/108015800

## 线程同步的方式

实现线程间同步的方法：

**互斥量，自旋锁，读写锁，条件变量**

- **互斥量**：比如说有两个线程，线程1和线程2，分别充当生产者与消费者的角色，那么这两个线程就很有可能同时去操作临界资源，如果同时去操作临界资源的话就会引起线程同步问题，互斥量的话就是来解决这个问题，当一个线程，比如说线程1在操作临界资源的时候，它就会阻止另外的线程去访问这个临界资源。其实引发线程同步问题的最根本原因是**这两个线程的指令是交叉执行的**，互斥量能够保证指令执行的原子性，也就是说先执行完线程1的指令再执行线程2的指令，或者先执行完线程2的指令再执行线程1的指令。保证他们之间不会出现交叉执行的情况。互斥量也称为互斥锁，它要么处于加锁状态要么处于解锁状态。保证资源访问的串行。操作系统提供的API是`pthread_mutex_t`。

- **自旋锁**：其实自旋锁和互斥锁的原理是一样的，都是在使用临界资源之前加一个锁，阻止其他线程对它进行访问，完成之后再把锁给释放掉，保证临界资源的串行访问。但是它和互斥锁还是存在差别的，使用自旋锁的线程会一直循环反复检查锁的变量是否可用，因此**它不会让出CPU**，会处于忙等待的状态。其实自旋锁还是有很多好处的，它避免了进程或者线程上下文切换的开销，如果锁使用的时间不是很长的话，使用自旋锁的代价也是很小的，同时在操作系统内部很多地方使用的是自旋锁而不是互斥量的。这里还要提一点就是**自旋锁不适合在单核`CPU`中使用**。因为自旋锁在等待的时候并不会释放`CPU`，而是死循环地去等待。会引起其他的进程或者线程无法去执行。操作系统提供的API是`pthread_spinock_t`。

- **读写锁**: 读写锁和互斥锁还有自旋锁是类似的，但是做了一些改进，基于临界资源的考量，因为在开发环境中，临界资源很可能会出现多读少写的特性，就比如有一个数据库存储的是历史订单信息，而这些订单我们一般只是去查询很少去改变它，这个存储历史订单的数据库就属于多读少写的临界资源，如果在读写的时候也给它加锁，这样的话效率会很低的。读写锁的话是一种特殊的自旋锁，**它允许多个读者同时读取临界资源，但是不允许多个写操作同时访问这个资源**。在操作系统中提供的API是`thread_rwlock_t`，读锁是通过`thread_rwlock_rdlock`来加的，写锁是通过`thread_rwlock_wdlock`来加的.

- **条件变量**：条件变量是一种先对复杂的线程同步方法，它允许线程睡眠，在满足一定条件的时候再唤醒线程，就是当满足条件时，可以向这个线程发送信号，唤醒这个线程。因为在生产者和消费者模型中是存在问题的，举个例子，比如当缓冲区小于或者等于0时，这时候应该不允许消费者继续消费，消费者必须等待，当缓冲区满的时候，这个时候应该不允许生产者往里面生成数据了，生产者必须处于等待状态。条件变量呢就是对这个问题进行了约束，当缓冲区为0的时候，如果有生产者生产一个产品，那么就要唤醒可能等待的消费者；当缓冲区满的时候，如果有消费者消费了产品，就需要唤醒其他可能在等待的生产者。操作系统提供的`API`是`pthread_cont_t`来定义的,等待是通过`pthread_cont_wait`定义的，,唤醒是通过`pthread_cont_notify`定义的。

----

[腾讯后端实习](https://www.nowcoder.com/discuss/652219?type=2&order=3&pos=14&page=1&channel=-1&source_id=discuss_tag_nctrack)

----

## `HTTP` 和 `HTTPS`的区别，由`HTTP`升级为`HTTPS`需要做哪些操作

- `http` 是超文本传输协议，信息是明文传输的， `https` 则是具有安全性的 `ssl` 加密传输协议

- `http` 和 `https` 使用的是完全不同的连接方式，用的端口也不一样，`http`是 80 ，`https`是 `443`

- `http` 的连接很简单，是无状态的； `HTTPS` 协议比 `http` 协议更加安全。

- `HTTPS`协议[**使用混合加密和摘要算法**]解决了`HTTP`协议的一些不足，因为 `HTTP`：
  
  - 1.通信使用明文（不加密），内容可能会被盗取
  - 2.不验证通信方身份，因此可能遭遇伪装
  - 3.无法证明报文的完整性（即准确性），所以可能已遭篡改      

> HTTP+加密+认证+完整性保护=HTTPS

由`HTTP`升级为`HTTPS`需要到 `CA` 申请证书，一般免费证书较少，因此需要一定费用

**其实**：

`HTTPS`也不是绝对安全的，针对`SSL`的攻击方式主要有两类，分别是`SSL`劫持攻击和`SSL`剥离攻击。

> 攻击者干预了 `HTTP` 到安全 `HTTPS` 协议的重定向，并拦截了客户端到服务器的请求，攻击者将将自己接入到客户端和目标网站之间； 在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥。并与用户建立不安全的 `HTTP` 连接。

### 如何保证公钥不被篡改？

将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

**公钥加密计算量太大，如何减少耗用的时间**？

每一次对话（`session`），客户端和服务器端都生成一个"**对话密钥**"（`session key`），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

- （1） 客户端向服务器端索要并验证公钥。
- （2） 双方协商生成"对话密钥"。
- （3） 双方采用"对话密钥"进行加密通信。上面过程的前两步，又称为"握手阶段"（handshake）。

### https怎么加密

> `https`的请求的过程，怎么确保安全性

`https`包括**非对称加密**和**对称加密**两个阶段，在客户端与服务器建立连接的时候使用**非对称加密**，连接建立以后使用的是**对称加密**。

（1）客户端向服务器端发起`SSL`连接请求；<br>
（2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥<br>
（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端<br>
（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，<br>
（5）进行数据传输，服务器和客户端用相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，也就是即使第三方获得数据包，也无法对其进行加密，解密和篡改。<br>

## UDP实现可靠传输

> https://blog.csdn.net/u013474436/article/details/105583260
