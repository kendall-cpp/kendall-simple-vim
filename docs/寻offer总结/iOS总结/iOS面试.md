

-----


## OC 和 C++ 的区别

- Objective-C 不支持多重承继，而C++语言支持多重继承（从侧面可以说明多重继承的效率不高）；
- Objective-C通过互相传递消息实现函数调用，而C++直接进行函数调用
- Objective-C是动态定型（dynamicaly typed)。所以它的类库比C++要容易操作。Objective-C 在运行时可以允许根据字符串名字来访问方法和类，还可以动态连接和添加类。而C++，对象的静态类型决定你是否可以发送消息给它。


## 什么是 runtime
## 为什么说 OC 是一门动态编程语言 

OC 是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行

比如说 C/C++ ，编译完之后生成的二进制文件和源代码是保持是一致的。而 OC 可以在程序运行过程中去修改之前编译好的东西。

> 代码就执行流程一般都是
>
> 编写代码 --> 编译链接 --> 执行

OC 的动态性就是由 Runtime 来支撑和实现的，Runtime 是一套 C 语言的 API，封装了很多动态性相关的函数

平时编写的OC代码，底层都是转换成了Runtime API进行调用

也就是说 Objective-C 的动态性是由 `Runtime` API来支撑的.

## objc在向一个对象发送消息时，发生了什么

objc在向一个对象发送消息时，runtime 会根据对象的 isa 指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果一直到根类还没找到，转向拦截调用，走消息转发机制，一旦找到 ，就去执行它的实现 IMP 。

## isa 指针

『以前」实例对象的 isa 指向 类对象，类对象的 isa 指向 源类对象

- instance 的 isa 指向 class
  - 当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用

- class 的 isa 指向 meta-class
  - 当调用类方法时，通过 class 的 isa 找到 meta-class ，最后找到类方法的实现进行调用

但是从 ARM64 开，例对象的 isa 不是直接指向 类对象，类对象的 isa 不是直接指向 源类对象，而是需要 &ISA_MASK  的值，才能得到类对象的地址值。

> 从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息

## objc中向一个nil对象发送消息将会发生什么

如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。也不会崩溃。

详解：

如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)；

如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*) ，float，double，long double 或者long long的整型标量，发送给nil的消息将返回0；

如果方法返回值为结构体,发送给nil的消息将返回0。结构体中各个字段的值将都是0；

如果方法的返回值不是上述提到的几种情况，那么发送给nil的消息的返回值将是未定义的


