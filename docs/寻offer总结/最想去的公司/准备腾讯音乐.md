## 算法部分

## 实现`split`

```cpp
#include <iostream>
#include <string>
#include <sstream>
#include <iostream>
#include <vector>

using namespace std;

vector<string> split(string str,char ch) {
    //加上ch，是为了保证最后一个字符串
    str += ch;
    vector<string> res;
    string temp = "";
    for(int i=0;i<str.size();++i) {
        if(str[i] == ch) {  //当遇到切割符
            res.push_back(temp);
            temp = "";
        }
        else {
            temp += str[i];
        }
    }
    return res;
}

int main() {

    string str;
    cin >> str;
    vector<string> strSplit =split(str,',');



    cout << "输入的字符串：" <<  str << endl << endl;;
    cout << "切割后的字符串：";
    for(int i=0;i<strSplit.size();++i) {
        cout << strSplit[i] << " ";
    }
    cout << endl;
    return 0;
}
```

### 字符串相减

[参考链接](https://mp.weixin.qq.com/s/kCue4c0gnLSw0HosFl_t7w)

```cpp
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

//相减函数
string sub(string a, string b) {
    string res = "";
    int borrow = 0;
    int i = a.size() - 1, j = b.size() - 1;
    while (i >= 0 || j >= 0) {
        int x = i >= 0 ? a[i] - '0' : 0;
        int y = j >= 0 ? b[j] - '0' : 0;
        int z = (x - borrow - y + 10) % 10;
        res += '0' + z;
        borrow = x - borrow - y < 0 ? 1 : 0;
        i--, j--;
    }
    reverse(res.begin(), res.end());
    //删除前导0。循环条件是res.size()-1是为防止"0000"的情况
    int pos;
    for (pos = 0; pos < res.size() - 1; pos++) {
        if (res[pos] != '0') break;
    }
    return res.substr(pos);
}

//比较两个字符串的大小
bool cmp(string num1,string num2) {
    //长度一样就去比较字典序
    if(num1.size() == num2.size()) {
        return num1 < num2;
    }
    return num1.size() < num2.size();
}

//字符串相减
string subString(string num1,string num2) {
    string res;
    //由于是大数，所以不能直接转成int比较
    //我们可以先比较两个字符串的长度
    //长度长的字符串，数一定更大，当长度一样长的就去比较字典序
    if(cmp(num1,num2)) {  //返回true，如果num1 < num2
        res = sub(num2,num1);
        if(res != "0") res.insert(0,"-");
    }
    else res = sub(num1,num2);

    return res;
}

int main() {

    string a,b;
    cin >> a >> b;
    cout << subString(a,b) << endl;
    return 0;
}
```


### 二叉树深度

[LC二叉树深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof)

[NK二叉树的最大深度](https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=117&tqId=37721&rp=1&ru=%2Fta%2Fjob-code-high&qru=%2Fta%2Fjob-code-high%2Fquestion-ranking&tab=answerKey)

题解：

```cpp

```


### 判断链表中是否有环

[LC判断链表中是否有环](https://leetcode-cn.com/problems/linked-list-cycle/)

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr || head->next == nullptr) return false;
        ListNode* fast = head;
        ListNode* slow = head;
        //保证fast = fast->next->next;不出错
        while(fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) return true;
        }
        return false;
    }
};
```

[NK判断链表中是否有环](https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=117&tab=answerKey)

判断给定的链表中是否有环。如果有环则返回true，否则返回false。

你能给出空间复杂度$O(1)$的解法么？

题解：

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == nullptr || head->next == nullptr) return false;
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) return true;
        }
        return false;
    }
};
```


