## UDP首部格式

![](./img/udp首部.png)

 用户数据报`UDP`有两个字段：数据字段和首部字段。首部字段很简单，只有`8`个字节，由四个字段组成，每个字段的长度都是两个字节。还有，`12`字节的伪首部是为了计算检验和临时添加的。

- （1）源端口：源端口号。在需要对方回信时选用。不需要时可用全0。

- （2）目的端口：目的端口号。在终点交付报文时使用。

- （3）长度：`UDP`用户数据报的长度，其最小值是`8`（仅有首部）。

- （4）检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。

## TCP首部格式

`TCP`虽然是面向字节流的，但`TCP`传送的数据单元却是报文段。一个`TCP`报文段分为首部和数据两部分，而`TCP`的全部功能体现在它首部中的各字段的作用。

`TCP`的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位（6个，ACK,SYN等），校验和等等

![](./img/tcp首部.png)


（1）序号：`seq`序号，占`32`位，用来标识从`TCP`源端向目的端发送的字节流，发起方发送数据时对此进行标记。

（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。

（3）标志位：共6个，即`ACK`、`FIN`、`PSH`、`RST`、`SYN`、`URG`等，具体含义如下：

    ACK：为确认序号，ACK=1时确认号才有效；

    FIN：为结束序号，用于发送端提出断开连接；

    PSH：接指示接收方立即将数据提交给应用层，而不是等待缓冲区满；
    
    RST：重置连接。

    SYN：为同步标志，用于数据同步

    URG：为紧急序号，URG=1是紧急指针有效；

> 需要注意的是：    
> 不要将确认序号ack与标志位中的ACK搞混了。    
> 确认方ack=发起方seq+1，两端配对。   

> 详细参考：https://blog.csdn.net/zhangliangzi/article/details/52554439


## TCP与UDP的区别

- 1.TCP面向连接，UDP无连接。
- 2.TCP面向字节流（文件传输），UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对IP电话，实时视频会议等）。
- 3.TCP首部开销20字节，UDP的首部开销小，只有8个字节。
- 4.TCP的逻辑通信信道是全双工的可靠信道，提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且有序到达; UDP是不可靠信道，UDP只是尽最大努力交付，并不保证可靠交付。
- 5.每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。
- 6.TCP对系统资源的要求高于UDP，所以速度也比UDP慢。
- 7.TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。
- 所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。

## 建立`TCP`服务器的各个系统调用

建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：`socket()`，`bind()`，`listen()`，`accept()`，`send()`和`recv()`。

![](./img/socket01.png)

- socket 函数

这个函数有三个参数，第一个是指定协议族，第二个是指定`socket`的类型，第三个是指定具体的协议。

- bind 函数

服务器监听的网络地址和端口号通常是固定不变的，客户端程序需要知道服务器的地址和端口号后就可以向服务器发起连接，因此服务器需要调用`bind`绑定一个固定的网络地址和端口号。

`bind()`的作用是将参数`sockfd`（`socket`描述符）和`addr`(本地`IP`和端口号)绑定在一起，使`sockfd`这个用于网络通讯的文件描述符监听`addr`所描述的地址和端口号。

- connect 函数

客户端需要调用`connect()`连接服务器，用来与服务器建立一个`TCP`连接，实际是发起`3`次握手过程，`connect`和`bind`的参数形式一致，区别在于`bind`的参数是自己的地址，而`connect`的参数是对方的地址。`connect()`成功返回`0`，出错返回`-1`。

- listen 函数

一般服务器程序可以同时服务多个客户端，当有客户端发起连接时，服务器调用的`accept()`返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未`accept`的客户端就处于连接等待状态，`listen()`声明`sockfd`处于监听状态，一般`Linux`系统最多允许有`128`个客户端处于连接待状态，如果接收到更多的连接请求就忽略。`listen()`成功返回`0`，失败返回`-1`。

- accept 函数

三次握手完成后，服务器调用`accept()`接受连接，如果服务器调用`accept()`时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。


- send 函数

> send(), write(), sendto()   数据发送 

主要是进行TCP类型的数据发送。

- recv 函数

> recv(), read(), recvfrom()  数据接收

主要用于TCP类型的数据接收。

- `close()`, `shutdown()` 关闭套接字

详见：[建立TCP 服务器的系统调用](计算机网络/unix网络编程学习笔记?id=_12-socket模型创建)

### `close`是一次就能直接关闭的吗，半关闭状态是怎么产生的？

使用`close()`时，只有当套接字的引用计数为`0`的时候才会终止连接，而用`shutdown()`就可以直接关闭连接。

同时在`TCP`协议中，发送关闭请求时，需要对方回复确认请求，否则不能确认，就会造成一个半关闭的状态，这个时候可以接收，不能发送。我们可以调用`shutdown()`来进行直接关闭 `shutdown`的第二个参数为`SHUT_WR`时，为半关闭。`shutdow`函数可以立即关闭进程，不用考虑套接字的引用计数。

半关闭的定义：
`TCP`提供了连接的一端在结束它的发送后，还能接收来自另一端发来的数据的能力，这就是`TCP`的半关闭。

## TCP怎么保证可靠传输的

**（校序重流拥）**

* 校验和      
  发送的数据包的二进制相加然后取反，目的是**检测数据在传输过程中的任何变化**。如果收到段的检验和有差错，`TCP`将丢弃这个报文段和不确认收到此报文段。 

* 确认应答+序列号       
  `TCP`对发送的**每一个包进行编号**，接收方**对数据包进行排序**，把有序数据传送给应用层。 

* 超时重传      
  当`TCP`发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 

* 流量控制      
  `TCP`连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止数据包丢失。`TCP`使用的流量控制协议是可变大小的滑动窗口协议。


* 拥塞控制
  如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以`TCP`在为了防止这种情况而进行了拥塞控制。

  进行拥塞控制后可以达到：在`TCP`通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。

> 拥塞控制有四种算法，**慢启动、拥塞避免，快速重传和快速恢复**

### 说一下`TCP`怎么进行拥塞控制的？

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![](./img/拥塞控制01.jpeg)

`TCP` 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快速重传、快速恢复**。

- **慢启动**。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即`1、2、4、8、16`
  * 为了防止拥塞窗口`cwnd`增长过大引起网络拥塞，还要另外设置一个慢启动阈值`ssthresh`状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ `cwnd > ssthresh` 时），停止使用慢启动算法而改用拥塞避免算法。

- **拥塞避免**：设置慢启动阈值，一般开始都设为`65536`。拥塞避免是指当拥塞窗口大小达到这个阈值的时候，拥塞窗口的值不再指数上升，而是采用加法增加（也就是每经过一个往返时间`RTT`就把发送方的拥塞窗口大小`+1`），以此来避免拥塞。

- **快速重传**：当发送端连续收到三个重复的`ack`时，表示该数据段已经丢失，需要重发。这个时候慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd`变为`ssth+3`，然后使用`+1+1`的发（也就是每一轮`RTT+1`）

- **快速恢复**。当超过设定的时间没有收到某个报文段的`ack`时，表示网络拥塞，慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd=1`，进入慢启动阶段。

### 拥塞控制和流量控制的区别

拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。

具体地说：

- 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。

- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的`TCP`报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。

- `实际最终发送窗口 = min{流控发送窗口，拥塞窗口}`。

### 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？

所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用`TCP`报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。

考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时将发送方将的发送窗口设置为`0`，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零**导致死锁**。

解决这个问题，`TCP`为每一个连接设置一个持续计时器（`persistence timer`）。只要`TCP`的一方收到对方的零窗口通知，就启动这个计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：`TCP`规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。

### TCP 滑动窗口协议

`TCP`的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。

接收方会在每个`ACK`数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。

详细可以参考[TCP滑动窗口](/计算机网络/TCP滑动窗口.md)

## TCP 通信过程

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如`ip`地址、端口号等。  

`TCP`可以看成是一种字节流，它会处理`IP`层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在`TCP`头部。  


一个`TCP`连接由一个`4`元组构成，分别是**两个IP地址**和**两个端口号**。一个`TCP`连接通常分为三个阶段：**连接、数据传输、退出（关闭）**。通过三次握手建立一个链接，通过四次挥手来关闭一个连接。

**当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。**

### TCP 三次握手

> 三次握手的本质是确认通信双方收发数据的能力

首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。

于是他给我回信，我若收到了，我便知我的**发件**能力和他的**收件**能力是可以的，并且他的**发件**能力和我的**收件**能力是可以。

然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的**发件**能力和我的**收件**能力是可以的。

TCP通信过程包括三个步骤：建立T`CP`连接通道，传输数据，断开TCP连接通道。如图1所示，给出了TCP通信过程的示意图。

![](./img/三次握手.png)
[图片来源](https://www.cnblogs.com/bj-mr-li/p/11106390.html)

- 第一次握手：
  
客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号`ISN`(比如是`100`)，那客户端向服务端发送的报文段包含`SYN`标志位(也就是`SYN=1`)，序列号`seq=100`。
  
这时候`client`处于同步状态`SYN-SENT`。也就是可以建立连接。服务端处于监听状态`LISTEN`。

- 第二次握手

服务端收到客户端发过来的报文后，发现`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1`,`ACK=1`)、序列号`seq=300`、确认号`ack=101`(*客户端发过来的序列号+1*)。

  这个时候服务端处于`SYN_RECV`接收状态。

- 第三次握手

客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(*服务端序列号+1*)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。


> 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，`TCP`连接一旦建立，在通信双方中的任何一方主动关闭连接之前，`TCP` 连接都将被一直保持下去。

### 为什么使用三次握手，两次握手可不可以？

三次握手是为了防止客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。

服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。

### 四次挥手过程

> 四次挥手的目的是关闭一个连接


`TCP`断开连接通常是由一方主动，一方被动的，这里我们假设`client`主动，`server`被动

比如客户端初始化的序列号`ISA=100`，服务端初始化的序列号`ISA=300`。`TCP`连接成功后客户端总共发送了`1000`个字节的数据，服务端在客户端发`FIN`报文前总共回复了`2000`个字节的数据。

- 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含`FIN`标志位(`FIN=1`)、序列号`seq=1101`(`100+1+1000`，其中的`1`是建立连接时占据的一个序列号)。需要注意的是客户端发出`FIN`报文段后只是不能发数据了，但是还可以正常收数据；另外`FIN`报文段即使不携带数据也要占据一个序列号。
  
- 第二次挥手：服务端收到客户端发的`FIN`报文后给客户端回复确认报文，确认报文包含`ACK`标志位(`ACK=1`)、确认号`ack=1102`(客户端`FIN`报文序列号`1101+1`)、序列号`seq=2300(300+2000)`。此时服务端处于**关闭等待状态**，而不是立马给客户端发`FIN`报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。

- 第三次挥手：服务端将最后数据(比如`50`个字节)发送完毕后就向客户端发出连接释放报文，报文包含`FIN`和`ACK`标志位(`FIN=1,ACK=1`)、确认号和第二次挥手一样`ack=1102`、序列号`seq=2350(2300+50)`。

- 第四次挥手：客户端收到服务端发的`FIN`报文后，向服务端发出确认报文，确认报文包含`ACK`标志位(`ACK=1`)、确认号`ack=2351`、序列号`seq=1102`。注意客户端发出确认报文后不是立马释放`TCP`连接，而是要经过`2MSL`(最长报文段寿命的`2`倍时长)后才释放`TCP`连接。而服务端一旦收到客户端发出的。


![](./img/四次握手.jpg)

### TIME_WAIT(等待重传)的意义（为什么要等于`2MSL`）

`TIME_WAIT`是指四次挥手中客户端接收了服务端的`FIN`报文并发送`ACK`报文给服务器后，仍然需要等待`2MSL`时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入`CLOSED`状态了，但是我们必须假象网络是不可靠的，有可以最后一个`ACK`丢失。如果客户端发送的`ACK`发生丢失，服务器会再次发送`FIN`报文给客户端，所以`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。

### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当`Server`端收到`Client`端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。其中`ACK`报文是用来应答的，`SYN`报文是用来同步的。但是关闭连接时，当`Server`端收到`FIN`报文时，很可能并不会立即关闭`SOCKET`，所以只能先回复一个`ACK`报文，告诉`Client`端，"你发的`FIN`报文我收到了"。只有等到我`Server`端所有的报文都发送完了，我才能发送`FIN`报文，因此不能一起发送。故需要四步握手。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

`TCP`还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为`2`小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送`10`个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 服务器出现大量`close_wait`的连接的原因以及解决方法

`close_wait`状态是在`TCP`四次挥手的时候收到`FIN`但是没有发送自己的`FIN`时出现的，服务器出现大量`close_wait`状态的原因有两种：

* 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行`close()`方法
* 服务器的父进程派生出子进程，子进程继承了`socket`，收到`FIN`的时候子进程处理但父进程没有处理该信号，导致`socket`的引用不为`0`无法回收

处理方法：

* 停止应用程序
* 修改程序里的bug


## 介绍一下`ping`的过程，分别用到了哪些协议

详见：[`Ping`原理与`ICMP`协议](https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html)

`ping`是使用`ICMP`协议来进行工作的。 

`ICMP`:网络控制报文协议

* 首先，`ping`命令会构建一个`ICMP`请求数据包，然后由`ICMP`协议将这个数据包连同目的`IP`地址源`IP`地址一起交给`IP`协议。
* 然后`IP`协议就会构建一个`IP`数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。
* 然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。

目的主机接收到数据帧后，就会检查包上的`mac`地址与本机`mac`是否相符，如果相符，就接收并把其中的信息提取出来交给`IP`协议，`IP`协议就会将其中的信息提取出来交给`ICMP`协议。然后构建一个`ICMP`应答包，用相同的过程发送回去。
