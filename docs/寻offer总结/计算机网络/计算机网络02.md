## UDP首部格式

![](./img/udp首部.png)

 用户数据报`UDP`有两个字段：数据字段和首部字段。首部字段很简单，只有`8`个字节，由四个部分组成，分别是：源端口号，目的端口号，长度，校验和；每个部分的长度都是两个字节。还有，`12`字节的伪首部是为了计算检验和临时添加的。

- （1）源端口：发送报文的进程的端口号。在需要对方回信时选用。不需要时可用全`0`。

- （2）目的端口：接收报文的进程的端口号。在终点交付报文时使用。

- （3）长度：`UDP`用户数据报的长度，其最小值是`8`（仅有首部）。

- （4）检验和：检测`UDP`用户数据报在传输中是否有错。有错就丢弃。

## TCP首部格式

`TCP`虽然是面向字节流的，但`TCP`传送的数据单元却是报文段。一个`TCP`报文段分为首部和数据两部分，而`TCP`的全部功能体现在它首部中的各字段的作用。

`TCP`的头部大致包括：源端口，目的端口，序号，确认号，数据偏移，标志位（6个，ACK,SYN等），检验和等等

![](./img/tcp首部.png)

（1）源端口，`2`个字节；发送报文的进程的端口号

（2）目的端口，`2`个字节；接收报文的进程的端口号

（3）序号：`seq`序号，`4`个字节，用来标识从`TCP`源端向目的端发送的字节流，发起方发送数据时对此进行标记。

> 就是对 `TCP` 通信过程中某一个传输方向上字节流的每个字节进行编号，为了保证网络传输过程中数据通信的有序性。初始序列号由自己定，而后绪的序列号由对端的 `ACK` 决定：`SN_x = ACK_y` (`x` 的序号 `=` `y` 发给 `x` 的 `ACK`)。   
> 说白了，类似于身份证一样，而且还得发送此时此刻的所在的位置，就相当于身份证上的地址一样。


（4）确认号：`ack`序号，占`4`个字节，只有标志位的大`ACK`标志位为`1`时，确认号字段才有效，`ack=seq+1`。
> 确认号是接收确认端所期望收到的下一个序号。确认号等于上次已成功收到的序号加`1`（`ack=seq+1`），只有当标志位中的 `ACK` 标志为 `1` 时该确认号的字段才有效。主要用来解决不丢包的问题。

（5）数据偏移：`4`个字节；实际代表`TCP`首部长度，最大为`60`字节。

（6）标志位：共`6`个，即`ACK`、`FIN`、`PSH`、`RST`、`SYN`、`URG`等，具体含义如下： `afprsu`

    ACK：为确认序号，ACK=1 时确认号才有效；
    
    FIN：为结束序号，用于发送端提出断开连接；
    
    PSH：指示接收方立即将数据提交给应用层，而不是等待缓冲区满；
    
    RST：重置连接。
    
    SYN：为同步标志，用于数据同步
    
    URG：为紧急序号，URG=1 是紧急指针有效；

> 1. **ACK**：用来标识发送端有没有把数据发送给接收端，发送的时候 ACK 为 0，表示接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。
> 2. **FIN**：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 FIN 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用 FIN 标识一下，接收端看到这个 FIN 之后，哦！这是接受的最后的数据，接收完就关闭了；
> 3. **SYN**：表示「同步序号」，是 TCP 握手的发送的第一个数据包。用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。

> 需要注意的是：    
> 不要将确认序号`ack`与标志位中的`ACK`搞混了。    
> 确认方`ack=发起方seq+1`，两端配对。

  （7）检验和：占`2`字节，用于检验数据的完整性

> 详细参考：https://blog.csdn.net/zhangliangzi/article/details/52554439


## TCP与UDP的区别

- 1.`TCP`面向连接，`UDP`无连接。
- 2.`TCP`面向字节流（文件传输），`UDP`是面向报文的，`UDP`没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（比如`IP`电话，实时视频会议等）。
- 3.`TCP`首部开销`20`字节，UDP的首部开销小，只有8个字节。
- 4.`TCP`的逻辑通信信道是全双工的可靠信道，提供可靠的服务。也就是说，通过`TCP`连接传送的数据，无差错，不丢失，不重复，且有序到达; `UDP`是不可靠信道，`UDP`只是尽最大努力交付，并不保证可靠交付。
- 5.每一条`TCP`连接只能是点到点的；`UDP`支持一对一，一对多，多对一和多对多的交互通信。
- 6.`TCP`对系统资源的要求高于`UDP`，所以速度也比`UDP`慢。
- 7.`TCP`数据包是没有边界的，会出现粘包的问题，`UDP`包是独立的，不会出现粘包问题。
- 所以在应用方面，如果强调数据的完整性和正确性用`TCP`，当要求性能和速度的时候，使用`UDP`更加合适。

## 建立`TCP`服务器的各个系统调用

建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：`socket()`，`bind()`，`listen()`，`accept()`，`send()`和`recv()`。

![](./img/socket01.png)

- **服务器**：

  - 创建`socket -> int socket(int domain, int type, int protocol);`

    - `domain`：协议域，决定了`socket`的地址类型，`IPv4`为`AF_INET`。

    - `type`：指定`socket`类型，`SOCK_STREAM`为`TCP`连接。

    - `protocol`：指定协议。`IPPROTO_TCP`表示`TCP`协议，为0时自动选择`type`默认协议。

  - 绑定`socket`和端口号 -> `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`

    - `sockfd`：`socket`返回的套接字描述符，类似于文件描述符`fd`。

    - `addr`：有个`sockaddr`类型数据的指针，指向的是被绑定结构变量。

    ```cpp
        // IPv4的sockaddr地址结构
        struct sockaddr_in {
            sa_family_t sin_family;    // 协议类型，AF_INET
            in_port_t sin_port;    // 端口号
            struct in_addr sin_addr;    // IP地址
        };
        struct in_addr {
            uint32_t s_addr;
        }
    ```

    - `addrlen`：地址长度。

  - 监听端口号 -> `int listen(int sockfd, int backlog);`

    - `sockfd`：要监听的`sock`描述字。

    - `backlog`：`socket`可以排队的最大连接数。

  - 接收用户请求 -> `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`

    - `sockfd`：服务器`socket`描述字。

    - `addr`：指向地址结构指针。

    - `addrlen`：协议地址长度。

    - 注：一旦`accept`某个客户机请求成功将返回一个全新的描述符用于标识具体客户的`TCP`连接。

  - 从`socket`中读取字符 -> `ssize_t read(int fd, void *buf, size_t count);`

    - `fd`：连接描述字。

    - `buf`：缓冲区`buf`。

    - `count`：缓冲区长度。

    - 注：大于`0`表示读取的字节数，返回`0`表示文件读取结束，小于`0`表示发生错误。

  - 关闭`socket -> int close(int fd);`

    - `fd`：`accept`返回的连接描述字，每个连接有一个，生命周期为连接周期。

    - 注：`sockfd`是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。

- **客户机**：

  - 创建socket -> int socket(int domain, int type, int protocol);

  - 连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);
    - sockfd客户端的sock描述字。

    - addr：服务器的地址。

    - addrlen：socket地址长度。

  - 向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);
    - fd、buf、count：同read中意义。

    - 大于0表示写了部分或全部数据，小于0表示出错。

  - 关闭oscket -> int close(int fd);
    - fd：同服务器端fd。



详见：[建立TCP 服务器的系统调用](计算机网络/unix网络编程学习笔记?id=_12-socket模型创建)

### `close`是一次就能直接关闭的吗，半关闭状态是怎么产生的？

使用`close()`时，只有当套接字的引用计数为`0`的时候才会终止连接，而用`shutdown()`就可以直接关闭连接。

在`TCP`协议中，发送关闭请求时，需要对方回复确认请求，否则不能确认，就会造成一个半关闭的状态，这个时候可以接收，不能发送。我们可以调用`shutdown()`来进行直接关闭 ，`shutdown`的第二个参数为`SHUT_WR`时，为半关闭。`shutdow`函数可以立即关闭进程，不用考虑套接字的引用计数。

半关闭的定义：
`TCP`提供了连接的一端在结束它的发送后，还能接收来自另一端发来的数据的能力，这就是`TCP`的半关闭。

## TCP怎么保证可靠传输的

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：`TCP`报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：`tcp`会按最大传输单元(MTU)合理分片，接收方如果收到的数据不按顺序的时候，就会对它重新排序再交给应用层。
  - 而对于UDP：`IP`数据报如果大于1500字节，也就是大于`MTU`。这个时候就会对数据包进行分片，让每一片都少于`MTU`，由于`UDP`的特性，有些分片会被丢弃，所以导致最终无法重组数据包，导致丢弃整个UDP数据报。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

> 拥塞控制有四种算法，**慢启动、拥塞避免，快速重传和快速恢复**

### 说一下`TCP`怎么进行拥塞控制的？

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![](./img/拥塞控制01.jpeg)

`TCP` 主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快速重传、快速恢复**。

- **慢启动**。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即`1、2、4、8、16`
  * 为了防止拥塞窗口`cwnd`增长过大引起网络拥塞，还要另外设置一个慢启动阈值`ssthresh`状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ `cwnd > ssthresh` 时），停止使用慢启动算法而改用拥塞避免算法。

- **拥塞避免**：设置慢启动阈值，一般开始都设为`65536`。拥塞避免是指当拥塞窗口大小达到这个阈值的时候，拥塞窗口的值不再指数上升，而是采用加法增加（也就是每经过一个往返时间`RTT`就把发送方的拥塞窗口大小`+1`），以此来避免拥塞。

- **快速重传**：当发送端连续收到三个重复的`ack`时，表示该数据段已经丢失，需要重发。这个时候慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd`变为`ssth+3`，然后使用`+1+1`的发（也就是每一轮`RTT`就+1）

- **快速恢复**。当超过设定的时间没有收到某个报文段的`ack`时，表示网络拥塞，慢启动阈值`ssth`变为原来一半，拥塞窗口`cwnd=1`，进入慢启动阶段。

### 拥塞控制和流量控制的区别

拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；

而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。

两种算法都是对发送方的行为进行控制的。

具体地说：

- 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。

- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的`TCP`报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。

- `实际最终发送窗口 = min{流控发送窗口，拥塞窗口}`。

### 流量控制的介绍，采用滑动窗口会有什么问题

所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用`TCP`报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。

考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时将发送方将的发送窗口设置为`0`，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零**导致死锁**。

解决这个问题，`TCP`为每一个连接设置一个持续计时器（`persistence timer`）。只要`TCP`的一方收到对方的零窗口通知，就启动这个计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：`TCP`规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。

### TCP 滑动窗口协议

`TCP`的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了一个连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。

接收方会在每个`ACK`数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。

详细可以参考[TCP滑动窗口](/计算机网络/TCP滑动窗口.md)

## TCP 通信过程

首先是通过三次握手建立连接，然后发送数据以及应答,最后通过四次挥手断开连接。

### TCP 三次握手

> 三次握手的本质是确认通信双方收发数据的能力

首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。

于是他给我回信，我若收到了，我便知我的**发件**能力和他的**收件**能力是可以的，并且他的**发件**能力和我的**收件**能力是可以。

然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的**发件**能力和我的**收件**能力是可以的。

`TCP`通信过程包括三个步骤：建立`TCP`连接通道，传输数据，断开`TCP`连接通道。如图1所示，给出了`TCP`通信过程的示意图。

![](./img/三次握手.png)


- 第一次握手：

客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号`ISN`(比如是`100`)，那客户端向服务端发送的报文段包含同步序号`SYN`标志位(也就是`SYN=1`)，序列号`seq=100`。

这时候`client`处于同步状态`SYN_SENT`。也就是可以建立连接。服务端处于监听状态`LISTEN`。

- 第二次握手

服务端收到客户端发过来的报文后，发现同步序号`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1`,`ACK=1`)、序列号`seq=300`、确认号`ack=101`(*客户端发过来的序列号+1*)。

  这个时候服务端处于`SYN_RECV`接收状态。

- 第三次握手

客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(*服务端序列号+1*)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。


> 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，`TCP`连接一旦建立，在通信双方中的任何一方主动关闭连接之前，`TCP` 连接都将被一直保持下去。

### 为什么使用三次握手，两次握手可不可以？

- **确认双方有没有建立连接**

三次握手是为了防止客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。

服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃。

- **阻止重复历史连接的初始化**

客户端由于某种原因发送了两个不同序号的 `SYN` 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 `SYN` 就会立刻建立连接，那么会造成网络异常。

如果是三次握手，服务器需要回复 `SYN+ACK` 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 RST 报文，直到正常的 `SYN` 到达服务器后才正常建立连接。

所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。


- **安全问题**

我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。

TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！

### ISN 是什么？

`ISN` 全称是 `Initial Sequence Number`，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号

#### ISN 是固定不变的吗？

`ISN` 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 `ISN` 是动态生成的

### 什么是半连接队列

服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

### 三次握手过程中，可以携带数据吗

第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 `SYN` 报文中放入大量的数据，疯狂着重复发 `SYN` 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。

对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。

### 四次挥手过程

> 四次挥手的目的是关闭一个连接

当我们的应用程序不需要数据通信了，就会发起断开 `TCP` 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

- 第一次挥手。客户端发起 `FIN` 包（`FIN = 1`）,客户端进入 `FIN_WAIT_1` 状态。`TCP` 规定，即使 `FIN` 包不携带数据，也要消耗一个序号。

- 第二次挥手。服务器端收到 `FIN` 包，发出确认包 `ACK（ack = u + 1）`，并带上自己的序号 `seq=v`，服务器端进入了 `CLOSE_WAIT` 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 `ACK` 后，进入了 `FIN_WAIT_2` 状态。

- 第三次挥手。服务器端数据发送完毕后，向客户端发送 `FIN` 包（`seq=w ack=u+1`），半连接状态下服务器可能又发送了一些数据，假设发送 `seq` 为 `w`。服务器此时进入了 `LAST_ACK` 状态。

- 第四次挥手。客户端收到服务器的 `FIN` 包后，发出确认包（`ACK=1，ack=w+1`），此时客户端就进入了 `TIME_WAIT` 状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MS`L 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 `TCP` 连接的时间要比客户端早一些。


![](./img/四次握手.jpg)

### TIME_WAIT(等待重传)的意义（为什么要等于`2MSL`）

`TIME_WAIT`是指四次挥手中客户端接收了服务端的`FIN`报文并发送`ACK`报文给服务器后，仍然需要等待`2MSL`时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入`CLOSED`状态了，但是我们必须假象网络是不可靠的，有可以最后一个`ACK`丢失。如果客户端发送的`ACK`发生丢失，服务器会再次发送`FIN`报文给客户端，所以`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。

### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当`Server`端收到`Client`端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。其中`ACK`报文是用来应答的，`SYN`报文是用来同步的。但是关闭连接时，当`Server`端收到`FIN`报文时，很可能并不会立即关闭`SOCKET`，所以只能先回复一个`ACK`报文，告诉`Client`端，"你发的`FIN`报文我收到了"。只有等到我`Server`端所有的报文都发送完了，我才能发送`FIN`报文，因此不能一起发送。故需要四步握手。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

`TCP`还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为`2`小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送`10`个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 服务器出现大量`close_wait`的连接的原因以及解决方法

`close_wait`状态是在`TCP`四次挥手的时候收到`FIN`但是没有发送自己的`FIN`时出现的，服务器出现大量`close_wait`状态的原因有两种：

* 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行`close()`方法
* 服务器的父进程派生出子进程，子进程继承了`socket`，收到`FIN`的时候子进程处理但父进程没有处理该信号，导致`socket`的引用不为`0`无法回收

处理方法：

* 停止应用程序
* 修改程序里的bug

### 可以解释一下RTO，RTT和超时重传分别是什么吗？

- 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：

  - 发送的数据没能到达接收端，所以对方没有响应。

  - 接收端接收到数据，但是ACK报文在返回过程中丢失。

  - 接收端拒绝或丢弃数据。

- RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。
  - 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......

  - 重传次数到达上限之后停止重传。

- RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。

## 介绍一下`ping`的过程，分别用到了哪些协议

详见：[`Ping`原理与`ICMP`协议](https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html)

`ping`命令基于网络层的命令，是基于`ICMP`协议工作的。 

`ICMP`:网络控制报文协议

* 首先，`ping`命令会构建一个`ICMP`请求数据包，然后由`ICMP`协议将这个数据包连同目的`IP`地址源`IP`地址一起交给`IP`协议。
* 然后`IP`协议就会构建一个`IP`数据报，并且在映射表中查找目的`IP`对应的`mac`地址，将其交给数据链路层。
* 然后数据链路层就会构建一个数据帧，附上源`mac`地址和目的`mac`地址发送出去。

* 目的主机接收到数据帧后，就会检查包上的`mac`地址与本机`mac`是否相符，如果相符，就接收并把其中的信息提取出来交给`IP`协议，`IP`协议就会将其中的信息提取出来交给`ICMP`协议。然后构建一个`ICMP`应答包，用相同的过程发送回去。
