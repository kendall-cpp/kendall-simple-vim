
- [Socket 模型](#socket-模型)
  - [服务端的 Socket 编程过程](#服务端的-socket-编程过程)
  - [listen 时候参数 backlog 的意义](#listen-时候参数-backlog-的意义)
  - [accept 发生在三次握手的哪一步](#accept-发生在三次握手的哪一步)


----- 

## Socket 模型

要想客户端和服务器能在网络中通信，那必须得使用 `Socket` 编程，`Socket`可以跨主机间通信。

创建 `Socket` 的时候，可以指定网络层使用的是 `IPv4` 还是 `IPv6`，传输层使用的是 `TCP` 还是 `UDP`。

对于 TCP 的 Socket 编程来说

### 服务端的 Socket 编程过程

（1）服务端首先调用 `socket()` 函数，创建网络协议为 `IPv4`，以及传输协议为 `TCP` 的 `Socket` ，接着调用 `bind()` 函数，给这个 `Socket` 绑定一个 `IP` 地址和端口

- 绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。
- 绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，只有相应的网卡收到数据后，才会发给我们；

（2）绑定完 IP 地址和端口号后，就可以调用 `listen()` 函数进行监听，这个时候如果我们要判定服务器中一个网络程序有没有启动，可以通过 `netstat` 命令查看对应的端口号是否有被监听。

（3）服务端进入了监听状态后，通过调用 `accept()` 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。

**那客户端是怎么发起连接的呢**？

（1）客户端在创建好 `Socket` 后，调用 `connect()` 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后 `TCP` 三次握手就开始了。

（2）在 `TCP` 连接的过程中，服务器的内核实际上为每个 `Socket` 维护了两个队列：

一个是`TCP`半连接队列，一个是`TCP`全连接队列。`TCP`半连接队列就是还没完成三次握手的链接，`TCP`全连接队列就是已经完成三次握手的连接。

（3）当 `TCP` 全连接队列不为空后，服务端的 `accept()` 函数，就会从内核中的 `TCP` 全连接队列里拿出一个已经完成连接的 Socket 也就是**已连接套接字**返回给应用程序，后续应用服务器使用这个**已连接套接字**和客户进行通信处理。

连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 `read()` 和 `write()` 函数来读写数据。

当数据传输完成后就会调用`close()`函数关闭连接。

以上就是 `TCP` 协议的 `Socket` 程序的调用过程

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/socket01.5fx6tkyx9lk0.png)


> 前面提到的` TCP Socket` 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是同步阻塞的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。

### listen 时候参数 backlog 的意义

```c
int listen (int socketfd, int backlog)
```

- 第一个参数 socketdf 为套接字描述符

- 第二个参数 backlog ,这个参数的大小决定了**可以接收的并发数目**。但是参数过大也会占用过多的系统资源，一些系统，比如 Linux 并不允许对这个参数进行改变。

早起的 backlog 是 SYN 队列的大小，也就是未完成的队列大小。

### accept 发生在三次握手的哪一步

客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 established `[ɪˈstæblɪʃt]`「已连接」，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答的数据为 `ack = seq + 1`

应答包到大服务端后，服务端协议栈使得 accept 阻塞调用返回，这个时候服务器到客户端的单向连接为建立成功，服务器也进入 established 状态。

> 所以，客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在第三次握手成功之后

