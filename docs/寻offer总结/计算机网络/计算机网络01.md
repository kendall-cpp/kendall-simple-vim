## OSI与TCP/IP各层结构与功能

- OSI的分层(7层)：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
- TCP/IP(4层)：数据链路层、网络层、传输层、应用层
- 五层协议(5层)：物理层、数据链路层、网络层、运输层、应用层

每一层的作用：
- 物理层：底层数据传输，就是利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。如网线；网卡标准。 （比特`Bit`）

- 数据链路层：接收来自物理层的数据，并封装成帧，传送到网络层；如网卡`MAC`地址。（帧Frame）

- 网络层：定义`IP`编址，定义路由选择功能；如不同设备的数据转发。（包Packet）

- 传输层：主要负责端到端之间传输数据；如 `TCP`、`UDP`。（段 Segments）

- 会话层：负责在网络中的两节点之间建立、维持和终止通信；如一个软件的数据分发给另一个软件。

- 表示层：数据格式标识，基本压缩加密功能。

- 应用层：各种应用软件，包括 `Web` 应用。


## DNS 是什么

DNS（Domain Name System）是域名解析系统，就是在因特网上作为域名和IP地址相互映射的分布式数据库系统，能够使用户更方便的去访问互联网，而不用去记住一连串数字的`IP`地址。

通过主机名最终得到这个主机名对应的IP地址，这个过程就做**域名解析**

通俗的说就是我们更习惯去记住一个网站的名字而不是这个网站的IP地址，比如`www.baidu.com`,而不是记住它的`ip`地址，比如：`167.23.10.2`。

## DNS 的工作原理

将主机域名转换为`ip`地址，属于**应用层协议**，使用`UDP`传输。

![](./img/dns-01.png)

`DNS`解析有两种方式：**递归查询**和**迭代查询**

一、主机 向 本地域名服务器的查询一般都是采用**递归查询**。<br>
二、本地域名服务器 向 根域名服务器的查询的**迭代查询**。

![](./img/DNS查询图解.png)

### DNS查询方式有哪些？

- 递归解析

当局部`DNS`服务器自己不能回答客户机的`DNS`查询时，它就需要向其他`DNS`服务器进行查询。**一般是先向该域名的根域名服务器查询，再由根域名服务器一级级向下查询**。最后得到的查询结果返回给局部`DNS`服务器，再由局部`DNS`服务器返回给客户端。

- 迭代解析

局部`DNS`服务器不是自己向其他`DNS`服务器进行查询，**而是把能解析该域名的其他`DNS`服务器的`IP`地址返回给客户端`DNS`程序**，客户端`DNS`程序再继续向这些`DNS`服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：`baidu.com`的服务器`ip`地址在`192.168.4.5`这里，你自己去查吧。

### `DNS`解析过程

如下图所示，详细阐述`DNS`解析流程。

![](./img/dns-02.jpeg)

- 客户机提出域名解析请求，并将该请求发送给本地的域名服务器。

- 当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该记录项，则本地的域名服务器就直接把查询的结果返回。
  
- 如果没有，就到互联网中根服务器去查找，获取`.com`的顶级域名服务器

- 然后在`.com`的顶级域名服务器中进行查找，比如说获取`google.com`的授权域名服务器

- 在`google.com`的授权域名服务器中查找主机`www.google.com`的`IP`地址，最后将`IP`地址返回给计算机。

- 计算机获得`www.google.com`的`IP`地址后，用户就可以访问这个网站了。

### 为什么域名解析用`UDP`协议？

因为`UDP`快啊！`UDP`的`DNS`协议只要一个请求、一个应答就好了。

而使用基于`TCP`的`DNS`协议要三次握手、发送数据以及应答、四次挥手，但是`UDP`协议传输内容不能超过`512`节。

不过客户端向`DNS`服务器查询域名，一般返回的内容都不超过`512`字节，所以用`UDP`传输即可。

一般`DNS`区域传送用的是`TCP`协议

### 为什么 DNS 区域传送用TCP协议

> 区域传送是指将一个区域文件复制到多个`DNS`服务器的过程<br>
> `DNS`主从复制，就是将主`DNS`服务器的解析库复制传送至从`DNS`服务器，进而从服务器就可以进行正向、反向解析了.

因为`TCP`协议可靠性好啊！

以为你要从主`DNS`上复制内容，肯定要保证可靠性啊，`UDP`是不保证传输的可靠性的。

还有，`TCP`协议的传输内容比较大，`UDP`要求传输的内容不能超过`512`字节，如果同步的数据超过`512`那肯定不行呀。

所以用`TCP`协议比较好。

## 什么是TCP粘包/拆包？发生的原因？

一个完整的业务可能会把`TCP`拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是`TCP`的拆包和粘包问题。

### 粘包和拆包原因

（1）要发送的数据小于`TCP`发送缓冲区的大小，`TCP`将多次写入缓冲区的数据一次发送出去，将会发生粘包；

（2）接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；

（3）要发送的数据大于`TCP`发送缓冲区剩余空间大小，将会发生拆包；

（4）待发送数据大于`MSS`（最大报文长度），`TCP`在传输前将进行拆包。即`TCP报文长度-TCP头部长度>MSS`。


### 粘包和拆包解决策略

由于底层的`TCP`无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决

- **消息定长**。发送端将每个数据包封装为固定长度（不够的可以通过补`0`填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- **设置消息边界**。服务端从网络流中按消息边界分离出消息内容。可以在数据包尾部增加回车换行符进行分割，例如`FTP`协议。
- **将消息分为消息头和消息体**，消息头中包含表示消息总长度（或者消息体长度）的字段。
- **使用其它复杂的协议**，如`RTMP`协议等。

> 可以参考：https://blog.csdn.net/ailunlee/article/details/95944377

## 为什么服务器要设置缓存?如何实现的？

**原因**

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

**实现方法**

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。

## 说一下HTTP协议

`HTTP`协议属于**应用层**协议，端口号是`80`。`HTTP`协议被用于网络中两台计算机间的通信，相比于`TCP/IP`这些底层协议，`HTTP`协议更像是高层标记型语言，*浏览器根据从服务器得到的`HTTP`响应体中分别得到报文头，响应头和信息体（`HTML`正文等），之后将`HTML`文件解析并呈现在浏览器上。*

## TCP 与 HTTP 区别与联系

**联系**：

`Http`协议是建立在`TCP`协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次`Http`请求。`Http`会通过`TCP`建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，`Http`会立即将`TCP`连接断开，这个过程是很短的。

**区别**：

`HTTP`和`TCP`位于不同的网络分层。`TCP`是传输层的协议，定义的是数据传输和连接的规范，而`HTTP`是应用层的，定义的是数据的内容的规范。

建立一个`TCP`请求需要进行三次握手，而由于`http`是建立在`tcp`连接之上的，建立一个`http`请求通常包含**请求**和**响应**两个步骤。

## HTTP常见状态码

```
100 ：服务器已经接收到一部分请求，等待其余部分
200 ：请求成功，成功返回网页
301 ：资源（网页等）被永久转移到其它`URL`
302 ：资源（网页等）被临时转移到其它`URL`
401 ：未授权，需要身份认真
403 ：服务器拒绝请求
404 ：请求的网页或资源不存在
500 ：内部服务器错误，无法完成请求
502 ：错误网关
503 ：服务器无法使用，服务器临时过载或宕机
504 ：网关超时
```

1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。


> HTTP 深入介绍清[查看我的另一篇文章](/计算机网络/理解HTTP协议.md)
    
## 什么是SSL/TLS ？

`SSL`：(Secure Socket Layer，**安全套接字层**)，**SSL是传输层的协议**。

`TLS`：**安全传输层协议**(`TLS`)用于在两个通信应用程序之间提供保密性和数据完整性。

`SSL/TLS`协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

## `https`的请求的过程，怎么确保安全性

`https`包括**非对称加密**和**对称加密**两个阶段，在客户端与服务器建立连接的时候使用**非对称加密**，连接建立以后使用的是**对称加密**。

（1）客户端向服务器端发起`SSL`连接请求；<br>
（2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥<br>
（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端<br>
（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，<br>
（5）进行数据传输，服务器和客户端用相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，也就是即使第三方获得数据包，也无法对其进行加密，解密和篡改。<br>

**数字签名**和**摘要**是证书防伪非常关键的武器。“摘要”就是对传输的内容，通过`hash`算法计算出一段固定长度的串。然后，再通过`CA`（`CA`认证，即电子认证服务）的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”。



## `HTTP` 和 `HTTPS`的区别，由`HTTP`升级为`HTTPS`需要做哪些操作

- `http` 是超文本传输协议，信息是明文传输的， `https` 则是具有安全性的 `ssl` 加密传输协议
- `http` 和 `https` 使用的是完全不同的连接方式，用的端口也不一样，`http`是 80 ，`https`是 `443`
- `http` 的连接很简单，是无状态的； `HTTPS` 协议比 `http` 协议更加安全。

- `HTTPS`协议解决了`HTTP`协议的一些不足，因为 `HTTP`：
  - 1.通信使用明文（不加密），内容可能会被盗取
  - 2.不验证通信方身份，因此可能遭遇伪装
  - 3.无法证明报文的完整性（即准确性），所以可能已遭篡改      

> HTTP+加密+认证+完整性保护=HTTPS

由`HTTP`升级为`HTTPS`需要到 `CA` 申请证书，一般免费证书较少，因此需要一定费用

**其实**：

`HTTPS`也不是绝对安全的，针对`SSL`的攻击方式主要有两类，分别是`SSL`劫持攻击和`SSL`剥离攻击。

> 攻击者干预了 `HTTP` 到安全 `HTTPS` 协议的重定向，并拦截了客户端到服务器的请求，攻击者将将自己接入到客户端和目标网站之间； 在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥。并与用户建立不安全的 `HTTP` 连接。

### 如何保证公钥不被篡改？

将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

**公钥加密计算量太大，如何减少耗用的时间**？

每一次对话（`session`），客户端和服务器端都生成一个"**对话密钥**"（`session key`），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
- （1） 客户端向服务器端索要并验证公钥。
- （2） 双方协商生成"对话密钥"。
- （3） 双方采用"对话密钥"进行加密通信。上面过程的前两步，又称为"握手阶段"（handshake）。

## 一次完整的HTTP请求过程包括哪些内容（HTTP工作流程）

- 建立起客户机和服务器连接。
- 建立连接后，客户机发送一个请求给服务器。
- 服务器收到请求给予响应信息。
- 客户端浏览器将返回的内容解析并呈现，断开连接。

## HTTP请求方法你知道多少？

客户端发送的   **请求报文** 第一行为请求行，包含了方法字段。

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。

`HTTP1.0` 定义了三种请求方法： `GET`, `POST` 和 `HEAD`方法。

`HTTP1.1` 新增了六种请求方法：`OPTIONS`、`PUT`、`PATCH`、`DELETE`、`TRACE` 和 `CONNECT` 方法。

| 序  号 | 方法    | 描述                                                         |
| :----- | :------ | :----------------------------------------------------------- |
| 1      | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2      | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3      | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4      | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5      | DELETE  | 请求服务器删除指定的页面。                                   |
| 6      | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7      | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8      | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9      | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

### GET 和 POST 的区别

1. `get`是从服务器上获取数据，`post`向服务器传送数据

2. `get`把请求的数据放在`url`上， 以`?`分割`URL`和传输数据，参数之间以`&`相连，所以`get`不太安全。而`post`把数据放在`HTTP`的包体内（`requrest body`）

3. `get`提交的数据最大是`2k`（ 限制实际上取决于浏览器）， `post`理论上没有限制。

4. `GET`产生一个`TCP`数据包，浏览器会把`http header`和`data`一并发送出去，服务器响应`200`(返回数据); `POST`产生两个`TCP`数据包，浏览器先发送`header`，服务器响应`100 continue`，浏览器再发送`data`，服务器响应`200 ok`(返回数据)。

5. `GET`请求会被浏览器主动缓存，而`POST`不会，除非手动设置。

6. 本质区别：`GET`是幂等的，而`POST`不是幂等的

   > 这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一`URL`的多个请求应该返回同样的结果。

正因为它们有这样的区别，所以不应该且**不能用get请求做数据的增删改这些有副作用的操作**。因为`get`请求是幂等的，**在网络不好的隧道中会尝试重试**。如果用`get`请求增数据，会有**重复操作**的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用`get`请求去做增操作）。

## 在浏览器中输入`URL`后执行的全部过程

1. 首先是域名解析，客户端使用`DNS`协议将`URL`解析为对应的`IP`地址；

2. 然后建立`TCP`连接，客户端与服务器通过三次握手建立`TCP`连接；
   
3. 接着是`http`连接，客户端向服务器发送`http`连接请求； （`http`连接无需额外连接，直接通过已经建立的`TCP`连接发送）
   
4. 服务器对客户端发来的`http`请求进行处理，并返回响应；
   
5. 客户端接收到`http`响应，将结果渲染展示给用户。

![](./img/输入url.png)

### 现代浏览器在与服务器建立了一个 `TCP` 连接后是否会在一个 `HTTP` 请求完成后断开？什么情况下会断开？

在 `HTTP 1.0` 中，一个服务器在发送完一个 `HTTP` 响应后，会断开 `TCP` 连接。也就是**短连接**，但是这样每次请求都会重新建立和断开 `TCP` 连接，代价过大。

意思是说，完成这个 `HTTP` 请求之后，不要断开 `HTTP` 请求使用的 `TCP` 连接。

这样的好处是连接可以被重新使用，之后发送 `HTTP` 请求的时候不需要重新建立 `TCP` 连接。

`HTTP 1.1` 就把 `Connection` 头写进标准，并且默认开启持久连接,也就是**长连接**

除非请求中写明 `Connection：close`，那么浏览器和服务器之间是会维持一段时间的 `TCP` 连接，不会一个请求结束就断掉。

所以，在默认情况下建立 `TCP` 连接不会断开，只有在请求报头中声明 `Connection：close`才会在请求完成后关闭连接。

### `HTTP`长连接和短连接的区别

在`HTTP/1.0`中默认使用短连接。也就是说，客户端和服务器每进行一次`HTTP`操作，就建立一次连接，任务结束就中断连接。

而从`HTTP/1.1`起，默认使用长连接，用以保持连接特性。


**适用场景**：

- 短连接：适用于网页浏览等数据刷新频度较低的场景。

- 长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等

### `http/1.0`和`http/1.1`的区别

`HTTP` 协议老的标准是 `HTTP/1.0` ，目前最通用的标准是 `HTTP/1.1` 。

`HTTP1.0 `是短连接，浏览器的每次请求都需要与服务器建立一个 `TCP` 连接，但是最新的`http/1.1`加入了长连接，只需要在客户端给服务器发送的`http`报文头部加入`Connection:keep-alive`

`HTTP 1.1` 支持持久连接，默认进行持久连接，在一个 `TCP` 连接上可以传送多个 `HTTP` 请求和响应，减少了建立和关闭连接的消耗和延迟。


### 一个`TCP`可以对应几个`HTTP`请求

从上面的分析可知，如果维持连接，一个 `TCP` 连接是可以发送多个 `HTTP` 请求的。


### 一个 `TCP` 连接中 `HTTP` 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）

`HTTP/1.1` 存在一个问题，单个 `TCP` 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 `HTTP` 请求从开始到结束的时间在同一个 `TCP` 连接里不能重叠。

虽然 `HTTP/1.1` 规范中规定了 `Pipelining` 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。所以可以认为这是不可行的。在 `HTTP2` 中由于 `Multiplexing`（多路技术） 特点的存在，多个 `HTTP` 请求可以在同一个 `TCP` 连接中并行进行。

那么在 `HTTP/1.1` 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

- 维持和服务器已经建立的 `TCP` 连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个 `TCP` 连接。

### 为什么有的时候刷新页面不需要重新建立 SSL 连接？

在第一个问题的讨论中已经有答案了，`TCP` 连接有的时候会被浏览器和服务端维持一段时间。`TCP` 不需要重新建立，`SSL` 自然也会用之前的。

### 浏览器对同一 `Host` 建立 `TCP` 连接到数量有没有限制？

假设我们还处在 `HTTP/1.1` 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 `TCP` 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 `TCP` 连接发 `HTTP` 请求，那电脑或者服务器都可能受不了，要是有 `1000` 张图片的话总不能开 `1000` 个`TCP` 连接吧，你的电脑同意 `NAT` 也不一定会同意。

**有。`Chrome` 最多允许对同一个 `Host` 建立六个 `TCP` 连接。不同的浏览器有一些区别。**

如果图片都是 `HTTPS` 连接并且在同一个域名下，那么浏览器在 `SSL` 握手之后会和服务器商量能不能用 `HTTP2`，如果能的话就使用 `Multiplexing` 功能在这个连接上进行多路传输。*不过也未必会所有挂在这个域名的资源都会使用一个 `TCP` 连接去获取，但是可以确定的是 `Multiplexing` 很可能会被用到。*

如果发现用不了 `HTTP2` 呢？或者用不了 `HTTPS`（现实中的 `HTTP2` 都是在` HTTPS` 上实现的，所以也就是只能使用 `HTTP/1.1`）。那浏览器就会在一个 `HOST` 上建立多个 `TCP` 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。

## `HTTP`是不保存状态的协议,如何保存用户状态?
- `HTTP` 是一种不保存状态，即无状态（`stateless`）协议。也就是说 `HTTP` 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？`Session` 机制的存在就是为了解决这个问题，`Session` 的主要作用**就是通过服务端记录用户的状态**。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 `HTTP` 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 `Session`，过了时间限制，就会销毁这个`Session`）。

- 在服务端保存 `Session` 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库`redis`保存)。既然 `Session` 存放在服务器端，那么我们如何实现 `Session `跟踪呢？大部分情况下，我们都是通过在 `Cookie` 中附加一个 `Session ID` 来方式来跟踪。

### `Cookie` 被禁用怎么办?

最常用的就是利用 `URL` 重写把 `Session ID` 直接附加在`URL`路径的后面。

### `Cookie`的作用是什么?和`Session`有什么区别？

`Cookie` 和 `Session`都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

- `Cookie` 一般用来保存用户信息 比如
  - ①我们在 `Cookie` 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；
  - ②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 `Token` 在 `Cookie` 中，下次登录的时候只需要根据 `Token` 值来查找用户即可(为了安全考虑，重新登录一般要将 `Token` 重写)；
  - ③登录一次网站后访问网站其他页面不需要重新登录。
- `Session` 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 `HTTP` 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了。

`Cookie` 数据保存在客户端(浏览器端)`，Session` 数据保存在服务器端。

`Cookie` 存储在客户端中，而`Session`存储在服务器上，相对来说 `Session` 安全性更高。如果使用 `Cookie` 的一些敏感信息不要写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。

## HTTP请求和响应报文有哪些主要字段

**http协议报文**
- 1.**请求报文**
  * **请求行** <br>
  请求求方法字段、`URL`字段和`HTTP`协议版本<br>
  例如：`GET /index.html HTTP/1.1`<br>
      `get`方法将数据直接拼接在`url`后面<br>
  请求方法：`HEAD`（`http/1.0`）、`GET`、`POST`、`PUT`、`DELETE`、`OPTIONS`、`TRACE`、`CONNECT`

   * **请求头**(`key value`形式)<br>
        `User-Agent`：产生请求的浏览器类型。<br>
        `Accept`：客户端可识别的内容类型列表。<br>
        `Host`：主机地址<br>
    * **请求体**<br>
        `post`方法中，会把数据以`key value`形式发送请求<br>
    * **空行**<br>
        发送回车符和换行符，通知服务器以下不再有请求头<br>
- 2.**响应报文**
    * 状态行
    * 消息报头
    * 响应正文
      



## ARP请求报文组成

![](./img/01tcpip04.png)

- 硬件类型：定义物理地址的类型，它的值为`1`表示`MAC`地址
- 协议类型字段表示要映射的映射的协议地址类型，它的值 `0x800`, 表示IP地址。
- 硬件地址长度字段和协议地址长度字段，单位是字节。对`MAC`地址类说，其长度是`6`，`IPv4`地址来说，其长度为`4`.
- 操作字段支出`4`种操作字段，`ARP`请求（值为`1`）、`ARP` 应答（值为`2`）、`RARP` 请求（值为`3`）和 `RARP` 应答（值为`4`）
- 最后`4`个字段指定通信双方的以太网地址和`IP`地址,发送端填充除目的端口`IP`地址是自己，就把自己的以太网地址填进去，然后交换两个目的端地址和两个发送端地址，以构建`ARP`应答返回之。

### ARP协议工作原理

- 1.每个主机都会在自己的`ARP`缓冲区中建立一个`ARP`列表,用来表示 IP 地址和 `MAC` 地址之间的对应关系。
- 2.主机（网络接口）**新加入网络时**（也可能只是mac地址发生变化，接口重启等）， 会发送免费`ARP`报文把自己IP地址与Mac地址的映射关系广播给其他主机。
- 3.网络上的主机接收到免费`ARP`报文时，会更新自己的`ARP`缓冲区。将新的映射关系更新到自己的`ARP`表中
- 4.某个主机需要发送报文时，首先检查 `ARP` 列表中是否有对应 `IP` 地址的目的主机的 `MAC` 地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送 `ARP` 数据包，该数据包包括的内容有：源主机 `IP` 地址，源主机 `MAC` 地址，目的主机的 `IP` 地址等。
- 5.当本网络的所有主机收到该 `ARP` 数据包时：
  - （A）首先检查数据包中的 `IP` 地址是否是自己的 `IP` 地址，如果不是，则忽略该数据包。
  - （B）如果是，则首先从数据包中取出源主机的 `IP` 和 `MAC` 地址写入到 `ARP` 列表中，如果已经存在，则覆盖。
  - （C） 然后将自己的 `MAC` 地址写入 `ARP` 响应包中，告诉源主机自己是它想要找的 `MAC` 地址。
- 6.源主机收到 `ARP` 响应包后。将目的主机的 `IP` 和 `MAC` 地址写入 `ARP` 列表，并利用此信息发送数据。如果源主机一直没有收到 `ARP` 响应数据包，表示 `ARP` 查询失败。






