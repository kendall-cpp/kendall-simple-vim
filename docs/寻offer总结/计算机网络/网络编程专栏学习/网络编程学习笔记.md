
- [套接字和地址](#套接字和地址)
  - [套接字地址结构](#套接字地址结构)
  - [IPv4 套接字格式地址](#ipv4-套接字格式地址)
  - [IPv6 套接字地址格式](#ipv6-套接字地址格式)
  - [本地套接字](#本地套接字)
- [使用套接字](#使用套接字)
  - [socket创建套接字](#socket创建套接字)
  - [bind](#bind)
    - [设置通配地址「bind前的处理」](#设置通配地址bind前的处理)
    - [关于大端小端「字节序」](#关于大端小端字节序)
    - [初始化 IPv4 TCP 套接字的例子](#初始化-ipv4-tcp-套接字的例子)
  - [listen](#listen)
  - [accept](#accept)
  - [connect](#connect)
- [使用套接字进行读写](#使用套接字进行读写)
  - [发送数据](#发送数据)
  - [发送缓冲区](#发送缓冲区)
    - [TCP 包过大会怎样](#tcp-包过大会怎样)
  - [read 函数](#read-函数)
  - [缓冲区实验](#缓冲区实验)
    - [服务器端读取数据程序](#服务器端读取数据程序)
    - [客户端发送数据程序](#客户端发送数据程序)

------

## 套接字和地址

### 套接字地址结构

套接字的通用地址结构：

```c

/* POSIX.1g 规范规定了地址族为2字节的值.  */
typedef unsigned short int sa_family_t;
/* 描述通用套接字地址  */
struct sockaddr {
    sa_family_t sa_family;  /* 地址族.  16-bit*/
    char sa_data[14];   /* 具体的地址值 112-bit */
  }; 
```

在这个结构体里，**第一个字段是地址族，它表示使用什么样的方式对地址进行解释和保存**，好比电话簿里的手机格式，或者是固话格式，这两种格式的长度和含义都是不同的。地址族在 glibc 里的定义非常多，常用的有以下几种：

- AF_LOCAL：表示的是本地地址，对应的是 Unix 套接字，这种情况一般用于本地 socket 通信，很多情况下也可以写成 AF_UNIX、AF_FILE；
- AF_INET：因特网使用的 IPv4 地址；
- AF_INET6：因特网使用的 IPv6 地址。

### IPv4 套接字格式地址

```c

/* IPV4套接字地址，32bit值.  */
typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
  
/* 描述IPV4的套接字地址格式  */
struct sockaddr_in
  {
    sa_family_t sin_family; /* 16-bit */  //AF_INET
    in_port_t sin_port;     /* 端口号  16-bit*/
    struct in_addr sin_addr;    /* Internet address. 32-bit */


    /* 这里仅仅用作占位符，不做实际用处  */
    unsigned char sin_zero[8];
  };
```

和 sockaddr 一样，都有一个 16-bit 的 sin_family 字段，对于 IPv4 来说这个值就是 AF_INET。

### IPv6 套接字地址格式


```c
struct sockaddr_in6
  {
    sa_family_t sin6_family; /* 16-bit */  //AF_INET6
    in_port_t sin6_port;  /* 传输端口号 # 16-bit */
    uint32_t sin6_flowinfo; /* IPv6流控信息 32-bit*/
    struct in6_addr sin6_addr;  /* IPv6地址128-bit */
    uint32_t sin6_scope_id; /* IPv6域ID 32-bit */
  };
```

对于 IPv6 来说，sin6_family 这个值是：AF_INET6

### 本地套接字

以上无论 IPv4 还是 IPv6 的地址格式都是因特网套接字的格式，还有一种本地套接字格式，用来作为本地进程间的通信， 也就是前面提到的 AF_LOCAL。

```c
struct sockaddr_un {
    unsigned short sun_family; /* 固定为 AF_LOCAL */
    char sun_path[108];   /* 路径名 */
};
```

## 使用套接字

### socket创建套接字

> 可以指定网络层使用的是 IPV4 还是 IPV6，传输层使用的是 TCP 还是 UDP。
>
> 一般我们用 AF_xxx 这样的值来初始化 socket 地址，用 PF_xxx 这样的值来初始化 socket。

```c
int socket(int domain, int type, int protocol)   //返回值：socketfd
```

- domian: PF_INET、PF_INET6 以及 PF_LOCAL 等 (或者AF_INET、AF_INET6 以及 AF_LOCAL )
- type 可用的值是：
  - **SOCK_STREAM**: 表示的是字节流，对应 TCP；
  - **SOCK_DGRAM**： 表示的是数据报，对应 UDP；
  - **SOCK_RAW**: 表示的是原始套接字。

- protocol 原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。protocol 目前一般写成 0 即可。


### bind

调用 bind 函数把套接字和套接字地址绑定

```cpp
bind(int fd, sockaddr * addr, socklen_t len)
```

- fd: 就是 socket 返回的 socketfd
- `sockaddr * addr`: 传入的参数可能是 IPv4 (AF_INET)、IPv6 (AF_INET6) 或者本地套接字格式
- len 字段表示的就是传入的地址长度

在绑定 bind 的时候需要对地址和端口进行处理

我们可以把地址设置成本机的 IP 地址，这相当告诉操作系统内核，仅仅对目标 IP 是本机 IP 地址的 IP 包进行处理。但是这样写的程序在部署时有一个问题，我们编写应用程序时并不清楚自己的应用程序将会被部署到哪台机器上。这个时候，就需要 **通配地址** 。

#### 设置通配地址「bind前的处理」

- 对于 IPv4 的地址来说，使用 INADDR_ANY 来完成通配地址的设置
- 对于 IPv6 的地址来说，使用 IN6ADDR_ANY 来完成通配地址的设置。

```cpp
struct sockaddr_in name;
name.sin_addr.s_addr = htonl (INADDR_ANY); /* IPV4通配地址 */
```

除了地址，还有端口。如果把端口设置成 0，就相当于把端口的选择权交给操作系统内核来处理，操作系统内核会根据一定的算法选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用。

#### 关于大端小端「字节序」

计算机有两种存储数据的方式:**大端字节序** （big endian）和**小段字节序**（little endian）。

>- 大端字节序：高位字节在前面，低位字节在后面,这符合人类的读写数值方法
>- 小端字节序：地位字节在前面，高位字节在后面。

计算机都是从低位开始处理字节效率比较高，因为计算都是从低位开始的，因此计算机内部都是小端字节序。            
但是人类比较习惯大端字节序，所以除了计算机内部处理，其他场合一般都用大端字节序，比如网络参数，文件存储。

注意：**只有读取的时候，才必须区分字节序，其他情况都不用考虑。**  

> 处理器读取外部数据的时候，必须知道数据的字节序，将其转成正确的值。然后，就正常使用这个值，完全不用再考虑字节序。
>       
> 即使是向外部设备写入数据，也不用考虑字节序，正常写入一个值即可。外部设备会自己处理字节序的问题。

- 网络字节序和主机字节序的转换函数

```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

`h`表示`host`，`n`表示`network`，`l`表示`32`位长整数，`s`表示`16`位短整数。

#### 初始化 IPv4 TCP 套接字的例子

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>

int make_socket(uint16_t port) {  //传入端口号

    int socketfd;
    struct sockaddr_in name;  //IPv4 套接字

    //创建字节流类型的IPV4 socket
    socketfd = socket(PF_INET,SOCK_STREAM,0);  //初始化 socket,使用PF_XXXX
    if(socketfd < 0) {
        perror("soocket");
        eixt(EXIT_FAILURE);
    }

    //绑定到port和ip  bind 前需要处理，设置通配地址
    //初始化socket地址，使用AF_XXXX
    name.sin_family = AF_INET;
    name.sin_port = htons(port);
    name.sin_addr.s_addr = htonl(INADDR_ANY);   //IPV4通配地址

    // 把IPV4地址转换成通用地址格式，同时传递长度
    //bind(int fd, sockaddr * addr, socklen_t len)
    if( bind(socketfd,(struct sockaddr *) &name,sizeof(name)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    //返回创建好的套接字描述符
    return socketfd;
}
```

### listen

> 绑定完 IP 地址和端口号后，就可以调用 `listen()` 函数进行监听，这个时候如果我们要判定服务器中一个网络程序有没有启动，可以通过 `netstat` 命令查看对应的端口号是否有被监听。

```c
int listen (int socketfd, int backlog)
```

- 第一个参数 socketdf 为套接字描述符

- 第二个参数 backlog ,这个参数的大小决定了可以接收的并发数目。但是参数过大也会占用过多的系统资源，一些系统，比如 Linux 并不允许对这个参数进行改变。

> 典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的`accept()`返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未`accept`的客户端就处于连接等待状态，`listen()`声明`sockfd`处于监听状态，并且最多允许有`backlog`个客户端处于连接待状态。

### accept

> 服务端进入了监听状态后，通过调用 `accept()` 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。

```c
int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)
```

- 第一个参数 listensockfd 是 listen 套接字，因为这就是前面通过 bind，listen 一系列操作而得到的套接字

- 后面两个是传输参数：
  - 第一个部分 cliadd 是通过指针方式获取的客户端的地址(通用套接字形式），addrlen 告诉我们地址的大小（`sizeof(cliaddr）`)

- 返回值：成功返回一个新的`socket`套接字描述符，用于和客户端通信。

这里一定要注意有**两个套接字描述字**，第一个是监听套接字描述字 `listensockfd`「**监听套接字**」，它是作为输入参数存在的；第二个是返回的是「**已连接套接字**」。

创建好已连接套接字之后，服务端就用这个已连接套接字和客户端通信，完成通信后，就**关闭的这一个客户端的已连接套接字**，
这样就完成了 TCP 连接的释放。

**客户端发起连接的过程**

客户端在创建好 Socket 后，调用 `connect()` 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后 TCP 三次握手就开始了。

### connect

```c
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)
```

- 第一个参数 sockfd 是连接套接字，通过前面讲述的 socket 函数创建。
- 第二个、第三个参数 servaddr 和 addrlen 分别代表指向套接字地址结构的指针和该结构的大小。套接字地址结构必须含有服务器的 IP 地址和端口号。

> TCP 三次握手发生在这个阶段


## 使用套接字进行读写

### 发送数据

发送数据时常用的有三个函数，分别是 write、send 和 sendmsg。

```c

ssize_t write (int socketfd, const void *buffer, size_t size)
ssize_t send (int socketfd, const void *buffer, size_t size, int flags)
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
```

- 第一个函数是常见的文件写函数，如果把 socketfd 换成文件描述符，就是普通的文件写入。

- 如果想发送带外数据，就需要使用第二个带 flag 的函数。所谓带外数据，是一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理。

- 如果想指定多重缓冲区传输数据，就需要使用第三个函数，以结构体 msghdr 的方式发送数据。

### 发送缓冲区

当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如**发送缓冲区**。

发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write 函数时，实际所做的事情是**把数据从应用程序中拷贝到操作系统内核的发送缓冲区中**，并不一定是把数据通过套接字写出去。

- 如果内核的发送缓冲区足够大，那么我们的程序从`write()`调用结束退出后，返回的字节数就是应用程序的数据大小。

- 发送缓冲区不足以容纳所有的应用程序数据，这时候应用程序被阻塞，也就是应用程序在`write()`函数调用处停留，不直接返回。

#### TCP 包过大会怎样

> TCP UDP 数据包过大导致分片

`MTU`大家都知道，是链路层中的网络对数据帧的一个限制，以太网为例，`MTU`为`1500`个字节。一个IP数据报在以太网中传输，如果它的长度大于该`MTU`值，就要进行分片传输，使得每片数据报的长度小`于MTU`。不过分片传输的`IP`数据报不一定按序到达，但`IP`首部中的信息能让这些数据报片按序组装。`IP`数据报的分片与重组是在网络层进完成的。

**MSS（最大分段大小）**

`MSS`是`TCP`首部的一个字段，`MSS`是`TCP`数据包每次能够传输的最大数据分段，`TCP`报文段的长度大于`MSS`时，要进行分段传输。`MSS`选项只出现在`SYN`报文段中，即`TCP`三次握手的前两次。`MSS`的值一般为`MTU`值减去两个首部大小。 

再来看`UDP`数据报，由于`UDP`数据报不会自己进行分段，因此当长度超过了`MTU`时，会在网络层进行`IP`分片。同样，`ICMP`（在网络层中）同样会出现`IP`分片情况。  
   
**总结：`UDP`不会分段，就由`IP`来分。`TCP`会分段，当然就不用`IP`来分了！**

> PS: **内核缓冲区总是充满数据时会产生粘包问题**



### read 函数

```c
ssize_t read (int socketfd, void *buffer, size_t size)
```

read 函数要求操作系统内核从套接字描述字 socketfd 读取最多多少个字节（size），并将结果存储到 buffer 中。**返回值告诉我们实际读取的字节数目**，也有一些特殊情况，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断开连接的情况；如果返回值为 -1，表示出错。

注意这里是最多读取 size 个字节。如果我们想让应用程序每次都读到 size 个字节，就需要编写下面的函数，不断地循环读取。

```c
#include <stdio.h>
#include <errno.h>

size_t readn(int fd,void *buffer,size_t size) 
{
    char *buffer_pointer = buffer;
    int lenght = size;

    //循环条件表示的是，在没读满 size 个字节之前，一直都要循环下去
    while(lenght > 0) {
        int result = read(fd,buffer_pointer,lenght);

        if(result < 0) {
            // 非阻塞 I/O 的情况下，没有数据可以读，需要继续调用 read
            // 考虑非阻塞的情况，这里需要再次调用read
            if(errno == EINTR) {
                continue;
            }
            else {
                return -1;
            }
        }
        // 表示读到对方发出的 FIN 包，表现形式是 EOF，此时需要关闭套接字
        else if(result == 0) //如果返回值为 0，表示 EOF
        {
            break;
        }
        // 需要读取的字符数减少，缓存指针往下移动。
        lenght -= result;
        buffer_pointer += result;  //指针移动result个
    }
    // 返回的是实际读取的字节数
    return (size - lenght); //在读取 EOF 跳出循环后，返回实际读取的字符数
}
```

### 缓冲区实验

我们用一个客户端 - 服务器的例子来解释一下读取缓冲区和发送缓冲区的概念。在这个例子中客户端不断地发送数据，服务器端每读取一段数据之后进行休眠，以模拟实际业务处理所需要的时间。

#### 服务器端读取数据程序

```c
// #include "../lib/common.h"
#include <string.h>

void read_data(int sockfd) 
{
    ssize_t n;
    char buf[1024];

    int time = 0; //执行次数

    // 实际每次读取 1K 数据，之后休眠 1 秒，用来模拟服务器端处理时延
    for(;;) {
        fprintf(stdout,"block in read\n");
        if(readn(sockfd,buf,n) == 0) {  //==0说明数据完了，readn返回的是读取的字符长度
            return;
        }
    }
    fprintf(stdout, "1K read for %d \n", time);
    // 睡眠
    usleep(1000);
}

int main(int argc,char **argv) {

    int listenfd,connfd;  //listenfd：监听套接字，connfd： 已连接套接字
    socklen_t client;  //客户端数量

    struct sockaddr_in cliaddr,servaddr;  //创建ipv4的客户端和服务端套接字

// SOCK_STREAM: 表示的是字节流，对应 TCP； SOCK_DGRAM： 表示的是数据报，对应 UDP；
    listenfd = socket(AF_INET,SOCK_STREAM,0) ;

    //初始化
    // extern void bzero(void *s, int n)  置字节字符串s的前n个字节为零且包括‘\0’
    // extern void *memset(void *buffer, int c, int count) 把buffer所指内存区域的前count个字节设置成c的值。
    bzero(&servaddr,sizeof(servaddr));  //把servaddr初始化为0
    servaddr.sin_family = AF_INET;   //这是协议族为IPV4
    servaddr.sin_port = htons(12345);
    //通配地址
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);  //IPv4

    //bind到本地地址，端口为12345
    // bind(int fd, sockaddr * addr, socklen_t len)
    bind(listenfd,(struct sockaddr*) &servaddr, sizeof(servaddr)) ;
    //listen的backlog为1024
    // int listen (int socketfd, int backlog)
    listen(listenfd,1024);

    //循环处理用户请求 accept()
    for(;;)
    {
        //看有多少个客户端
        client = sizeof(cliaddr);
        // int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)
        //cliaddr在accept函数中是传了一个地址的，这相当于是accept函数的输出参数，这样就可以知道连接上来的客户端的信息，比如IP。
        connfd = accept(listenfd,(struct sockaddr *) &cliaddr,&client);
        read_data(connfd); // 开始读取数据  //运行完后悔休眠1秒
        close(connfd); //关闭连接套接字，注意不是监听套接字
    }

}
```

#### 客户端发送数据程序







