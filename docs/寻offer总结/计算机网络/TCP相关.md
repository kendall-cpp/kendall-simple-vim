
<!-- vscode-markdown-toc -->

- [TCP 头部](#tcp-头部)
- [为什么需要TCP，TCP工作在哪一层](#为什么需要tcptcp工作在哪一层)
  - [如何确定 TCP 连接](#如何确定-tcp-连接)
- [TCP的最大连接数是多少](#tcp的最大连接数是多少)
- [UDP 头部](#udp-头部)
- [TCP 和 UDP 的区别](#tcp-和-udp-的区别)
  - [TCP 和 UDP 应用场景：](#tcp-和-udp-应用场景)
  - [为什么 UDP 头部没有首部长度字段，而 TCP 头部有呢](#为什么-udp-头部没有首部长度字段而-tcp-头部有呢)
  - [为什么 UDP 头部有包长度字段，而 TCP 头部则没有呢](#为什么-udp-头部有包长度字段而-tcp-头部则没有呢)
- [MTU 和 MSS](#mtu-和-mss)
- [TCP 三次握手](#tcp-三次握手)
  - [为什么使用三次握手，两次握手可不可以？](#为什么使用三次握手两次握手可不可以)
  - [为什么客户端和服务端的初始序列号 ISN 是不相同的](#为什么客户端和服务端的初始序列号-isn-是不相同的)
    - [ISN 是固定不变的吗？](#isn-是固定不变的吗)
- [SYN 攻击](#syn-攻击)
  - [避免 SYN 攻击](#避免-syn-攻击)
  - [什么是半连接队列](#什么是半连接队列)
  - [最后一个 ACK 丢失了会怎样](#最后一个-ack-丢失了会怎样)
  - [如何查看 TCP 状态](#如何查看-tcp-状态)
- [四次挥手过程](#四次挥手过程)
  - [为什么连接的时候是三次握手，关闭的时候却是四次握手](#为什么连接的时候是三次握手关闭的时候却是四次握手)
  - [TIME_WAIT 为什么要等于`2MSL`](#time_wait-为什么要等于2msl)
    - [MSL 与 TTL 的区别](#msl-与-ttl-的区别)
    - [Time_wait状态的链接过多会怎样](#time_wait状态的链接过多会怎样)
    - [如何优化Time_wait](#如何优化time_wait)
  - [如果已经建立了连接，但是客户端突然出现故障了怎么办](#如果已经建立了连接但是客户端突然出现故障了怎么办)
- [TCP怎么保证可靠传输的](#tcp怎么保证可靠传输的)
  - [RTT 和 RTO 是什么](#rtt-和-rto-是什么)
  - [滑动窗口](#滑动窗口)

------

## TCP 头部

> `TCP`的全部功能体现在它首部中的各字段的中。tcp 首部有 20 个字节

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/OfficialAccounts/tcp首部.3bk2olobrrm0.png)


（1）源端口，`2`个字节；发送报文的进程的端口号

（2）目的端口，`2`个字节；接收报文的进程的端口号

（3）序号：`seq`序列号，占 4 个字节，在建立连接时由计算机随机生成的随机数，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次这个「数据字节数」的大小。，用来**解决网络包乱序的问题**。

（4）确认号：`ack`序号，占`4`个字节，就是指下一次 期望 收到的数据的序列号。只有当标志位中的 `ACK` 标志为 `1` 时该确认号的字段才有效。主要**用来解决不丢包的问题**。


（5）标志位：共`6`个，即`ACK`、`FIN`、`P·`、`RST`、`SYN`、`URG`等，具体含义如下： `afprsu`

    ACK：为确认序号，一旦建立接收端接受数据之后，就将 ACK 置为 1。
    
    FIN：为结束序号，用于发送端提出断开连接；
    
    PSH：指示接收方立即将数据提交给应用层，而不是等待缓冲区满；
    
    RST：该位如果为 1，表示 TCP 连接中出现异常必须强制断开连接
    
    SYN：为同步标志，用于数据同步
    
    URG：为紧急序号，URG=1 是紧急指针有效；

（6）检验和：占`2`字节，用于检验数据的完整性

## 为什么需要TCP，TCP工作在哪一层

IP 层是「不可靠」的，不提供可靠的传输服务、也不保证网络数据包的完整性。

如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。

因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络数据包是无差错，不丢失，不重复，且有序。

### 如何确定 TCP 连接

TCP 四元祖可以唯一确定 TCP 连接

- 源地址
- 源端口号
- 目的地址
- 目的端口号

源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

## TCP的最大连接数是多少

> 有一个 IP 的服务器监听了一个端口，它的TCP的最大连接数是多少?

服务器的 IP 地址和端口号一般是固定不变的，等待客户端的连接请求。

客户端 IP 和 端口是可变的，其理论值计算公式如下:

> 最大 TCP 连接数 = 客户端的 IP 数 * 客户端的端口数

- 对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最 大 TCP 连接数，约为 2 的 48 次方。

- 当然，服务端最大并发 TCP 连接数远不能达到理论上限
  - 首先主要是**文件描述符限制**，Socket 都是文件，所以首先要通过 `ulimit` 配置文件描述符的数目;
  - 另一个是**内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的。

## UDP 头部

> 首部字段很简单，只有`8`个字节

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/udp头部.20nt6p2qxqw0.png)

- （1）源端口：发送报文的进程的端口号。在需要对方回信时选用。不需要时可用全`0`。

- （2）目的端口：接收报文的进程的端口号。在终点交付报文时使用。

- （3）包长度：`UDP`用户数据报的长度，其最小值是`8`（仅有首部）。

- （4）检验和：检测`UDP`用户数据报在传输中是否有错。有错就丢弃。

## TCP 和 UDP 的区别

1. 连接

- TCP 是面向连接的传输层协议，传输数据前要通过三次握手建立连接。
- UDP 是不需要连接，即刻就可以传输数据。

2. 服务对象

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

3. 可靠性

- TCP 的通信信道是全双工可靠信道，数据可以无差错、不丢失、不重复、且有序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。

4. 拥塞控制、流量控制

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

5. 首部开销

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
  
6. 传输方式

- TCP 是面向字节流的，没有边界，可能会出现粘包问题
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

7. 分片不同

TCP 的数据大小如果大于 MSS「TCP 最大分段长度」时，则会在传输层进行**分片**，目标主机收到后，也同样在传输层**组装** TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片就可以了。

UDP 的数据大小如果大于 MTU 大小，则会在 **IP 层**进行分片，目标主机收到后，在 IP 层**组装**完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输效率非常差，所以通常 UDP 的报文应该小于 MTU。

### TCP 和 UDP 应用场景：

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP 文件传输
- HTTP / HTTPS

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP 等
- 视频、音频等多媒体通信
- 广播通信

### 为什么 UDP 头部没有首部长度字段，而 TCP 头部有呢

原因是 TCP 有**可变长**的「选项」字段，而 UDP 头部长度则是**不会变化**的，无需多一个字段去记录 UDP 的首部长度。

### 为什么 UDP 头部有包长度字段，而 TCP 头部则没有呢

> TCP 数据的长度 = IP 总长度 - IP 首部长度 - TCP 首部长度

其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。

> 那么：“ UDP 也是基于 IP 层的，那 UDP 的数据长度也可以通过这个公式计算？ 为何还要有「包长度」呢？”

这么一问，确实感觉 UDP 「包长度」是冗余的。

因为为了网络设备硬件设计和处理方便，首部长度需要是 4 字节的整数倍。

如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段。

## MTU 和 MSS

- MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
- MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。「TCP 最大分段长度」

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/tcp分割数据.66xmbk7p3ig0.png)

> 如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？

> 传输层 < == > 网络层

当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。

这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。

因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时重传。

当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。

因此，IP 层进行分片传输，是非常没有效率的。

所以，**为了达到最佳的传输效能** TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。


经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是**以 MSS 为单位，而不用重传所有的分片**，大大增加了重传的效率。

> IP 片丢失，IP 没有重装机制，有 TCP 负责，所以效率低       
> TCP 就进行分片，也保证了不超过 MTU，提高效率

## TCP 三次握手

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/三次握手.4vj51xsb8mc0.png)

- 第一次握手：

客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号`ISN`(比如是`100`)，那客户端向服务端发送的报文段包含同步序号`SYN`标志位(也就是`SYN=1`)，序列号`seq=100`。

这时候`client`处于同步状态`SYN_SENT`。也就是可以建立连接。服务端处于监听状态`LISTEN`。

- 第二次握手

服务端收到客户端发过来的报文后，发现同步序号`SYN=1`，知道这是一个连接请求，于是将客户端的起始序列号`100`存起来，并且随机生成一个服务端的起始序列号(比如是`300`)。然后给客户端回复一段报文，回复报文包含`SYN`和`ACK`标志(也就是`SYN=1`,`ACK=1`)、序列号`seq=300`、确认号`ack=101`(*客户端发过来的序列号+1*)。

这个时候服务端处于`SYN_RECV`同步接收状态。

- 第三次握手

客户端收到服务端的回复后发现`ACK=1`并且`ack=101`,于是知道服务端已经收到了序列号为`100`的那段报文；同时发现`SYN=1`，知道了服务端同意了这次连接，于是就将服务端的序列号`300`给存下来。然后客户端再回复一段报文给服务端，报文包含`ACK`标志位(`ACK=1`)、`ack=301`(*服务端序列号+1*)、`seq=101`(第一次握手时发送报文是占据一个序列号的，所以这次`seq`就从`101`开始，需要注意的是不携带数据的`ACK`报文是不占据序列号的，所以后面第一次正式发送数据时`seq`还是`101`)。当服务端收到报文后发现`ACK=1`并且`ack=301`，就知道客户端收到序列号为`300`的报文了，就这样客户端和服务端通过`TCP`建立了连接。


> 上面过程中，**第三次捂手是可以携带数据的，前两次握手不可以携带数据。**        
> 一旦完成三次握手，双方都处于 ESTABLISHED「已连接」 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

### 为什么使用三次握手，两次握手可不可以？

- **三次握手可以阻止重复历史连接的初始化**

简单的说就是防止旧的重复连接初始化造成混乱。

因为网络环境是错综复杂的，往往并没有我们期望的一样，先发送数据包，就先到达主机。可能由于网络堵塞等一些乱七八糟的原因会使得旧的数据包先到达目标主机。

就比如一个旧的`SYN`报文比最新的`SYN`报文先到达服务端，那么服务端就会给客户端返回一个 `SYN+ACK` 报文。如果是三次握手的话，客户端收到这个报文后可以根据自己的上下文判断这是不是一个历史连接（通过序列号过期或者超时判断），如果是历史连接，客户端就会给服务端发送一个 `RST` 报文给服务端，表示终止这一次连接。当然如果不是历史连接就发送一个`ACK`报文，双方就会成功建立链接。

但是如果是两次握手，客户端就不能判断连接是否是历史连接。

- **三次握手可以同步双方的初始序列号**

当客户端发送携带[初始序号`seq`]的 `SYN`报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 `SYN` 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。

而两次握手只能保证一方的初始序号被对方接收，不能保证双方的初始序号都能被确认接收。

- **三次握手才可以避免资源浪费**

如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的连接的 ACK 确认号，所以没收到一个 SYN 就只能先主动建立一个连接。

那么如果服务端发送回给客户端的 ACK 报文阻塞了，那么客户端由于没有收到 ACK 确认号，就会重复多次发送 SYN 报文，那么服务器在收到请求连接报文后就会**建立多个冗余的无效连接**。造成不必要的资源浪费。

> 四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，没必要两次握手来分别发送 ACK 报文 和 SYN 报文。所以就成了「三次握手」

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/四次握手.6az8xsuu6sg0.png)

### 为什么客户端和服务端的初始序列号 ISN 是不相同的

如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱。

所以，每次建立连接前重新初始化一个序列号主要是**为了通信双方能够根据序号将不属于本连接的报文段丢弃**。

另一方面是为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。

#### ISN 是固定不变的吗？

`ISN` 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 `ISN` 是动态生成的

## SYN 攻击

假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。

### 避免 SYN 攻击

1. 方式一

其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。

- 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值参数：`net.core.netdev_max_backlog`

- SYN_RCVD 状态连接的最大个数：`net.ipv4.tcp_max_syn_backlog`

- 超出处理能时，对新的 SYN 直接返回 RST 报文，丢弃连接：`net.ipv4.tcp_abort_on_overflow`

2. 方式二

分析这个要从 Linux 内核中的 SYN （未完成连接建立）队列与 Accpet （已完成连接建立）队列是如何工作入手分析。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/SYN攻击避免01.3fi25a873ee0.png)

正常流程：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出连接。

不正常的情况是：

- 应用处理过慢

如果应用程序过慢时，就会导致「 Accept 队列」被占满。

- 受到攻击

如果不断收到 SYN 攻击，就会导致「 SYN 队列」被占满。

设置 `net.ipv4.tcp_syncookies = 1`的方式可以应对 SYN 攻击

**大致流程是**：

    - 当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；
    - 计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，
    - 服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接- 放入到「 Accept 队列」。
    - 最后应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出的连接。

### 什么是半连接队列

服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。


### 最后一个 ACK 丢失了会怎样

- **Server 端**

第三次的ACK在网络中丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。

而Server重发SYN+ACK包的次数，可以通过设置`/proc/sys/net/ipv4/tcp_synack_retries`修改，默认值为5.

如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。

- **Client 端**

在linux c 中，client 一般是通过 `connect()` 函数来连接服务器的，而 `connect()`是在 TCP 的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK 包，它的 TCP 连接状态就为 established `[ɪˈstæblɪʃt]`（已连接），表示该连接已经建立。那么如果 第三次握手中的 ACK 包丢失的情况下，Client 向 server 端发送数据，Server 端将以 RST 包响应，就能感知到 Server 的错误。

### 如何查看 TCP 状态

在linux系统中可以通过 `netstat -napt` 命令查看。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/查看tcp状态.3k61escyq340.png)

-----

## 四次挥手过程

> 四次挥手的目的是关闭一个连接

当我们的应用程序不需要数据通信了，就会发起断开 `TCP` 连接。建立一个连接需要三次握手，而终止一个连接需要经过四次挥手。

假如客户端先发起关闭请求。

- 第一次挥手。客户端向服务端发送一个 FIN 报文，报文中会指定一个序号（假如`seq = u`)，这个时候客户端处于终止等待1 `FIN_WAIT_1` 状态，客户端会停止发送数据，主动关闭 TCP 连接，并等待服务端确认。

- 第二次挥手，服务端收到客户端的 FIN 报文后，就知道这是一个关闭请求。然后服务端向客户端返回一个确认报文，包含确认序号`ACK = 1`，`ack = seq + 1`,也就是`u+1`,并带上自己的序号`squ = v`,这时候服务端处于终止等待`CLOSE_WAIT` 状态，客户端进入`FIN_WAIT_2` 状态。TCP 处于半关闭状态，因为客户端不会发送数据了，不过服务器端有数据发送的话，客户端依然需要接收。

- 第三次挥手，如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。也就是服务端没有数据要向客户端发送了，服务端发出**连接释放报文段**包含（`FIN=1`，`ACK=1`，序号`seq=w`，确认号`ack=u+1`），服务端进入` LAST_ACK`（最后确认）状态，等待客户端的确认。

- 第四次挥手。客户端收到服务器的 `FIN` 包后，向服务端返回确认报文（`ACK=1，ack=w+1`），这个时候客户端就进入了 `TIME_WAIT` （时间等待）状态。注意此时 `TCP` 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态，可以看出服务器端结束 `TCP` 连接的时间要比客户端早一些。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/四次握手.7do6qsang0g.jpg)

### 为什么连接的时候是三次握手，关闭的时候却是四次握手

> 三次握手中，因为当`Server`端收到`Client`端的`SYN`连接请求报文后，可以直接发送`SYN+ACK`报文。

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。

### TIME_WAIT 为什么要等于`2MSL`

`TIME_WAIT`是指四次挥手中客户端接收了服务端的`FIN`报文并发送`ACK`报文给服务器后，仍然需要等待`2MSL`时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入`CLOSED`状态了，但是我们必须假设网络是不可靠的，有可能最后一个`ACK`丢失。如果客户端发送的`ACK`发生丢失，服务器会再次发送`FIN`报文给客户端，所以`TIME_WAIT`状态就是用来重发可能丢失的`ACK`报文。`Linux` 系统停留在 `TIME_WAIT` 的时间为固定的 `60` 秒。

TIME_WAIT 等待 2 倍的 MSL，因为网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

注意：**只有发起连接终止的一方会进入 TIME_WAIT 状态**。

#### MSL 与 TTL 的区别

 MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。 

> TTL 字段在 IP 头部，是 IP 数据报可以经过的最大路由数

#### Time_wait状态的链接过多会怎样

- 第一是内存资源占用，这个目前看来不是太严重，基本可以忽略。

- 第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768～61000 ，*也可以通过`net.ipv4.ip_local_port_range`指定*，如果 TIME_WAIT 状态过多，会导致无法创建新连接。

#### 如何优化Time_wait

- 一个暴力的方法是通过 `sysctl` 命令，将系统值调小。这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置，并且只打印出警告信息。这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，**不推荐使用**。

- **调低 TCP_TIMEWAIT_LEN，重新编译系统**，这个方法是一个不错的方法，缺点是需要“一点”内核方面的知识，能够重新编译内核。我想这个不是大多数人能接受的方式。

- `SO_LINGER` (停留) 的设置，我们可以通过设置套接字选项，来设置调用 `close` 或者 `shutdown` 关闭连接时的行为。不过是一个非常危险的行为，不值得提倡

- Linux 还提供了一种比较安全的方法，就是设置`net.ipv4.tcp_tw_reuse`选项，从协议角度理解如果是安全可控的，可以复用处于 TIME_WAIT 的套接字为新的连接所用。

> sysctl 命令 调低， tcp_timewait_len 重新编译，SO_LINGER，net.ipv4.tcp_tw_reuse

### 如果已经建立了连接，但是客户端突然出现故障了怎么办

`TCP` 有一个保持活跃的机制叫做 `Keep-Alive`。显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为`2`小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送`10`个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

-----

## TCP怎么保证可靠传输的

- **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- **数据校验**：`TCP`报文头有校验和，用于校验报文是否损坏。
- **数据合理分片和排序**：`tcp`会按最大传输单元(MTU)合理分片，接收方如果收到的数据不按顺序的时候，就会对它重新排序再交给应用层。
  - 而对于UDP：`IP`数据报如果大于1500字节，也就是大于`MTU`。这个时候就会对数据包进行分片，让每一片都少于`MTU`，由于`UDP`的特性，有些分片会被丢弃，所以导致最终无法重组数据包，导致丢弃整个UDP数据报。
- **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

> 拥塞控制有四种算法，**慢启动、拥塞避免，快速重传和快速恢复**


### RTT 和 RTO 是什么

RTT 就是数据从网络一端传送到另一端所需要的时间，也就是数据包的往返时间

RTO 是超时重传时间，RTO 的值非常重要，因为精确的测量超时时间 RTO 可以让我们冲床机制更加高效

> 超时重传时间 RTO 》 报文往返时间 RTT

### 滑动窗口

在数据包传输过程中有一个问题，就是 **数据包的往返时间越长，通信的效率就越低**

为了解决这个问题，所以 TCP 就引入了 窗口 这个概念，即使在 往返时间较长的情况下，它也不会降低网络通信的效率。

