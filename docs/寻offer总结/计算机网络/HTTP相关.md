
- [OSI与TCP/IP各层结构与功能](#osi与tcpip各层结构与功能)
- [DNS 是什么](#dns-是什么)
- [DNS 的工作原理](#dns-的工作原理)
  - [DNS查询方式有哪些？](#dns查询方式有哪些)
  - [`DNS`解析过程](#dns解析过程)
  - [为什么域名解析用`UDP`协议？](#为什么域名解析用udp协议)
  - [为什么 DNS 区域传送用TCP协议](#为什么-dns-区域传送用tcp协议)
- [为什么服务器要设置缓存?如何实现的？](#为什么服务器要设置缓存如何实现的)
- [说一下HTTP协议](#说一下http协议)
  - [HTTP常见字段](#http常见字段)
  - [HTTP常见状态码](#http常见状态码)
  - [HTTP请求方法你知道多少？](#http请求方法你知道多少)
  - [GET 和 POST 的区别](#get-和-post-的区别)
  - [一次完整的HTTP请求过程包括哪些内容（HTTP工作流程）](#一次完整的http请求过程包括哪些内容http工作流程)
- [HTTP 1.1 协议的优化](#http-11-协议的优化)
- [HTTP2 相对于 HTTP1 做了哪些提升](#http2-相对于-http1-做了哪些提升)
  - [HTTP是无状态的，那么怎么保存客户端的状态呢](#http是无状态的那么怎么保存客户端的状态呢)
    - [什么是cookie 技术](#什么是cookie-技术)
    - [什么是`Session` 机制](#什么是session-机制)
    - [`Cookie`和 `Session`有什么区别](#cookie和-session有什么区别)
- [`HTTP` 和 `HTTPS`的区别，由`HTTP`升级为`HTTPS`需要做哪些操作](#http-和-https的区别由http升级为https需要做哪些操作)
  - [什么是SSL/TLS ？](#什么是ssltls-)
  - [SSL/TLS协议基本流程](#ssltls协议基本流程)
  - [SSL/TLS 建立过程(握手过程)](#ssltls-建立过程握手过程)
    - [RSA 算法的缺陷](#rsa-算法的缺陷)
- [`HTTPS`的请求的过程，怎么确保安全性](#https的请求的过程怎么确保安全性)
  - [数字证书](#数字证书)
  - [如何保证公钥不被篡改？](#如何保证公钥不被篡改)
- [在浏览器中输入`URL`后执行的全部过程](#在浏览器中输入url后执行的全部过程)
  - [详细说这个过程](#详细说这个过程)
  - [现代浏览器在与服务器建立了一个 `TCP` 连接后是否会在一个 `HTTP` 请求完成后断开](#现代浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开)
  - [`HTTP`长连接和短连接的区别](#http长连接和短连接的区别)
  - [`http/1.0`和`http/1.1`的区别](#http10和http11的区别)
  - [一个`TCP`可以对应几个`HTTP`请求](#一个tcp可以对应几个http请求)
  - [一个 `TCP` 连接中 `HTTP` 请求发送可以一起发送么](#一个-tcp-连接中-http-请求发送可以一起发送么)
  - [为什么有的时候刷新页面不需要重新建立 SSL 连接？](#为什么有的时候刷新页面不需要重新建立-ssl-连接)
  - [浏览器对同一 `Host` 建立 `TCP` 连接到数量有没有限制？](#浏览器对同一-host-建立-tcp-连接到数量有没有限制)

---------

## OSI与TCP/IP各层结构与功能

- OSI的分层(7层)：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
- TCP/IP(4层)：数据链路层、网络层、传输层、应用层
- 五层协议(5层)：物理层、数据链路层、网络层、运输层、应用层

每一层的作用：

- 物理层：负责底层数据传输，就是为数据链路层提供二进制传输服务。如网线；网卡标准。 （比特`Bit`）

- 数据链路层：接收来自物理层的数据，并封装成帧，传送到网络层；如网卡`MAC`地址。（帧Frame），ARP，STP

- 网络层：定义`IP`编址，定义路由选择功能；如不同设备的数据转发。（包Packet），IP，ICMP

- 传输层：主要负责端到端之间传输数据；如 `TCP`、`UDP`。（段 Segments）

- 会话层：负责在网络中的两节点之间建立、维持和终止通信；如一个软件的数据分发给另一个软件。

- 表示层：数据格式标识，基本压缩加密功能。

- 应用层：各种应用软件，包括 `Web` 应用。HTTP，HTTPS，DNS，RTMP、FTP



## DNS 是什么

DNS（Domain Name System）是域名解析系统，就是在因特网上作为域名和IP地址相互映射的分布式数据库系统，能够使用户更方便的去访问互联网，而不用去记住一连串数字的`IP`地址。

通过主机名最终得到这个主机名对应的`IP`地址，这个过程就做**域名解析**

通俗的说就是我们更习惯去记住一个网站的名字而不是这个网站的`IP`地址，比如`www.baidu.com`,而不是记住它的`ip`地址，比如：`167.23.10.2`。

## DNS 的工作原理

将主机域名转换为`ip`地址，属于**应用层协议**，使用`UDP`传输。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/dns-01.5hnf2qy1yyw0.png)

`DNS`解析有两种方式：**递归查询**和**迭代查询**

一、主机 向 本地域名服务器的查询一般都是采用**递归查询**。<br>
二、本地域名服务器 向 根域名服务器的查询的**迭代查询**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/DNS查询图解.7jshddthzvo0.png)

### DNS查询方式有哪些？

- 递归解析

当局部`DNS`服务器自己不能回答客户机的`DNS`查询时，它就需要向其他`DNS`服务器进行查询。**一般是先向该域名的根域名服务器查询，再由根域名服务器一级级向下查询**。最后得到的查询结果返回给局部`DNS`服务器，再由局部`DNS`服务器返回给客户端。

- 迭代解析

局部`DNS`服务器不是自己向其他`DNS`服务器进行查询，**而是把能解析该域名的其他`DNS`服务器的`IP`地址返回给客户端`DNS`程序**，客户端`DNS`程序再继续向这些`DNS`服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：`baidu.com`的服务器`ip`地址在`192.168.4.5`这里，你自己去查吧。

### `DNS`解析过程

- 客户机提出域名解析请求，并将该请求发送给本地的域名服务器。

- 当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该记录项，则本地的域名服务器就直接把查询的结果返回。
  
- 如果没有，就到互联网中根服务器去查找，获取`.com`的顶级域名服务器

- 然后在`.com`的顶级域名服务器中进行查找，比如说获取`google.com`的授权域名服务器

- 在`google.com`的授权域名服务器中查找主机`www.google.com`的`IP`地址，最后将`IP`地址返回给计算机。

- 计算机获得`www.google.com`的`IP`地址后，用户就可以访问这个网站了。

### 为什么域名解析用`UDP`协议？

因为`UDP`快啊！`UDP`的`DNS`协议只要一个请求、一个应答就好了。

而使用基于`TCP`的`DNS`协议要三次握手建立连接、然后再进行发送数据，最后通过四次挥手关闭连接，但是`UDP`协议传输内容不能超过`512`字节。

不过客户端向`DNS`服务器查询域名，一般返回的内容都不超过`512`字节，所以用`UDP`传输即可。

一般`DNS`区域传送用的才是`TCP`协议

### 为什么 DNS 区域传送用TCP协议

> 区域传送是指将一个区域文件复制到多个`DNS`服务器的过程<br>
> `DNS`主从复制，就是将主`DNS`服务器的解析库复制传送至从`DNS`服务器，进而从服务器就可以进行正向、反向解析了.

因为`TCP`协议可靠性好啊！

因为你要从主`DNS`上复制内容，肯定要保证可靠性啊，`UDP`是不保证传输的可靠性的。

还有，`TCP`协议的传输内容比较大，`UDP`要求传输的内容不能超过`512`字节，如果同步的数据超过`512`那肯定不行呀。

所以用`TCP`协议比较好。


## 为什么服务器要设置缓存?如何实现的？

**原因**

- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。

**实现方法**

- 让代理服务器进行缓存；
- 让客户端浏览器进行缓存。


## 说一下HTTP协议

`HTTP`协议属于**应用层**协议，超文本传输协议，端口号是`80`。`HTTP`协议被用于网络中两台计算机间的通信，相比于`TCP/IP`这些底层协议，`HTTP`协议更像是高层标记型语言，*浏览器根据从服务器得到的`HTTP`响应体中分别得到报文头，响应头和信息体（`HTML`正文等），之后将`HTML`文件解析并呈现在浏览器上。*


### HTTP常见字段

- Host: 客户端发送请求时，用来指定服务器的域名。有了host字段，就可以将请求发往**同一台服务器上的不同网站**了。'Host: www.AAA.com'
- Content-Length: 表示服务器返回的数据长度
- Connection: 一般用于客户段要求服务端使用 TCP 持久连接。HTTP/1.1 默认是持久连接，但是为了兼容老版本的 HTTP，需要制定 Connection 首部字段的值为 Keep-alive
- Content-Type: 告诉客户端，本次数据时什么格式，也就是数据类型。
- Content-Encoding: 表示服务器返回的数据用了什么压缩方法，比如：gzip。


### HTTP常见状态码

```
100 ：服务器已经接收到一部分请求，等待其余部分
200 ：请求成功，成功返回网页
206 ：HTTP分块下载或者断点续传，返回数据的一部分而不是全部
301 ：资源（网页等）被永久转移到其它`URL`
302 ：资源（网页等）被临时转移到其它`URL`
401 ：未授权，需要身份验证
403 ：服务器拒绝请求
404 ：请求的网页或资源不存在
500 ：内部服务器错误，无法完成请求
502 ：错误网关
503 ：服务器无法使用，服务器临时过载或宕机
504 ：网关超时
```

1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。



### HTTP请求方法你知道多少？

客户端发送的   **请求报文** 第一行为请求行，包含了方法字段。

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。

`HTTP1.0` 定义了三种请求方法： `GET`, `POST` 和 `HEAD`方法。

`HTTP1.1` 新增了六种请求方法：`OPTIONS`、`PUT`、`PATCH`、`DELETE`、`TRACE` 和 `CONNECT` 方法。

| 序  号 | 方法    | 描述                                                         |
| :----- | :------ | :----------------------------------------------------------- |
| 1      | GET     | 请求指定的页面信息，并返回实体主体。                         |
| 2      | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3      | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| 4      | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| 5      | DELETE  | 请求服务器删除指定的页面。                                   |
| 6      | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7      | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8      | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9      | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

### GET 和 POST 的区别

1. `get`是从服务器上获取数据，`post`向服务器传送数据

2. `get`把请求的数据放在`url`上， 以`?`分割`URL`和传输数据，参数之间以`&`相连，所以`get`不太安全。而`post`把数据放在`HTTP`的包体内（`requrest body`）

3. `get`提交的数据最大是`2k`（ 限制实际上取决于浏览器）， `post`理论上没有限制。

4. `GET`产生一个`TCP`数据包，浏览器会把`http header`和`data`一并发送出去，服务器响应`200`(返回数据); `POST`产生两个`TCP`数据包，浏览器先发送`header`，服务器响应`100 continue`，浏览器再发送`data`，服务器响应`200 ok`(返回数据)。

5. `GET`请求会被浏览器主动缓存，而`POST`不会，除非手动设置。

6. 本质区别：`GET`是幂等的，而`POST`不是幂等的

   > 这里的幂等性：多次执行操作结果是系统的。就是为了保证请求方法不会破坏服务器上的资源。

  `GET`方法是安全幂等且幂等的，因为它是**只读**操作，无论操作多少次，服务器上的数据都是安全的，且每次返回的结果也是相同的。

### 一次完整的HTTP请求过程包括哪些内容（HTTP工作流程）

- 建立起客户机和服务器连接。
- 建立连接后，客户机发送一个请求给服务器。
- 服务器收到请求给予响应信息。
- 客户端浏览器将返回的内容解析并呈现，断开连接。

##  HTTP 1.1 协议的优化

- 第一个思路是，**通过缓存技术来避免发送 HTTP 请求**

客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。

> 那缓存是如何做到的呢？

> 客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。

> 这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。读取本次磁盘的速度肯定比网络请求快得多.


- 第二个思路是，**减少 HTTP 请求的次数**，有以下的方法：

  - **减少重定向请求次数**：如果服务器上一个资源从 URL1 迁移到 URL2，但是客户端不知情还访问 URL1，这时候服务端会返回一个 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。
  - **合并请求**：把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。进而减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。


- 第三思路是，**通过压缩响应资源，降低传输资源的大小，**从而提高传输效率，所以应当选择更优秀的压缩算法。


> 缓存--避免 HTTP 请求，重定向和合并请求--减少 HTTP 请求，压缩相应资源

-------

## HTTP2 相对于 HTTP1 做了哪些提升

第一点，对于常见的 HTTP 头部通过静态表和 Huffman 编码的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立动态表，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。

不过，动态表并也非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP/2 连接时长或者请求次数。

第二点，**HTTP/2 实现了 Stream 并发**，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 才可以并发，即使乱序发送帧也没问题，但是同一个 Stream 里的帧必须严格有序。

另外，可以根据资源的渲染顺序来设置 Stream 的优先级，从而提高用户体验。

第三点，服务器支持主动推送资源，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE (push_promise )帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。

>  `HTTP/2` 通过 Stream 的并发能力，解决了 `HTTP/1`队头阻塞的问题，

> 但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。   
> HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

> 这个问题在 `HTTP/3` 协议解决了，因为这是 TCP 协议自身的问题，直接放弃 TCP 协议，转而使用 UDP 协议作为传输层协议

> 记忆：    
> 1.头部通过 静态表 和 Huffman 编码的方式减少体积  ，还可以建立动态表（也不是无限大）      
> 2.HTTP/2 实现了 Stream 并发，解决了 `HTTP/1`队头阻塞的问题，减少 tcp 握手，同一个 ID 可以乱序并发    
> 3.发出 push_promise 帧


### HTTP是无状态的，那么怎么保存客户端的状态呢

#### 什么是cookie 技术
  
cookie 技术可以用来解决 HTTP 请求和相应无状态问题，相当于客户端第一次请求后，服务器会下发一个装有客户端信息的[小贴纸],后续客户端请求服务器的时候，带上这个[小贴纸]，服务器就能认得了了。

`Cookie` 一般用来保存用户信息 比如在 `Cookie` 中保存已经登录过得用户信息，下次访问网站的时候就会自动帮你登陆。

一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 `Token` 在 `Cookie` 中，下次登录的时候只需要根据 `Token` 值来查找用户即可(为了安全考虑，重新登录一般要将 `Token` 重写)；

#### 什么是`Session` 机制

也**可以使用`Session` 机制来解决 HTTP 无状态这个问题**，

- `Session` 的主要作用**就是通过服务端记录用户的状态**。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 `HTTP` 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 `Session`，过了时间限制，就会销毁这个`Session`）。

> - 在服务端保存 `Session` 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库`redis`保存)。既然 `Session` 存放在服务器端，   

- 那么我们**如何实现 `Session `跟踪呢**？

大部分情况下，我们都是通过在 `Cookie` 中附加一个 `Session ID` 来方式来跟踪。

#### `Cookie`和 `Session`有什么区别

`Cookie` 和 `Session`都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

- 》》》说上面的

- `Cookie` 数据保存在客户端(浏览器端)`，Session` 数据保存在服务器端。

- `Cookie` 存储在客户端中，而`Session`存储在服务器上，相对来说 `Session` 安全性更高。如果使用 `Cookie` 的一些敏感信息不要写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。



## `HTTP` 和 `HTTPS`的区别，由`HTTP`升级为`HTTPS`需要做哪些操作

- `http` 是超文本传输协议，信息是明文传输的， `https` 则是具有安全性的 `ssl` 加密传输协议
- `http` 和 `https` 使用的是完全不同的连接方式，用的端口也不一样，`http`是 80 ，`https`是 `443`
- `http` 的连接很简单，是无状态的； `HTTPS` 协议比 `http` 协议更加安全。

- `HTTPS`协议[**使用混合加密和摘要算法**]解决了`HTTP`协议的一些不足，因为 `HTTP`：
  - 1.通信使用明文（不加密），内容可能会被盗取
  - 2.不验证通信方身份，因此可能遭遇伪装
  - 3.无法证明报文的完整性（即准确性），所以可能已遭篡改      

> HTTP+加密+认证+完整性保护=HTTPS

由`HTTP`升级为`HTTPS`需要到 `CA` 申请证书，一般免费证书较少，因此需要一定费用


### 什么是SSL/TLS ？

`SSL`：(Secure Socket Layer，**安全套接字层**)，**SSL是传输层的协议**。

`TLS`：**安全传输层协议**(`TLS`)用于在两个通信应用程序之间提供保密性和数据完整性。

`SSL/TLS`协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

### SSL/TLS协议基本流程

- 客户端向服务端所有服务端的公钥
- 双方进行协商，也就是「会话秘钥」
- 双方采用会话秘钥进行加密通信

> 前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。

### SSL/TLS 建立过程(握手过程)

- 第一次握手：客户端会向到服务端发送一个 Client Hello 的消息，这个消息中有 客户端使用的 TLS 版本号，支持的密码套件，以及生成的随机数，这个随机数会被服务器保留，这个随机数是生成对 对称秘钥 的材料之一

- 第二次握手：当服务端收到 Client Hello 消息后，会确认 TLS 是否支持，从密码套件列表中选择一个密码套件，以及生成随机数。接着返回 Server Hello 消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数，还有从客户端的密码套件中选出的 密码套件。同时包含 CA 数字证书。

- 第三次握手：客户端检查 CA 数字证书的真实性，如果是有效的，客户端会生成一个随机数，用服务器的 RSA 公钥加密这个随机数，然后传给服务端，服务端收到之后用 RSA 私密进行解密，得到客户端的随机数。

- 第四次握手：服务器也是同样的操作，如果双方都验证加密和解密没有问题，那么握手就完成了。

> 1.Client --> TLS版本号，密码套件列表，随机数 --> Server   
> 2.Server --> TLS版本号，密码套件，随机数，CA --> Client     
> 3.检查CA真实性，生成随机数，客户端用 RSA 公钥加密，服务端用 RSA 私钥解密    
> 4.服务器童谣操作


#### RSA 算法的缺陷

使用 RSA 密钥协商算法的最大问题是不支持前向保密。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

为了解决这一问题，于是就有了 **DH 密钥协商算法**

DH 密钥交换过程中，即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是实时生成的，实现前向保密。


## `HTTPS`的请求的过程，怎么确保安全性

`https`包括**非对称加密**和**对称加密**两个阶段，在客户端与服务器建立连接的时候使用**非对称加密**，连接建立以后使用的是**对称加密**。

（1）客户端向服务器端发起`SSL`连接请求；<br>
（2）服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥<br>
（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端<br>
（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，<br>
（5）进行数据传输，服务器和客户端用相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，也就是即使第三方获得数据包，也无法对其进行加密，解密和篡改。<br>


### 数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

但是这里存在一个问题，如何保证公钥不被篡改。

所以就需要借助 **CA** （数字证书认证机构），将服务器公钥放在数字证书中，保证公钥的可信。

- 首先是服务器把自己的公钥注册到 CA
- CA 用自己的私钥将服务器的公钥弄成数字签名，并颁发数字证书
- 然后服务器将 服务器的公钥和 CA 的数字签名(组成**数字证书**)发送给客户端
- 客户端拿到服务器的数字证书后，使用 CA 的公钥确认数字证书的真实性
- 如果确定是真实后就用公钥加密信息成密文后发送给服务端
- 服务端用私钥进行解密 

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/数字证书工作流程01.5cveh79fxy40.webp)



### 如何保证公钥不被篡改？

将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。

**公钥加密计算量太大，如何减少耗用的时间**？

每一次对话（`session`），客户端和服务器端都生成一个"**对话密钥**"（`session key`），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。
- （1） 客户端向服务器端索要并验证公钥。
- （2） 双方协商生成"对话密钥"。
- （3） 双方采用"对话密钥"进行加密通信。上面过程的前两步，又称为"握手阶段"（handshake）。



## 在浏览器中输入`URL`后执行的全部过程

1. 首先是域名解析，客户端使用`DNS`协议将`URL`解析为对应的`IP`地址；

2. 然后建立`TCP`连接，客户端与服务器通过三次握手建立`TCP`连接；
   
3. 接着是`http`连接，客户端向服务器发送`http`连接请求； （`http`连接无需额外连接，直接通过已经建立的`TCP`连接发送）
   
4. 服务器对客户端发来的`http`请求进行处理，并返回响应；
   
5. 客户端接收到`http`响应，将结果渲染展示给用户。

![](./img/输入url.png)


### 详细说这个过程

- **解析 URL**

首先浏览器做的第一步工作就是要对 URL 进行解析，从而生发送给 Web 服务器的请求信息

- **生成 HTTP 请求信息**

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

- **DNS 域名解析**

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。

但在发送之前，还需要进行 DNS 域名解析，就是**查询服务器域名对应的 IP 地址**

- **协议栈**

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

此外 IP 中还包括 ICMP 协议和 ARP 协议。

    1）ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。

    2）ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

- **TCP** 

HTTP 是基于 TCP 协议传输的，TCP 传输数据之前，要先三次握手建立连接，

- **IP**

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

在 IP 协议里面需要有**源地址 IP**和 **目标地址 IP**：

1）源地址IP，即是客户端输出的 IP 地址；

2）目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP

- 然后生成 IP 头部，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。

- 接下来需要 ARP 协议帮我们找到路由器的 MAC 地址

ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

- 接着就到网卡、交换机、路由器

- 最终到达服务器

服务器会一次解析 Mac 头部，IP 头部，TCP 头部，TCP 头部里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址

然后按照相同的方式返回给客户端，客户端收到 HTTP 响应报文之后就可以渲染给用户了。

- 最后客户端向服务器发起了 TCP 四次挥手，至此双方的连接就断开了


### 现代浏览器在与服务器建立了一个 `TCP` 连接后是否会在一个 `HTTP` 请求完成后断开
### `HTTP`长连接和短连接的区别
### `http/1.0`和`http/1.1`的区别

在 `HTTP 1.0` 中，一个服务器在发送完一个 `HTTP` 响应后，会断开 `TCP` 连接。也就是**短连接**，但是这样每次请求都会重新建立和断开 `TCP` 连接，代价过大。


`HTTP 1.1` 默认开启持久连接,也就是**长连接**。也就是说一个`HTTP`请求结束之后并不会断开 TCP 连接，除非将`Connection`设置为`close`。

所以，在默认情况下建立 `TCP` 连接不会断开，只有在请求报头中声明 `Connection：close`才会在请求完成后关闭连接。

**长连接和短连接的适用场景**：

- 短连接：适用于网页浏览等数据刷新频度较低的场景。

- 长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等


### 一个`TCP`可以对应几个`HTTP`请求

从上面的分析可知，如果维持连接，一个 `TCP` 连接是可以发送多个 `HTTP` 请求的。


### 一个 `TCP` 连接中 `HTTP` 请求发送可以一起发送么

`HTTP/1.1` 存在一个问题，单个 `TCP` 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠。

虽然 `HTTP/1.1` 规范中规定了 `Pipelining` 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。所以可以认为这是不可行的。

在 `HTTP2` 中由于 `Multiplexing`（多路技术） 特点的存在，多个 `HTTP` 请求可以在同一个 `TCP` 连接中并行进行。

那么在 `HTTP/1.1` 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

- 维持和服务器已经建立的 `TCP` 连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个 `TCP` 连接。

> 单个 TCP 同一时刻只能处理一个请求，Pipelining 可以解决这个问题，但是浏览器默认是关闭的，HTTP2 有 Multiplexing 多路技术      
> 多个 HTTP 可以在同一 TCP 上并行进行

### 为什么有的时候刷新页面不需要重新建立 SSL 连接？

在第一个问题的讨论中已经有答案了，`TCP` 连接有的时候会被浏览器和服务端维持一段时间。`TCP` 不需要重新建立，`SSL` 自然也会用之前的。

### 浏览器对同一 `Host` 建立 `TCP` 连接到数量有没有限制？

假设我们还处在 `HTTP/1.1` 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 `TCP` 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 `TCP` 连接发 `HTTP` 请求，那电脑或者服务器都可能受不了，要是有 `1000` 张图片的话总不能开 `1000` 个`TCP` 连接吧，你的电脑同意 `NAT` 也不一定会同意。

**有。`Chrome` 最多允许对同一个 `Host` 建立六个 `TCP` 连接。不同的浏览器有一些区别。**

如果请求都是 `HTTPS` 连接并且在同一个域名下，那么浏览器在 `SSL` 握手之后会和服务器商量能不能用 `HTTP2`，如果能的话就使用 `Multiplexing` 功能在这个连接上进行多路传输。*不过也未必会所有挂在这个域名的资源都会使用一个 `TCP` 连接去获取，但是可以确定的是 `Multiplexing` 很可能会被用到。*

如果发现用不了 `HTTP2` 呢？或者用不了 `HTTPS`（现实中的 `HTTP2` 都是在` HTTPS` 上实现的，所以也就是只能使用 `HTTP/1.1`）。那浏览器就会在一个 `HOST` 上建立多个 `TCP` 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求。

如果所有的连接都正在发送请求呢？那其他的请求就只能等了。

> 谷歌浏览器支持 6 个连接   
> 如果支持使用 HTTPS，就可以使用 multiplexing 功能进行多路传输，如果使用不了，那么浏览器只能一个 host 建立多个 tcp 连接了。
