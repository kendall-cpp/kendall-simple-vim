## 写一个单例模式

```cpp
class Singleton
{
public:
    static Singleton& Instance()
    {
        static Singleton singleton;
        return singleton;
    }
private:
    Singleton() { };
};
```

### 写一个线程安全版的单例模式

```cpp
class Singleton{
  private:
    static Singleton* instance;
    Singleton(){
      // initialize
    }
  public:
    static Singleton* getInstance(){
      if(instance==nullptr) instance=new Singleton();
      return instance;
    }
};
```
[点击查看详细：理解单例模式](/C++随记/06C++单例模式.md)

## 不使用临时变量实现`swap`函数

异或运算符`^`也称`XOR`运算符，它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号为1（真）。即`0 ^ 0 = 0`, `0 ^ 1 = 1`, `1 ^ 0 = 1`, `1 ^ 1 = 0`。

```cpp
void swap(int& a,int& b){
  a=a^b;
  b=a^b;
  a=a^b;
}
```

## 实现一个`strcpy`函数

一个完美的答案应该要考虑：

> 将字符串`src`复制给`dest`

```cpp
#include <iostream>
#include <assert.h>
#include <string.h>
using namespace std;
char *myStrcpy(char *dest, const char *src) {
    //断言，检查数据的有效性
    assert(dest != NULL && src != NULL);
    if (dest == NULL || src == NULL) {
        return NULL;
    }
    if (dest == src) {
        return dest;
    }
    int i = 0;
    while (src[i] != '\0') {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';
    return dest;
}
```


### 为什么要返回`char*`类型
为了实现链式连接。返回内容为指向目标内存的地址指针，这样可以在需要字符指针的函数中使用`strcpy`,例如`strlen(strcpy(str1, str2))`。

### 源地址和目标地址出现内存重叠时，如何保证复制的正确性

调用`c`运行库`strcpy`函数，发现即使是内存重叠，也能正常复制，但是上面的实现就不行。说明，`c`运行库中`strcpy`函数实现，还加入了检查内存重叠的机制，下面是参考代码：

```cpp
//my_memcpy实现重叠内存转移
char* my_memcpy(char* dest, const char* src, int count)
{
    //检查传入参数的有效性
    assert(NULL != dest);
    assert(NULL != src);
    if (NULL == dest || NULL == src)
         return NULL;
    char* ret = dest;
    /**
    dest和 src 的内存地址有三种排列组合：
    1. dest和 src 没有发生重叠；
    2. dest和 src 地址重叠，且 dest的地址大于 src 的地址；
    3. dest和 src 地址重叠，dest 的地址小于 src 的地址；
    第一种情况和第三种情况，直接从低位字节开始复制，即可；
    第二种情况，必须从高位字节开始复制，才能保证复制正确。
    */
    //源地址和目的地址重叠，高字节向低字节拷贝  (第二种)
    if (dest> src && dest < src + count )
    {
         dest = dest + count - 1;
         src = src + count - 1;
         while(count--)
         {
             *dest-- = *src--;
         }
    }else //源地址和目的地址不重叠，低字节向高字节拷贝 （第一和第三种）
    {
         while(count--)
         {
             *dest++ = *src++;
         }
    }
    return ret;
}

int main() {
    char str1[] = "kendall";
    char str2[] = "sunny";
    cout << myStrcpy(str2,str1) << endl;  //把str1复制给str2， kendall
    // cout << myStrcpy(str+1,str) << endl;  //error

    char str[10]="kendall"; 
    cout << my_memcpy(str+1,str,strlen(str)) << endl;  //kendall

    return 0;
}
```

### strcpy和memcpy的区别

`strcpy`和`memcpy`都是标准`C`库函数。

- `strcpy`提供了字符串的复制。即`strcpy`只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。`memcpy`提供了一般内存的复制。即`memcpy`对于不需要复制的内容没有限制，因此用途更广；
- `strcpy`只有两个参数，即遇到`‘\0’`结束复制，而`memcpy`是**根据第三个参数来决定复制的长度**。

![](./img/一点算法/strcpy-01.png)