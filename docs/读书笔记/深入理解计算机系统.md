
- [第3章 程序机器级表示](#第3章-程序机器级表示)
	- [gcc 的流程](#gcc-的流程)
	- [通过一个例子来学习汇编](#通过一个例子来学习汇编)
		- [ATT 与 Intel 汇编代码格式](#att-与-intel-汇编代码格式)
	- [数据格式](#数据格式)
	- [指令的三类操作数](#指令的三类操作数)

----

## 第3章 程序机器级表示

### gcc 的流程

> 我们都知道 gcc 命令是将源代码转化成可执行的代码

- 首先是**预处理**阶段
  - C 预处理器会插入所有用 `#include` 命令指定的文件
  - 展开所有用`#define` 声明的宏定义
  - 删除所有的注释
  - 添加行号和文件标识

```
gcc -E p1.c -o p1.i
```

- 接着是**编译**阶段
  - 编译器会进行一系列的词法分析和语法分析，得到**汇编**输出文件 p1.s

```
gcc -S p1.i -o p1.s
```

- 接下来到**汇编**
  - 汇编器会将汇编代码转化成二进制的目标代码文件
  - 目标代码是机器代码的一种形式，它包含所有指令的二进制表示
  - 注意这阶段**还没有填入全局变量的地址**

```
gcc -c p1.s -o p1.o
```

- 最后是**链接**
  - 将所有相关的文件链接起来得到 p1.out 可执行文件
  - 这阶段会将所有的目标代码文件和实现库函数（例如 printf）的代码合并

```
gcc p1.0 -o p1.out
```

> 在这个编译的过程中，编译器会完成大部分的工作，会将 C 语言提供的执行模型表示层汇编指令，汇编指令只是执行一个非常基本的操作，比如，将存放在寄存器的两个数字相加，另外，汇编代码是不区分有符号和无符号整数，不区分各种类型的指针，甚至不区分指针和整数

### 通过一个例子来学习汇编


```c
long mult2(long,long);

void multstore(long x,long y,long *dest)
{
	long t = mult2(x,y);
	*dest = t;
}
```

经过编译之后产生汇编文件

```
gcc -Og -S mstore.c 
```

> -Og 表示选择合适的优化等级。使得生成的机器代码符合原始 C代码的原始结构

通过删除冗余信息之后得到如下汇编代码

```X86asm
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
void multstore(long x,long y,long *dest)
x in %rdi, y in %rsi, dest in % rdx
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
multstore:
.LFB0:
	pushq	%rbx 			; 将寄存器 %rbx的内容压入栈
	movq	%rdx, %rbx		; 将寄存器 rdx中的 dest拷贝到 rbx中
	call	mult2			; 调用 mult2(x,y)
	movq	%rax, (%rbx)	; 存储结果到 *dest（rbx）
	popq	%rbx			; 出栈
	ret						; 返回
```

接着我们可以使用如下命令生成目标代码文件 `mstore.o`

```
 gcc -Og -c mstore.c
```

但是 `.o` 文件我们无法查看，所以我们可以通过【反汇编】来查看机器代码文件的内容。

```
$ objdump -d mstore.o

mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:   53                      push   %rbx
   1:   48 89 d3                mov    %rdx,%rbx
   4:   e8 00 00 00 00          callq  9 <multstore+0x9>
   9:   48 89 03                mov    %rax,(%rbx)
   c:   5b                      pop    %rbx
   d:   c3                      retq   
```

找左侧我们可以看到 6组十六进制的字节值，每组对应一套汇编指令。

通过观察反汇编出来的汇编代码和使用 gcc 直接编译出来的代码有些差别，它省略了指令结尾的 `q`,这些后缀是大小指示符，后面会介绍这些指示符代表的字节大小。这些指示符在大多情况下是可以被省略的。

考虑到生成可执行代码必须要有 main 函数，我们在原来的基础上加入一个 main 函数。

```c
#include <stdio.h>

void multstore(long,long,long *);

int main(){
	long d;
	multstore(2,3,&d);
	printf("2 * 3 --> %d\n",d);
	return 0;
}

long mult2(long a,long b)
{
	long s = a * b;
	return s;
}
```

我们用如下命令生成可自行文件 prog

```
gcc -Og -o prog main.c mstore.c
```

然后在对这个可执行文件进行反汇编

```
objdump -d prog 
```

其中包含如下代码

```x86asm
0000000000000741 <multstore>:
 741:   53                      push   %rbx
 742:   48 89 d3                mov    %rdx,%rbx
 745:   e8 ef ff ff ff          callq  739 <mult2>
 74a:   48 89 03                mov    %rax,(%rbx)
 74d:   5b                      pop    %rbx
 74e:   c3                      retq   
 74f:   90                      nop
```

#### ATT 与 Intel 汇编代码格式

需要说明的是，上面使用 gcc产生的汇编代码是 AT&T 格式的代码，还有一种是 Intel 格式，他们的区别见下图

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/两种汇编的区别.28waarmj82sk.png)

>- 注意 Intel 汇编语言的赋值方向是【从右到左】，而 AT&T 汇编语言是【从左到右】。		
> - AT&T 汇编语言使用【寄存器】必须在前面添加前缀 % ，使用【立即数】必须在前面添加前缀 $，比如：mov $12,%cx

### 数据格式

一般情况下，称 16 位数据类型为【字 word】，32位数据类型为【双字 double words】，64位数据类型为【四字 quad words】

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/数据类型大小.6j3e327n4fw0.png)

> 数据传送表示：movb (传送字节move byte), movw (传送字move word), movl 传送双字(move double word), and movq (传送四字move quad word)

### 指令的三类操作数

- 立即数：用来表示常数值，ATT 汇编格式中的立即数前面需要加 `$`
- 寄存器：某个寄存器的内容
- 内存应用：根据计算出来的地址访问某个内存位置 

来看看书本中 练习题 3-1

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/练习题3-1.67j29gcyx7c.png)

根据上面的寄存器和地址的值填写下表

|  操作数   | 值（填写）  | 解析  |
|  ----  | ----  | ----  |
| %rax  | 0x100 |  |
| 0x104  | 0xAB | 内存地址 |
| $0x108  | 0x108 | 立即数 |
| (%rax)  | 0xFF | |
| 4(%rax)  | 0xAB |基地址+偏移地址，4是十进制，4+0x100|
| 9(%rax,%rdx)  | 0x11 | 0x100 + 0x3 + 0x9 = 0x10C|
| 260(%rcx,%rdx)  | 0x13 | 260转成16进制是0x104，0x3+0x1+0x104 |
| 0xFC(,%rcx,4)  | 0xFF | 0x1 * 4 + 0xFC = 0x100 |
| (%rax,%rdx,4)  | 0x11 | 0x100 + 0x3*4 = 0x10C |

