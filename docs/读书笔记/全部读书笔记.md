

USB开发大全
嵌入式Linux应用开发完全手册

深入理解linux内核  ULK 看完这本书可以直接去看代码了
ARM  Linux内核源码剖析(带书签目录完整版)
linux设备驱动程序 LDD
深入Linux设备驱动程序内核机制
深入理解linux虚拟内存管理  LVMM
linux内核卷1
深入linux内核架构（选读）
内核源代码情景分析



-----

# USB 开发大全

# 深入理解linux内核

## 内存地址

- 逻辑地址

每一个逻辑地址都又一个段 和 偏移量 组成，偏移量指明了从段开始的地方到实际地址之间的距离

- 线性地址

是一个 32 为无符号整数，可以用来表示高 4GB 的地址，通常用 16进制表示。

- 物理地址

用于内存芯片级内存单元寻址，这些地址与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址有 32 为或者 36 位无符号整数表示。


**内存控制单元（MMU）** ： 逻辑地址 -->（分段单元）--> 线性地址 --> （分页单元） --> 物理地址

在多处理器系统中，所有的 CPU 都共享同一内存，所以，ARM 由同一 CPU 并发地访问。但是 RAM 芯片的读写操作是串行执行的，所以需要 **内存仲裁器** 来控制 CPU 对 ARM 芯片的访问，当 ARM 芯片空闲时，就允许 CPU 访问，如果 ARM 芯片繁忙时，就延迟 CPU 的访问。

**单处理器系统需要内存仲裁器么？**

同样需要，因为单处理器中有 DMA 控制器，DMA 控制器与 CPU 并发操作

## 硬件中的分段

一个逻辑地址由两部分组成

- 段标识符（段选择符）

一个 16 位长的字段，称为段选择符

- 偏移量

是一个 32 位长的字段

为了方便找到 段选择符 ，处理器提供了段寄存器，用来存放段选择符，段寄存器有： cs，ss，ds，es，fs 和 gs 。

- cs: 代码段寄存器，指向包含程序指令的段

> 还有一个另外的功能，就是指明 CPU 的当前特权等级（CPL），0 代表最高优先级，3 代表最低优先级，linux 只用 0 级和 3 级，**分表表示内核态和用户态**。

- ss：栈段寄存器，指向包含当前程序栈的段
- ds：数据段寄存器，指向包含静态数据或者全局数据段

## 内存管理


在 Linux 中，内存分配的基本单元是“页框”（page frame），其大小通常为 4KB。但是，Linux 支持通过配置来使用不同大小的页框，最大可支持 2MB 大小的页框。

> 为什么呢？

采用 4KB 作为页框大小是出于多方面的考虑。首先，这个大小足够小以满足大多数应用程序的内存管理需求，同时也不会占用过多的内存。其次，较小的页框大小可以提高内存空间的利用率，并减少对磁盘 I/O 的访问次数，从而提高系统性能。此外，4KB 页框大小也便于与硬件平台集成，因为这是目前主流处理器架构的标准大小。在某些场景下，如大规模内存数据库或缓存服务器等应用，可能需要使用更大的页面来提高系统性能，但这通常需要进行额外的配置和调优。

### linux常见物理内存的管理方法有哪些

- Buddy 系统（伙伴系统）：将可用物理内存块分成大小相等的块，并使用二叉树结构来跟踪每个块的可用性和状态。
  - 通常用于分配**大块内存**。它的优势是简单高效，适用于对**内存碎片化要求较低**的场景。
  - 例如数组、图像、视频或者音频文件。这些对象通常需要长期存储，并且在整个程序运行期间都可能被多次访问

- Slab分配器：是一种基于对象缓存的内存分配器，用于分配小块内存。它通过缓存已经分配过的对象来提高性能，并具有更好的内存碎片管理能力。它的优势是可以减少内存碎片化，适合频繁分配和释放**小块内存**的场景。
  - 例如，在编写循环或函数时，可能需要使用小块内存来存储迭代器或局部变量。通常用于存储数据结构、变量、指针等较小的数据对象

#### Buddy系统原理

Buddy系统是一种内存管理算法，用于动态分配和释放内存。它的原理是将可用内存空间划分为大小相等且为2的幂次方的块，每个块可以被分配或释放。

- 当需要分配内存时，Buddy系统会搜索可用块列表，直到找到一个大小合适的块来满足需求。如果系统需要存储一个大块数据但没有足够大的空闲空间可用，则系统会把一个更大的空闲空间划分成两个较小的部分来存储这个大块数据。这两个较小的块就称为 buddy ，其中一个块提供所需的内存，另一个块则继续被分割，直到找到足够小的块。

- 当需要释放内存时，Buddy 系统会检查该块的“伙伴”是否也处于空闲状态。如果伙伴块为空闲，则两者将合并成一个更大的块。该块然后与其它同样大小的块结合在一起，形成一个更大的可用块，以便于将来使用。

这种方式可以减少内存碎片化，提高内存利用率，并允许高效地分配和释放内存。

#### slab 分配器的原理

当操作系统需要分配一块内存时，通常会使用 slab 分配器来管理这些内存块。Slab 分配器的基本原理是将一块大内存空间按照固定大小的块划分成若干个 slabs（或称对象池）。每个 slab 包含多个同样大小的内存块，当需要分配内存时，可以从一个未满的 slab 中分配一个内存块来使用。

为了更好地管理内存，slab 分配器还会维护三个链表，分别是**空闲链表**、**局部缓存链表**和**全局缓存链表**。其中，

- 空闲链表用于保存所有未被分配的内存块；
- 局部缓存链表用于保存当前正在被使用的 slab；
- 全局缓存链表用于保存未满的 slab。

>  未满的 slab 是什么?		
> 已经被分配但未被完全使用的内存块。这些内存块仍然被 Slab 分配器所持有，并且可以被快速重用，以避免频繁的内存分配和释放操作。

当需要分配内存时，slab 分配器会首先检查局部缓存链表中是否有可用的 slab，如果存在，则直接从该 slab 中分配内存块；如果不存在，则会从全局缓存链表中获取一个未满的 slab，并将其移到局部缓存链表中，再从该 slab 中分配内存块。如果全局缓存链表也没有可用的 slab，则会重新申请一块大内存空间，并将其划分成多个 slabs，然后从其中一个新的 slab 中分配内存块。

使用 slab 分配器能够有效地防止内存碎片和频繁的系统调用，提高系统性能和稳定性。