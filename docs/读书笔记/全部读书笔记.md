

USB开发大全
深入理解linux内核  ULK 看完这本书可以直接去看代码了
ARM  Linux内核源码剖析(带书签目录完整版)
linux设备驱动程序 LDD
深入Linux设备驱动程序内核机制
深入理解linux虚拟内存管理  LVMM
linux内核卷1




-----

# 内存寻址

## 内存地址

- 逻辑地址

每一个逻辑地址都又一个段 和 偏移量 组成，偏移量指明了从段开始的地方到实际地址之间的距离

- 线性地址

是一个 32 为无符号整数，可以用来表示高 4GB 的地址，通常用 16进制表示。

- 物理地址

用于内存芯片级内存单元寻址，这些地址与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址有 32 为或者 36 位无符号整数表示。


**内存控制单元（MMU）** ： 逻辑地址 -->（分段单元）--> 线性地址 --> （分页单元） --> 物理地址

在多处理器系统中，所有的 CPU 都共享同一内存，所以，ARM 由同一 CPU 并发地访问。但是 RAM 芯片的读写操作是串行执行的，所以需要 **内存仲裁器** 来控制 CPU 对 ARM 芯片的访问，当 ARM 芯片空闲时，就允许 CPU 访问，如果 ARM 芯片繁忙时，就延迟 CPU 的访问。

**单处理器系统需要内存仲裁器么？**

同样需要，因为单处理器中有 DMA 控制器，DMA 控制器与 CPU 并发操作

## 硬件中的分段

一个逻辑地址由两部分组成

- 段标识符（段选择符）

一个 16 位长的字段，称为段选择符

- 偏移量

是一个 32 位长的字段

为了方便找到 段选择符 ，处理器提供了段寄存器，用来存放段选择符，段寄存器有： cs，ss，ds，es，fs 和 gs 。

- cs: 代码段寄存器，指向包含程序指令的段

> 还有一个另外的功能，就是指明 CPU 的当前特权等级（CPL），0 代表最高优先级，3 代表最低优先级，linux 只用 0 级和 3 级，**分表表示内核态和用户态**。

- ss：栈段寄存器，指向包含当前程序栈的段
- ds：数据段寄存器，指向包含静态数据或者全局数据段

## 内存管理

### 什么是页

内存管理单元（MMU ， 管理内存并把虚拟地址转换成物理地址的硬件）通常以【页】为单位进行处理，所以 MMU 以 页 大小为单位管理系统中的页表。 从虚拟内存的角度来看，**页就是最小单位**。

- 32 位体系结构支持 4KB 的页
- 64 位体系结构支持 8KB 的页

> 在支持4KB页大小并有1GB物理内存的机器上，物理内存会被划分为多少个页 ?

使用 4KB 的页大小，并有 1GB 物理内存，那么物理内存会被划分为 1GB / 4KB = 262144 个物理页。

- $4KB = 4\times1024 = 4096字节$
- $1 GB = 1024 \times 1024 \times 1024 字节$

```c
//include/linux/mm_types.h 
struct page {
	unsigned long flags;		// 存放 页 的状态，这些状态包括页是不是脏页，是不是被锁定在内存中等
      // flag 每一位都单独表示一个状态，所以它至少同时可以表示 32 种状态，对应 page-flags.h 的 enum pageflags 中
	atomic_t _count;		//这一页被引用的次数
  /*
  可以通过这个函数进行检查，_count = -1 表示当前页没有被引用
  //include/linux/mm.h
  static inline int page_count(struct page *page)
  {
    return atomic_read(&compound_head(page)->_count); // 返回 0 就是空闲页
  }
  */
	union {
		atomic_t _mapcount;	/* Count of ptes mapped in mms,
					 * to show when page is mapped
					 * & limit reverse map searches.
					 */
		struct {		/* SLUB */
			u16 inuse;
			u16 objects;
		};
	};
	union {
	    struct {
		unsigned long private;		/* Mapping-private opaque data:
					 	 * usually used for buffer_heads
						 * if PagePrivate set; used for
						 * swp_entry_t if PageSwapCache;
						 * indicates order in the buddy
						 * system if PG_buddy is set.
						 */
		struct address_space *mapping;	/* If low bit clear, points to
						 * inode address_space, or NULL.
						 * If page mapped as anonymous
						 * memory, low bit is set, and
						 * it points to anon_vma object:
						 * see PAGE_MAPPING_ANON below.
						 */
	    };
	    struct kmem_cache *slab;	/* SLUB: Pointer to slab */
	    struct page *first_page;	/* Compound tail pages */
	};
	union {
		pgoff_t index;		/* Our offset within mapping. */
		void *freelist;		/* SLUB: freelist req. slab lock */
	};
	struct list_head lru;		/* Pageout list, eg. active_list
					 * protected by zone->lru_lock !
					 */

	void *virtual;			//页的虚拟地址

};
```

注意：page 的结构与物理页相关，而不是与虚拟页相关，这个数据结构仅仅是描述当前时刻相关的物理页中存放的东西，只是描述物理页内存本身，而不是存放物理内存中的数据。

> **既然不存放数据，内核为什么需要用 page 这个数据结构来管理系统中所有的页呢？**

因为内核需要知道一个页是不是空闲页，如果这个页已经被分配，那么就要知道这个页被谁拥有，是 用户空间的进程？动态分配的内核数据？静态内核代码 还是 页高速缓冲等等。因此系统为每个物理页都分配一个这样的结构体。

### 什么是区(内存区域)

> **为什么要有区？**

由于硬件的限制，有些页位于内存中特定的物理地址上，这些页不能用于一些特定的任务，真实因为有这样的限制，所以内核把页又划分成不同的区。也就是对页进行分组。

> **有哪些特殊的限制呢？**

- 一些硬件只能用于某些特定的内存地址来执行 DMA （直接内存访问）
- 某些体系结构的内存的物理寻址范围比虚拟地址的寻址范围大得多，所以就有一些内存不能永远地映射到内核空间上。

> **linux 中主要分层几种区？**

- ZONE_DMA —— 在 64 位系统中，该区域仍然包含了可以被 DMA 控制器直接寻址的物理内存，但是其地址必须小于等于 4GB。
- ZONE_DMA32 —— 在 64 位系统中，该区域已经没有太大的作用，因为 64 位系统可以使用更大的地址空间来访问内存。因此，ZONE_DMA32 在 64 位系统中一般不会被使用。
- ZONE_NORMAL —— 该区域包含了物理内存地址位于 ZONE_DMA 和 ZONE_HIGHMEM 之间的所有内存，在 64 位系统中，该区域的大小比 32 位系统要大得多，通常可以达到数百 GB。
- ZONE_HIGHEM —— 在 64 位系统中，该区域也包含了无法被内核直接映射到虚拟地址空间的物理内存，但是相对于 32 位系统而言，其范围更大，可以覆盖从 4GB 开始到机器上安装的最大内存容量的所有内存。

```c
// nclude/linux/mmzone.h 
enum zone_type {
  ZONE_DMA,
  ZONE_DMA32,
  ZONE_NORMAL,
  ZONE_HIGHMEM,
  //其他两个一般不用
}
```

-----


在 Linux 中，内存分配的基本单元是“页框”（page frame），其大小通常为 4KB。但是，Linux 支持通过配置来使用不同大小的页框，最大可支持 2MB 大小的页框。

> 为什么呢？

采用 4KB 作为页框大小是出于多方面的考虑。首先，这个大小足够小以满足大多数应用程序的内存管理需求，同时也不会占用过多的内存。其次，较小的页框大小可以提高内存空间的利用率，并减少对磁盘 I/O 的访问次数，从而提高系统性能。此外，4KB 页框大小也便于与硬件平台集成，因为这是目前主流处理器架构的标准大小。在某些场景下，如大规模内存数据库或缓存服务器等应用，可能需要使用更大的页面来提高系统性能，但这通常需要进行额外的配置和调优。

### linux常见物理内存的管理方法有哪些

- Buddy 系统（伙伴系统）：将可用物理内存块分成大小相等的块，并使用二叉树结构来跟踪每个块的可用性和状态。
  - 通常用于分配**大块内存**。它的优势是简单高效，适用于对**内存碎片化要求较低**的场景。
  - 例如数组、图像、视频或者音频文件。这些对象通常需要长期存储，并且在整个程序运行期间都可能被多次访问

- Slab分配器：是一种基于对象缓存的内存分配器，用于分配小块内存。它通过缓存已经分配过的对象来提高性能，并具有更好的内存碎片管理能力。它的优势是可以减少内存碎片化，适合频繁分配和释放**小块内存**的场景。
  - 例如，在编写循环或函数时，可能需要使用小块内存来存储迭代器或局部变量。通常用于存储数据结构、变量、指针等较小的数据对象

#### Buddy系统原理

Buddy系统是一种内存管理算法，用于动态分配和释放内存。它的原理是将可用内存空间划分为大小相等且为2的幂次方的块，每个块可以被分配或释放。

- 当需要分配内存时，Buddy系统会搜索可用块列表，直到找到一个大小合适的块来满足需求。如果系统需要存储一个大块数据但没有足够大的空闲空间可用，则系统会把一个更大的空闲空间划分成两个较小的部分来存储这个大块数据。这两个较小的块就称为 buddy ，其中一个块提供所需的内存，另一个块则继续被分割，直到找到足够小的块。

- 当需要释放内存时，Buddy 系统会检查该块的“伙伴”是否也处于空闲状态。如果伙伴块为空闲，则两者将合并成一个更大的块。该块然后与其它同样大小的块结合在一起，形成一个更大的可用块，以便于将来使用。

这种方式可以减少内存碎片化，提高内存利用率，并允许高效地分配和释放内存。

#### slab 分配器的原理

当操作系统需要分配一块内存时，通常会使用 slab 分配器来管理这些内存块。Slab 分配器的基本原理是将一块大内存空间按照固定大小的块划分成若干个 slabs（或称对象池）。每个 slab 包含多个同样大小的内存块，当需要分配内存时，可以从一个未满的 slab 中分配一个内存块来使用。

为了更好地管理内存，slab 分配器还会维护三个链表，分别是**空闲链表**、**局部缓存链表**和**全局缓存链表**。其中，

- 空闲链表用于保存所有未被分配的内存块；
- 局部缓存链表用于保存当前正在被使用的 slab；
- 全局缓存链表用于保存未满的 slab。

>  未满的 slab 是什么?		
> 已经被分配但未被完全使用的内存块。这些内存块仍然被 Slab 分配器所持有，并且可以被快速重用，以避免频繁的内存分配和释放操作。

当需要分配内存时，slab 分配器会首先检查局部缓存链表中是否有可用的 slab，如果存在，则直接从该 slab 中分配内存块；如果不存在，则会从全局缓存链表中获取一个未满的 slab，并将其移到局部缓存链表中，再从该 slab 中分配内存块。如果全局缓存链表也没有可用的 slab，则会重新申请一块大内存空间，并将其划分成多个 slabs，然后从其中一个新的 slab 中分配内存块。

使用 slab 分配器能够有效地防止内存碎片和频繁的系统调用，提高系统性能和稳定性。