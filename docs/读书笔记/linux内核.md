

----

> 深入理解linux内核、linux内核设计与实现、linux内核完全注释、linux内核设计的艺术、linux内核代码情景分析

> https://www.bilibili.com/video/BV1tQ4y1d7mo?spm_id_from=333.337.search-card.all.click


----

## 保护模式的内存管理

> 内存寻址就是寻找在存储在内存中的某个数据对象的地址

对于 80X86CPU 而言，其寻址方式是使用**分段机制**，就是把内存空间分成一个或者多个段，这样寻址就需要使用【段地址+偏移地址】的方式进行。前面我们说过，段地址使用 16 位的值来指定，段内偏移地址可以使用 32 位的值来指定。程序中由 16位的段和 32位的偏移地址构成的 48位地址成为一个逻辑地址（**虚拟地址**）。

但是这个虚拟地址不能直接访问物理内存，需要使用地址变化机制将它映射到物理地址上。我们先来看下虚拟地址映射到物理地址的整个过程。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/虚拟地址映射物理地址.6c253teb9zc0.png)

上图的流程中我们可以看到有【分段机制】和【分页机制】两种，其实分段机制是总是会使用的，而分页机制是可以选择是否启用的。接下来就详细学习一下这两种机制。

### 分段机制

程序是由若干个逻辑分段组成的，比如有 代码分段、数据分段、栈段、堆段。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来**。如果 CPU 有多个程序或者任务在运行，那么每个程序就可以分配各自的 段 。

每个段都有一个段描述符，段描述符中包含段的基地址，段界限（段的长度）和段的保护属性。段描述符保存在段描述符表中。

> 虚拟地址是图和转换成一个线性地址的？

- 1.使用段选择符中的段索引，在段描述符表中找到相应的段描述符

- 2.利用段描述符来检验段的访问权限和访问范围，因为要确定该段是可以被访问的，并且偏移量在段界限内。

- 3.在段描述符中拿到段基地址 + 偏移量，最后形成一个线性地址。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/分段机制.3fnh44bzkik0.png)

### 段描述符表

段描述符表是段描述符的一个数组，描述符表的长度是可以变的，最多可以包含 8192 个 8 字节的段描述符。有两种段描述符表：**全局描述符表** GDT（Global descriptor table）；**局部描述符表** LDT（Local descriptor table）。

下面给出了描述符表的结构

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/段描述符表.grp5yntvbyw.png)

- 全局描述符表寄存器 GDTR 中存放全局描述符表 GDT的 32 位线性地址和 16 位表界限长度值，在机器刚加电或者处理器复位后，基地址被默认设置为 0，而长度值被设置成 0xFFFF

- 局部描述符表寄存器 LDTR 中存放全局描述符表 LDT的 32 位线性地址、16 位表界限长度值和 描述符属性值。在机器刚加电或者处理器复位后，段选择符和基地址被默认设置为 0，而长度值被设置成 0xFFFF

虚拟地址空间被分割成大小相等的两部分，一部分是有 GDT 来映射的全局虚拟地址空间，另一部分是有 LDT 来映射的局部虚拟地址空间。

